{"/ark/architecture/":{"data":{"":"Ark uses an archetype-based architecture.\nThis chapter explains the concept and Ark’s take on it.","archetypes#Archetypes":"The ASCII graph below illustrates the concept of archetypes in an entity-component system.\nEach archetype represents a unique combination of components and stores data for all entities that share exactly that combination. You can think of an archetype as a table, where rows correspond to entities and columns represent components. The first column always contains the entity identifiers themselves.\nIn the illustration below, the first archetype stores all entities that have components A, B and C, as well as their associated component data. The second archetype contains all entities with A and C, and their corresponding data.\nEntities Archetypes Bitmasks Queries E E Comps |0| |2|A|B|C| 111... \u003c-. \u003c---. |1|---. |8|A|B|C| | | |2| '--\u003e|1|A|B|C| | | |3| |3|A|B|C| |--Q(A,C) | |4| | 101... | |6| .--\u003e|7|A|C| 101... \u003c-' |--Q(B) |7|---' |6|A|C| | 010... |8| |4|A|C| | |9|---. | |.| | |5|B|C| 011... \u003c---' |.| '--\u003e|9|B|C| |.| |.| \u003c===\u003e [Entity pool] Illustration of Ark’s archetype-based architecture.\nEach archetype maintains a bitmask that encodes its unique component composition. This compact representation enables fast bitwise comparisons, allowing queries to quickly determine which archetypes are relevant.\nOnce matching archetypes are identified, queries can linearly iterate over their entities, a process that is both highly efficient and cache-friendly, thanks to the tight memory layout of archetype tables.\nComponent access through queries is extremely fast (below 1ns per component) due to predictable memory access patterns and minimal indirection.","details#Details":"The previous explanation offers a simplified view of archetypes. To fully understand the system, we need to consider two advanced concepts: the Archetype Graph and Entity relationships.\nArchetype graph When components are added to or removed from an entity, the system must locate the corresponding archetype that matches the new component composition. To accelerate this process, Ark uses a dynamic graph of archetype nodes (or just nodes). The figure below illustrates the concept.\nEach arrow represents the transition between two archetypes when a single component is added (solid arrow head) or removed (empty arrow head). Following these transitions, the archetype resulting from addition and/or removal of an arbitrary number of components can be found easily.\nIllustration of the archetype graph. Letters represent components. Boxes represent archetype nodes. Arrows represent transitions when a single component is added or removed.\nNodes and transitions are created on demand. When searching for an archetype, the algorithm proceeds transition by transition. When looking for the next archetype, established transitions are checked first. If this is not successful, the resulting component mask is used to search through all nodes. On success, a new connection is established. If the required node was still not found, a new node is created. Then, the next transition it processed and so on, until the final node is found. Only then, an archetype is created for the node.\nAs a result, the graph will usually not be fully connected. There will also not be all possible nodes (combinations of components) present. Nodes that are only traversed by the search but never receive entities contain no archetype and are called inactive.\nDuring a game or simulation run, the graph stabilizes quickly. Then, only the fast following of transitions is required to find an archetype when components are added or removed. Transitions are stored in the nodes with lookup approx. 10 times faster than Go’s map.\nEntity relations Earlier, archetypes were described as flat tables. However, with Ark’s Entity relationships feature, archetypes can contain multiple sub-tables, each corresponding to a unique combination of relation targets.\nAs an example, we have components A, B and R, where R is a relation. Further, we have two parent entities E1 and E2. When you create some entities with components A B R(E1) and A B R(E2), i.e. with relation targets E1 and E2, the following archetype is created:\nArchetype [ A B R ] | |--- E1 E Comps | |3|A|B|R| | |6|A|B|R| | |7|A|B|R| | '--- E2 E Comps |4|A|B|R| |5|A|B|R| When querying without specifying a target, the archetype’s tables are simply iterated if the archetype matches the filter. When querying with a relation target (and the archetype matches), the table for the target entity is looked up in a standard Go map.\nIf the archetype contains multiple relation components, a map lookup is used to get all tables matching the target that is specified first. These tables are simply iterated if no further target is specified. If more than one target is specified, the selected tables are checked for these further targets and skipped if they don’t match.\nArchetype removal Normal archetype tables without a relation are never removed, because they are not considered temporary. For relation archetypes, however, things are different. Once a target entity dies, it will never appear again (actually it could, after dying another 4,294,967,294 times).\nIn Ark, empty tables with a dead target are recycled. They are deactivated, but their allocated memory for entities and components is retained. When a table in the same archetype, but for another target entity is requested, a recycled table is reused if available. To be able to efficiently detect whether a table can be removed, a bitset is used to keep track of entities that are the target of a relation.","entity-recycling-and-generations#Entity recycling and generations":"The entity list also includes entities that are no longer alive because they have been removed from the World. These inactive entities are recycled when new entities are created, allowing efficient reuse of memory and IDs.\nTo safely distinguish between recycled and stale references, each entity carries a generation counter. This counter is incremented every time an entity is “reincarnated”. It ensures that references to old or removed entities can be detected and invalidated, and that different “incarnations” of same entity ID can be distinguished.","performance#Performance":"Archetypes are primarily designed to maximize iteration speed by grouping entities with identical component sets into tightly packed memory layouts. This structure enables blazing-fast traversal and component access during queries.\nHowever, this optimization comes with a trade-off: Adding or removing components from an entity requires relocating it to a different archetype, essentially moving all of its component data. This operation typically costs ≈20ns per involved component.\nTo reduce the number of archetype changes, it is recommended to add/remove/exchange multiple components at the same time rather than one after the other. Further, operations can be batched to manipulate many entities in a single command. See chapter Performance tips for more details.\nFor detailed benchmarks and performance metrics, refer to the Benchmarks chapter.","world-entity-access#World entity access":"To retrieve components for a specific entity outside of query execution, the World maintains a list indexed by entity ID (as shown leftmost in the diagram above). Each entry in this list points to the entity’s archetype and the position within the archetype’s table.\nThis setup enables fast random access to component data, though slightly slower than query-based iteration (≈2ns vs. \u003c1ns), due to the additional indirection.\nNote that the entity list also contains entities that are currently not alive, because they were removed from the World. These entities are recycled when new entities are requested from the world. Therefore, besides the ID shown in the illustration, each entity also has a generation variable. It is incremented on each “reincarnation”, which allows to distinguish recycled from dead entities, as well as from previous or later “incarnations”."},"title":"Architecture"},"/ark/batch/":{"data":{"":"In an archetype-based ECS, creation and removal of entities or components are relatively costly operations. For these operations, Ark provides batched versions. This allows to create or manipulate a large number of entities much faster than one by one. Most batch methods come in two flavors. A “normal” one, and one that runs a callback function on each affected entity.","components#Components":"Components can be added, removed or exchanged in batch operations. For these operations, Map2, Exchange2 etc. provide batch versions of the respective methods. Component batch operations take an Batch filter as an argument to determine the affected entities:\n// Create a world world := ecs.NewWorld() // Create a component mapper. mapper := ecs.NewMap2[Position, Velocity](\u0026world) // Create some entities. for range 100 { world.NewEntity() } // Create a filter. filter := ecs.NewFilter0(\u0026world) // Batch-add components. mapper.AddBatch(filter.Batch(), \u0026Position{}, \u0026Velocity{X: 1, Y: -1}) // Batch-Remove components. The optional callback is not used here. mapper.RemoveBatch(filter.Batch(), nil) // Alternatively, add and initialize components with a callback. mapper.AddBatchFn(filter.Batch(), func(entity ecs.Entity, pos *Position, vel *Velocity) { // ... }) ","creating-entities#Creating entities":"Entity creation is probably the most common use case for batching. When the number of similar entities that are to be created is known, creation can be batched with Map2.NewBatch et al.:\n// Create a component mapper. mapper := ecs.NewMap2[Position, Velocity](\u0026world) // Create a batch of 100 entities. mapper.NewBatch(100, \u0026Position{}, \u0026Velocity{X: 1, Y: -1}) Map2.NewBatchFn can be used for more flexible initialization:\n// Create a component mapper. mapper := ecs.NewMap2[Position, Velocity](\u0026world) // Create a batch of 100 entities using a callback. mapper.NewBatchFn(100, func(entity ecs.Entity, pos *Position, vel *Velocity) { pos.X = rand.Float64() * 100 pos.Y = rand.Float64() * 100 vel.X = rand.NormFloat64() vel.Y = rand.NormFloat64() }) The callback is called for each created entity, allowing to set individual values.","removing-entities#Removing entities":"Entities can be removed in batches using World.RemoveEntities:\n// Create a component mapper. mapper := ecs.NewMap2[Position, Velocity](\u0026world) // Create some entities. mapper.NewBatch(10, \u0026Position{}, \u0026Velocity{X: 1, Y: -1}) // Create a filter. filter := ecs.NewFilter2[Position, Velocity](\u0026world) // Remove all matching entities. The callback can also be nil. world.RemoveEntities(filter.Batch(), func(entity ecs.Entity) { fmt.Println(\"Removing\", entity) }) "},"title":"Batch operations"},"/ark/benchmarks/":{"data":{"":"","components#Components":"","components-batched#Components, batched":"","entities#Entities":"","entities-batched#Entities, batched":"","other#Other":"This chapter gives an overview of the runtime cost of typical Ark operations. All time information is per entity. All components used in the benchmarks have two int64 fields. Batch operations are performed in batches of 1000 entities.\nBenchmark code: benchmark/table in the GitHub repository.\nBenchmarks are run automatically in the GitHub CI, and are updated on this page on every merge into the main branch. They always reflect the latest development state of Ark.\nFor comparative benchmarks of different Go ECS implementations, see the go-ecs-benchmarks repository.\nLast run: Fri, 31 Oct 2025 16:38:10 UTC\nVersion: Ark v0.6.3\nGo version: 1.25.1\nCPU: AMD EPYC 7763 64-Core Processor\nQuery Operation Time Remark Query.Next 0.3 ns Query.Next + Query.Get 1 1.0 ns Query.Next + Query.Get 2 1.4 ns Query.Next + Query.Get 5 2.5 ns Query.Next + Query.Entity 1.2 ns Query.Next + Query.Relation 1.7 ns Filter1.Query + Query1.Close 36.9 ns Filter1.Query + Query1.Close 37.6 ns registered filter World access Operation Time Remark World.Alive 0.9 ns random, 1000 entities Map.Get 2.4 ns random, 1000 entities Map.GetUnchecked 1.8 ns random, 1000 entities Map.Has 2.2 ns random, 1000 entities Map.HasUnchecked 1.6 ns random, 1000 entities Map5.Get 5 7.8 ns random, 1000 entities Map5.HasAll 5 7.0 ns random, 1000 entities Map.GetRelation 2.6 ns random, 1000 entities Map.GetRelationUnchecked 2.1 ns random, 1000 entities Entities Operation Time Remark Entity.IsZero 0.3 ns World.NewEntity 17.4 ns memory already alloc. Map1.NewEntityFn w/ 1 Comp 36.3 ns memory already alloc. Map5.NewEntityFn w/ 5 Comps 53.5 ns memory already alloc. Map1.NewEntity w/ 1 Comp 45.1 ns memory already alloc. Map5.NewEntity w/ 5 Comps 74.0 ns memory already alloc. World.RemoveEntity 29.7 ns World.RemoveEntity w/ 1 Comp 38.0 ns World.RemoveEntity w/ 5 Comps 70.1 ns Entities, batched Operation Time Remark World.NewEntities 9.5 ns 1000, memory already alloc. Map1.NewBatchFn w/ 1 Comp 9.4 ns 1000, memory already alloc. Map5.NewBatchFn w/ 5 Comps 9.5 ns 1000, memory already alloc. World.RemoveEntities 5.7 ns 1000 World.RemoveEntities w/ 1 Comp 6.0 ns 1000 World.RemoveEntities w/ 5 Comps 7.1 ns 1000 Components Operation Time Remark Map1.AddFn 1 Comp 46.0 ns memory already alloc. Map5.AddFn 5 Comps 63.0 ns memory already alloc. Map1.AddFn 1 to 5 Comps 122.3 ns memory already alloc. Map1.Add 1 Comp 53.7 ns memory already alloc. Map5.Add 5 Comps 80.1 ns memory already alloc. Map1.Add 1 to 5 Comps 128.9 ns memory already alloc. Map1.Remove 1 Comp 54.3 ns memory already alloc. Map5.Remove 5 Comps 103.1 ns memory already alloc. Map1.Remove 1 of 5 Comps 113.7 ns memory already alloc. Exchange1.ExchangeFn 1 Comp 65.6 ns memory already alloc. Exchange1.ExchangeFn 1 of 5 Comps 121.2 ns memory already alloc. Exchange1.Exchange 1 Comp 74.6 ns memory already alloc. Exchange1.Exchange 1 of 5 Comps 129.8 ns memory already alloc. Components, batched Operation Time Remark Map1.AddBatchFn 1 Comp 4.9 ns 1000, memory already alloc. Map5.AddBatchFn 5 Comps 4.9 ns 1000, memory already alloc. Map1.AddBatchFn 1 to 5 Comps 8.4 ns 1000, memory already alloc. Map1.RemoveBatch 1 Comp 5.3 ns 1000, memory already alloc. Map5.RemoveBatch 5 Comps 6.3 ns 1000, memory already alloc. Map1.RemoveBatch 1 of 5 Comps 8.2 ns 1000, memory already alloc. Exchange1.ExchangeBatchFn 1 Comp 5.4 ns 1000, memory already alloc. Exchange1.ExchangeBatchFn 1 of 5 Comps 8.0 ns 1000, memory already alloc. Other Operation Time Remark ecs.NewWorld 22.9 μs World.Reset 81.2 ns empty world ecs.ComponentID 19.4 ns component already registered ","query#Query":"","world-access#World access":""},"title":"Benchmarks"},"/ark/cheatsheet/":{"data":{"":"Frequently used Ark APIs for quick lookup.\n➕ ➖","access-components#Access components":" ➕ ➖ Components can also be accessed for arbitrary entities, not only inside queries.\n🧩 A component mapper is required for component access outside queries Allows access to the given components.\nmapper := ecs.NewMap2[Position, Velocity](\u0026world) _ = mapper API: Map1, Map2, …\n🧩 Access components by entity entity := mapper.NewEntity(\u0026Position{X: 100, Y: 100}, \u0026Velocity{X: 1, Y: -1}) pos, vel := mapper.Get(entity) _, _ = pos, vel API: Map2.Get\n🧩 Check for existence of components for an entity entity := mapper.NewEntity(\u0026Position{X: 100, Y: 100}, \u0026Velocity{X: 1, Y: -1}) hasPosAndVel := mapper.HasAll(entity) _ = hasPosAndVel API: Map2.HasAll\n🧩 For single component access, there is a slightly more convenient mapper mapper := ecs.NewMap[Position](\u0026world) entity := mapper.NewEntity(\u0026Position{X: 100, Y: 100}) if mapper.Has(entity) { pos := mapper.Get(entity) _ = pos } API: Map","addremove-components#Add/remove components":" ➕ ➖ Components store the data that is associated to entities.\n🧩 A component mapper is required for adding and removing components It adds or removes the given components to/from entities. Component mappers should be stored and re-used for best performance.\nmapper := ecs.NewMap2[Position, Velocity](\u0026world) _ = mapper API: Map1, Map2, …\n🧩 Add and remove components to/from a single entity entity := world.NewEntity() mapper.Add( entity, \u0026Position{X: 100, Y: 100}, \u0026Velocity{X: 1, Y: -1}, ) mapper.Remove(entity) API: Map2.Add, Map2.Remove\n🧩 Add components to all entities matching a filter filter := ecs.NewFilter1[Altitude](\u0026world).Exclusive() mapper.AddBatch( filter.Batch(), \u0026Position{X: 100, Y: 100}, \u0026Velocity{X: 1, Y: -1}, ) API: Map2.AddBatch\n🧩 Add components to all entities matching a filter, with individual initialization filter := ecs.NewFilter1[Altitude](\u0026world).Exclusive() mapper.AddBatchFn( filter.Batch(), func(e ecs.Entity, pos *Position, vel *Velocity) { pos.X, pos.Y = rand.Float64()*100, rand.Float64()*100 vel.X, vel.Y = rand.NormFloat64(), rand.NormFloat64() }) API: Map2.AddBatchFn\n🧩 Remove components from all entities matching a filter. The callback can be used to do something with entities before component removal.\nfilter := ecs.NewFilter2[Position, Velocity](\u0026world) mapper.RemoveBatch( filter.Batch(), func(entity ecs.Entity) { /* ... */ }) API: Map2.RemoveBatch","create-entities#Create entities":" ➕ ➖ Entities represent the “objects” in a game or simulation.\n✨ Create an entity without components Create an entity without components:\ne := world.NewEntity() _ = e API: World.NewEntity\n✨ A component mapper is required for creating entities with components Component mappers should be stored and re-used for best performance.\nmapper := ecs.NewMap2[Position, Velocity](\u0026world) _ = mapper API: Map1, Map2, …\n✨ Create a single entity, given some components e := mapper.NewEntity( \u0026Position{X: 100, Y: 100}, \u0026Velocity{X: 1, Y: -1}, ) _ = e API: Map2.NewEntity\n✨ Create a single entity using a callback e := mapper.NewEntityFn(func(pos *Position, vel *Velocity) { pos.X, pos.Y = 100, 100 vel.X, vel.Y = 1, -1 }) _ = e API: Map2.NewEntityFn\n✨ Create many entities more efficiently, all with the same component values mapper.NewBatch( 100, \u0026Position{X: 100, Y: 100}, \u0026Velocity{X: 1, Y: -1}, ) API: Map2.NewBatch\n✨ Create many entities, using a callback for individual initialization mapper.NewBatchFn( 100, func(e ecs.Entity, pos *Position, vel *Velocity) { pos.X, pos.Y = rand.Float64()*100, rand.Float64()*100 vel.X, vel.Y = rand.NormFloat64(), rand.NormFloat64() }) API: Map2.NewBatchFn","events-and-observers#Events and observers":" ➕ ➖ Observers allow to react to ECS lifecycle events, like entity creation or component addition.\n👀 Create and register observers for ECS lifecycle events Gets notified on any creation of an entity.\necs.Observe(ecs.OnCreateEntity). Do(func(e ecs.Entity) { // Do something with the newly created entity. }). Register(\u0026world) API: Observer\n👀 Observers can filter for certain components Gets notified when a Position and a Velocity component are added to an entity.\necs.Observe(ecs.OnAddComponents). For(ecs.C[Position]()). For(ecs.C[Velocity]()). Do(func(e ecs.Entity) { // Do something with the entity. }). Register(\u0026world) API: Observer.For\n👀 Observers can process matched components Gets notified when a Position and a Velocity component are added to an entity, with both available in the callback.\necs.Observe2[Position, Velocity](ecs.OnAddComponents). Do(func(e ecs.Entity, pos *Position, vel *Velocity) { // Do something with the entity and the components }). Register(\u0026world) API: Observer1, Observer2, …\n👀 Observers can also filter for the entity composition Gets notified when a Position component is added to an entity that also has Velocity but not Altitude.\necs.Observe1[Position](ecs.OnAddComponents). With(ecs.C[Velocity]()). Without(ecs.C[Altitude]()). Do(func(e ecs.Entity, pos *Position) { // Do something with the entity and the component }). Register(\u0026world) API: Observer1.With, Observer1.Without\n📣 Custom event types can be created using a registry var registry = ecs.EventRegistry{} var OnCollisionDetected = registry.NewEventType() var OnInputReceived = registry.NewEventType() _, _ = OnCollisionDetected, OnInputReceived API: EventRegistry, EventRegistry.NewEventType\n📣 Custom events can be emitted by the user event := world.Event(OnCollisionDetected). For(ecs.C[Position]()) entity := mapper.NewEntity(\u0026Position{}, \u0026Velocity{}) event.Emit(entity) API: World.Event, Event\n📣 Custom events can be observed like pre-defined events ecs.Observe1[Position](OnCollisionDetected). Do(func(e ecs.Entity, p *Position) { // Do something with the collision entity and the component }). Register(\u0026world) API: Observer, Observer1, Observer2, …\n➕ ➖ ","filters-and-queries#Filters and queries":" ➕ ➖ Queries are the main work horse for implementing logic.\n🔍 Use filters and queries to iterate entities Filters should be stored and re-used for best performance.\nAlways create a new query before iterating.\nfilter := ecs.NewFilter2[Position, Velocity](\u0026world) query := filter.Query() for query.Next() { pos, vel := query.Get() pos.X += vel.X pos.Y += vel.Y } API: Filter1, Filter2, …, Filter2.Query, Query2.Next, Query2.Get\n🔍 Filters can match additional components For components the entities should have, but that are not accessed in the query.\nfilter := ecs.NewFilter2[Position, Velocity](\u0026world). With(ecs.C[Altitude]()) _ = filter API: Filter2.With\n🔍 Filters can exclude components filter := ecs.NewFilter2[Position, Velocity](\u0026world). Without(ecs.C[Altitude]()) _ = filter API: Filter2.Without\n🔍 Filters can be exclusive on the given components This filter matches only entities with exactly the given components.\nfilter := ecs.NewFilter2[Position, Velocity](\u0026world). Exclusive() _ = filter API: Filter2.Exclusive\n🔍 Filters can combine multiple conditions filter := ecs.NewFilter1[Position](\u0026world). With(ecs.C[Velocity]()). With(ecs.C[Altitude]()). Without(ecs.C[Health]()) _ = filter API: Filter2.With, Filter2.Without\n🔍 Access entities in query loops query := filter.Query() for query.Next() { entity := query.Entity() _ = entity } API: Query.Entity\n🔍 Queries can count entities without iterating Note that a query that is not iterated must be closed explicitly.\nquery := filter.Query() fmt.Println(query.Count()) query.Close() API: Query.Count, Query.Close","remove-entities#Remove entities":" ➕ ➖ ❌ Remove a single entity world.RemoveEntity(entity) API: World.RemoveEntity\n❌ Remove all entities that match a filter filter := ecs.NewFilter2[Position, Velocity](\u0026world).Exclusive() world.RemoveEntities(filter.Batch(), nil) API: World.RemoveEntities\n❌ With a callback to do something with entities before their removal world.RemoveEntities(filter.Batch(), func(entity ecs.Entity) { // Do something before removal }) API: World.RemoveEntities","resources#Resources":" ➕ ➖ Resources are “global”, singleton-like data structures that are not associated to a particular entity.\n📦 Adding and getting resources, the simple but slower way (≈20ns) grid := NewGrid(100, 100) ecs.AddResource(\u0026world, \u0026grid) _ = ecs.GetResource[Grid](\u0026world) API: AddResource, GetResource\n📦 For repeated access, better use a resource accessor (Get() ≈1ns) gridResource := ecs.NewResource[Grid](\u0026world) grid := gridResource.Get() _ = grid (Creating the accessor does not add the actual Grid resource!)\nAPI: Resource, Resource.Get","world-creation#World creation":" ➕ ➖ The world is the central ECS data storage. Most applications will use exactly one world.\n🌍 Create a World with default initial capacity world := ecs.NewWorld() _ = \u0026world API: World.New\n🌍 Create a World with a specific initial capacity world := ecs.NewWorld(1024) _ = \u0026world API: World.New"},"title":"Cheat sheet"},"/ark/concepts/":{"data":{"":"This chapter gives a brief explanation of ECS concepts and how they are represented in Ark.","components#Components":"Components contain the data, or state variables, associated with an entity. Each entity can have an arbitrary combination of components, but can only have one instance of each. Components can be added to and removed from entities at runtime.\nComponents are identified by their type. So e.g., all instances of Position are of the same component type. Each entity can have only one Position.\nComponents are simple Go structs and can contain variables of any type, including slices and pointers. Typically, components don’t have any functions. Particularly, contrary to object oriented programming (OOP), components don’t contain game or simulation logic. In ECS, logic is performed by systems, using queries.\nFor optimal performance and modularity, components should be small and only contain closely related state variables that are typically used together. “Good” components are e.g. Position, Velocity, Age, Sex, etc. “Bad” components are large monolithic things with many state variables like Player or Animal.\nComponents can also be labels or tags, which means that they don’t contain any data but are just used to tag entities, like Female and Male.\nA world can contain up to 256 different component types (64 with build tag ark_tiny).\nSee chapter Component operations for how to create entities with components, adding and removing components, and other details.","entities#Entities":"Entities (Entity) are used to represent the “objects” in a game or simulation. In Ark, an entity is just an opaque ID (with an associated current generation) that allows access to components associated to it.\nEntities without any components can be created through the (World):\nentity := world.NewEntity() For creating entities with components, component mappers are used. Entities can be removed or deleted like this:\nworld.RemoveEntity(entity) Entities can be stored safely, in components or elsewhere. However, always store them by value, never by pointer. When dealing with stored entities, it may be required to check whether they are still alive:\nalive := world.Alive(entity) if alive { // ... } In Ark, entities are returned to a pool when they are removed from the world. These entities can be recycled, with the same ID (Entity.ID), but an incremented generation (Entity.Gen). This allows to determine whether an entity held by the user is still alive, despite it was potentially recycled.","queries#Queries":"Queries are the core feature for writing logic in an ECS. A query iterates over all entities that possess all the component types specified by the query. Note that these entities may contain further components, which are ignored.\nFor best performance, filters are used to create queries:\n// Create a filter. filter := ecs.NewFilter2[Position, Velocity](\u0026world) // Obtain a query. query := filter.Query() // Iterate the query. for query.Next() { pos, vel := query.Get() pos.X += vel.X pos.Y += vel.Y } Filters are relatively costly to create, as they require lookup of component IDs. This takes around 20ns per component. Thus, make sure to create filters only once and store them, e.g. in systems. Then, create a new query from the filter each time before the iteration loop.\nImportant\nThe component pointers obtained from a query should never be stored outside of the current context (i.e. the query loop), as they are not persistent inside the world.\nFor advanced filters, caching and other details, see chapter Filters \u0026 queries.","relationships#Relationships":"Entity relationships are a powerful, advanced ECS feature that was first introduced by Flecs. They serve the efficient representation of entity hierarchies, groupings, or other relationships.\nRelationships can also be realized by storing entities (or lists of entities) in components. However, Ark’s relations feature allows for more efficiency and more comprehensible logic, as relationships can be used in queries.\nSome illustrative examples:\nIterate/get all game objects in a grid cell. Iterate/get all animals in a herd. Iterate/get all plants of a certain species. Build hierarchies, like a scene graph. Compared to Flecs, entity relations in Ark are more limited. Each entity can have an arbitrary number of relationships to other entities, but for each relation type (i.e. relation component), there can be only one target entity. This is primarily a performance consideration.\nFor usage and more details, see chapter Entity relationships.","resources#Resources":"Resources are singular data structures in an ECS world. As such, they can be thought of as components that exist only once and are not associated to an entity. Examples could be the current game/simulation tick, a grid that your entities live on, or an acceleration structure for spatial indexing.\nAs with components, resources are Go structs that can contain any types of variables.\n// Create a resource. var worldGrid Grid = NewGrid(100, 100) // Add it to the world. ecs.AddResource(\u0026world, \u0026worldGrid) // Elsewhere, get the resource from the world. grid := ecs.GetResource[Grid](\u0026world) See chapter Resources for more details.","systems#Systems":"Systems perform the logic of your game or simulation, using queries. Ark does not provide systems or a scheduler for them. You can create your own interface for system, matching your game engine if you are using one. Alternatively, ark-tools provides systems, a scheduler, and other useful stuff for Ark. See there for a full example.","the-world#The World":"The World (World) is the central data storage in Ark. It manages and stores entities (Entity), their components, as well as Resources.\nTo create a world with default settings, use NewWorld:\nworld := ecs.NewWorld() A world can also be configured with an initial capacity for archetypes, the entity list, etc:\nworld := ecs.NewWorld(1024) For systematic simulations, it is possible to reset a populated world for reuse:\nworld := ecs.NewWorld() // ... do something with the world. world.Reset() // ... start over again. "},"title":"Concepts"},"/ark/design/":{"data":{"":"Unlike most other ECS implementations, Ark is primarily designed for the development of scientific, individual-based models rather than for game development. This motivates some design decisions, with an emphasis on simplicity, safety and performance. Still, Ark remains perfectly usable for game development.","determinism#Determinism":"Ark guarantees deterministic and reproducible iteration order. While it doesn’t preserve insertion order or maintain consistent order across successive iterations. Both are impossible in archetype-based ECS. However, identical operations on the same World will always produce the same iteration sequence.\nThis deterministic behavior ensures that simulations yield consistent results across runs, platforms, and environments.\nTo reinforce this reliability, Ark is built with zero external dependencies. This eliminates variability introduced by third-party libraries and ensures that performance and behavior remain predictable and stable over time.","limitations#Limitations":"The number of component types per World is capped at 256, a deliberate performance-oriented decision. This constraint enables extremely fast component lookups by using compact, array-based internal representations.\nThe number of entities alive at any one time is limited to just under 5 billion (uint32 ID).\nArk is not thread-safe. This design choice avoids internal locking mechanisms, which would introduce overhead and complexity. In scientific modeling, where large numbers of simulations are often executed in parallel, this approach is more efficient and scalable.\nConcurrent query execution is yet possible if the queries don’t access the same entities concurrently. For example, entity relationships can be used to split up entities of the same archetype to process them in parallel. See the section Parallel queries and the respective stand-alone example.","performance-driven-design#Performance-driven design":"Ark is engineered for high performance, especially in large-scale simulations. Key optimizations include:\nArchetype-based storage: Enables cache-friendly memory layout and fast iteration. Batch operations: Mass manipulation of entities and components is highly efficient. Reusable filters and mappers: Designed to minimize allocations and maximize throughput. For hard numbers on performance, see the Benchmarks chapter. For a comparison that shows Ark outperforming many other Go ECS libraries, see the go-ecs-benchmarks repository.","safety-first-panic-on-violations#Safety first: panic on violations":"Ark puts an emphasis on safety and on avoiding undefined behavior. It panics on unexpected operations, like removing a dead entity, adding a component that is already present, or attempting to change a locked world.\nWhile panics may seem unidiomatic in Go, Ark’s scientific context demands strict behavior. Explicit error handling in performance-critical paths is impractical, and silent failures are unacceptable. For details, see the Error handling chapter.","simple-and-type-safe-api#Simple and type-safe API":"The World object provides a minimal and pure ECS core — a data store for entities and components with robust querying and iteration capabilities.\nArk does not include built-in systems or an update loop. These are left to the user, offering flexibility and control. For a more complete, ready-to-use setup, see the ark-tools module.\nArk leverages Go’s generics to provide a fully type-safe API for queries, component access and manipulation. This design offers several advantages:\nCompile-time safety: Component types are enforced at compile time, eliminating runtime type assertions and reducing the risk of subtle bugs. Zero reflection: Unlike many ECS frameworks that rely on reflection, Ark’s generic API avoids it entirely, leading to superb performance. Optimized queries: Generic filters and mappers are statically typed and reusable, minimizing allocations and maximizing throughput. For scenarios where component types are only known at runtime, such as serialization, deserialization, or dynamic inspection, Ark offers an additional Unsafe API. While it sacrifices compile-time type safety, this API provides maximum flexibility for advanced use cases. It complements the generic API by enabling dynamic access to components, making Ark suitable for tooling, debugging, and data-driven workflows where static typing isn’t feasible."},"title":"Design philosophy"},"/ark/errors/":{"data":{"":"Ark puts an emphasis on safety, and on avoiding undefined and unexpected behavior. It panics on unexpected operations, like removing a dead entity, adding a component that is already present, or attempting to change a locked world.\nThis may not seem idiomatic for Go. However, explicit error handling in performance hot spots is not an option. Neither is silent failure or ignoring invalid operations, given the scientific background of Ark. Therefore, Ark panics.","debug-build#Debug build":"Ark tries to give informative error messages on invalid operations or other misuse. In performance hot spots like queries or component mappers, however, this is not always possible without degrading performance. As an example, Query2.Get panics (deliberately) with invalid memory address or nil pointer dereference when called after query iteration finished.\nIn case of uninformative errors in queries or mappers, try to run your project using the build tag ark_debug:\ngo run -tags ark_debug . This enables additional checks for more helpful error messages, at the cost of a performance penalty. Note that this does not change when Ark panics, it only improves the error messages.\nIf you still get uninformative error messages from inside Ark, please create an issue! Either there are missing debug checks, or there is a bug in Ark."},"title":"Error handling"},"/ark/events/":{"data":{"":"Ark provides an event system with observers that allow an application to react on events, such as adding and removing components and entities.\nObservers can filter for the events they are interested in, in several ways. A callback function is executed for the affected entity whenever an observer’s filter matches.\nIn addition to built-in lifecycle events like OnCreateEntity or OnAddComponents, Ark supports custom event types that enable domain-specific triggers. These events can be emitted manually and observed with the same filtering and callback mechanisms, making them ideal for modeling interactions such as user input, synchronization, or game logic.\nObservers are lightweight, composable, and follow the same declarative patterns as Ark’s query system. They provide fine-grained control over when and how logic is executed. This design encourages a declarative, data-driven approach while maintaining performance and flexibility.","combining-multiple-types#Combining multiple types":"Observers can be combined to react to multiple event types in a single callback function. Below is a combination of observers to react on component addition as well as removal. The callback is set up to be able to distinguish between these event types (if needed).\n// Common callback fn := func(evt ecs.EventType, entity ecs.Entity, pos *Position) { if evt == ecs.OnAddComponents { // do something } if evt == ecs.OnRemoveComponents { // do something } } // Observer for adding components ecs.Observe1[Position](ecs.OnAddComponents). Do(func(e ecs.Entity, pos *Position) { fn(ecs.OnAddComponents, e, pos) }). Register(\u0026world) // Observer for removing components ecs.Observe1[Position](ecs.OnRemoveComponents). Do(func(e ecs.Entity, pos *Position) { fn(ecs.OnRemoveComponents, e, pos) }). Register(\u0026world) ","custom-events#Custom events":"Custom events in Ark allow developers to define and emit their own event types, enabling application-specific logic such as UI interactions, game state changes, or other domain-specific triggers. These events support the same filtering and observer mechanisms as built-in events.\nDefine custom event types using EventRegistry.NewEventType:\n// Create an event registry var registry = ecs.EventRegistry{} // Create event types var OnCollisionDetected = registry.NewEventType() var OnInputReceived = registry.NewEventType() var OnLevelLoaded = registry.NewEventType() var OnTimerElapsed = registry.NewEventType() Ideally, custom event types are stored as global variables of the applications.\nAlteratively, if all custom events are defined in one place, constants can be used like this:\nconst ( OnCollisionDetected ecs.EventType = iota OnInputReceived OnLevelLoaded OnTimerElapsed ) Use custom events like this:\n// Create an event registry var registry = ecs.EventRegistry{} // Define the event type var OnTeleport = registry.NewEventType() // Add an observer for the event type ecs.Observe1[Position](OnTeleport). Do(func(e ecs.Entity, p *Position) { /*...*/ }). Register(\u0026world) // Define the event event := world.Event(OnTeleport). For(ecs.C[Position]()) // Emit the event for an entity event.Emit(entity) Observers might not be interested in components, or in more than one component. This is also supported by custom events:\n// Create an event registry var registry = ecs.EventRegistry{} // Define the event type var OnClick = registry.NewEventType() // Emit a click event world.Event(OnClick).Emit(uiElement) Here, the event is created and emitted in a single expression. However, it is recommended to store events after construction and to reuse them for Emit. Reusing event instances is especially important for events with components, as it avoids repeated lookups and improves runtime efficiency. The overhead for component ID lookup is ≈20ns per component.\nFor custom events, observer filters work exactly the same as for predefined events. The components in the generic parameters of the observer, as well as those defined by For, are matched against the components of the event. With, Without and Exclusive are matched against the entity for which the event is emitted.\nNote that custom events can also be emitted for the zero entity:\n// Create an event registry var registry = ecs.EventRegistry{} // Define the event type var OnGameOver = registry.NewEventType() // Emit a game over event world.Event(OnGameOver).Emit(ecs.Entity{}) ","event-timing#Event timing":"The time an event is emitted relative to the operation it is related to depends on the event’s type. The observer callbacks are executed immediately by any emitted event.\nEvents for entity creation and for adding or setting components are emitted after the operation. Hence, the new or changed components can be inspected in the observer’s callback. If emitted from individual operations, the world is in an unlocked state when the callback is executed. Contrary, when emitted from a batch operation, the world is locked.\nEvents for entity or component removal are emitted before the operation. This way, the entity or component to be removed can be inspected in the observer’s callback. In this case, the world is locked when the callback is executed.\nFor batch operations, all events are emitted before or after the entire batch, respectively. For batch creation or addition, events are emitted after the potential batch callback is executed for all entities, allowing to inspect the result.\nNote that observer order is undefined. Observers are not necessarily triggered in the same order as they were registered.","event-types#Event types":"Observers are specific for different event types, and each observer can react only to one type. See below for how to react on multiple different types.\nOnCreateEntity — Emitted after a new entity is created. OnRemoveEntity — Emitted before an entity is removed. OnAddComponents — Emitted after components are added to an existing entity. OnRemoveComponents — Emitted before components are removed from an entity. OnSetComponents — Emitted after existing components are set from an entity. OnAddRelations — Emitted after relation targets are added to an entity.* OnRemoveRelations — Emitted before relation targets are removed from an entity.* If multiple components are added/removed/set for an entity, one event is emitted for the entire operation.\n* Relation events are emitted when entities with relations are created or removed, when relation components are added or removed, as well as when targets are set without changing components.","example#Example":" // Create an observer ecs.Observe1[Position](ecs.OnCreateEntity). Do(func(e ecs.Entity, pos *Position) { fmt.Printf(\"%#v\\n\", pos) }). Register(\u0026world) // Create an entity that triggers the observer's callback builder := ecs.NewMap1[Position](\u0026world) builder.NewEntity(\u0026Position{X: 10, Y: 11}) ","filters#Filters":"Observers filter for the components specified by their generic parameters. Additional components can be specified using Observer.For, but these are not directly accessible in the callback.\nObservers only trigger when all specified components (in parameters and in For) are affected in a single operation. For example, if an observer watches Position and Velocity, both must be added or removed together for the observer to activate\nFurther, events can be filtered by the composition of the affected entity via Observer.With, Observer.Without and Observer.Exclusive, just like queries.\nExamples (leaving out observer registration):\nBoth observers are triggered when an entity with Position is created. The first one has direct access to the component in the callback while the second does not:\necs.Observe1[Position](ecs.OnCreateEntity). Do(func(e ecs.Entity, p *Position) { /* ... */ }) ecs.Observe(ecs.OnCreateEntity). With(ecs.C[Position]()). Do(func(e ecs.Entity) { /* ... */ }) Both observers are triggered when an entity with Position as well as Velocity is created:\necs.Observe2[Position, Velocity](ecs.OnCreateEntity). Do(func(e ecs.Entity, p *Position, v *Velocity) { /* ... */ }) ecs.Observe1[Position](ecs.OnCreateEntity). With(ecs.C[Velocity]()). Do(func(e ecs.Entity, p *Position) { /* ... */ }) An observer that is triggered when any entity is created, irrespective of its components:\necs.Observe(ecs.OnCreateEntity). Do(func(e ecs.Entity) { /* ... */ }) An observer that is triggered when a Position component is added to an existing entity:\necs.Observe1[Position](ecs.OnAddComponents). Do(func(e ecs.Entity, p *Position) { /* ... */ }) An observer that is triggered when a Position component is added to an entity that has Velocity, but not Altitude (or rather, had before the operation):\necs.Observe1[Position](ecs.OnAddComponents). With(ecs.C[Velocity]()). Without(ecs.C[Altitude]()). Do(func(e ecs.Entity, p *Position) { /* ... */ }) "},"title":"Event system"},"/ark/generated/_benchmarks/":{"data":{"":"Last run: Fri, 31 Oct 2025 16:38:10 UTC\nVersion: Ark v0.6.3\nGo version: 1.25.1\nCPU: AMD EPYC 7763 64-Core Processor","components#Components":" Operation Time Remark Map1.AddFn 1 Comp 46.0 ns memory already alloc. Map5.AddFn 5 Comps 63.0 ns memory already alloc. Map1.AddFn 1 to 5 Comps 122.3 ns memory already alloc. Map1.Add 1 Comp 53.7 ns memory already alloc. Map5.Add 5 Comps 80.1 ns memory already alloc. Map1.Add 1 to 5 Comps 128.9 ns memory already alloc. Map1.Remove 1 Comp 54.3 ns memory already alloc. Map5.Remove 5 Comps 103.1 ns memory already alloc. Map1.Remove 1 of 5 Comps 113.7 ns memory already alloc. Exchange1.ExchangeFn 1 Comp 65.6 ns memory already alloc. Exchange1.ExchangeFn 1 of 5 Comps 121.2 ns memory already alloc. Exchange1.Exchange 1 Comp 74.6 ns memory already alloc. Exchange1.Exchange 1 of 5 Comps 129.8 ns memory already alloc. ","components-batched#Components, batched":" Operation Time Remark Map1.AddBatchFn 1 Comp 4.9 ns 1000, memory already alloc. Map5.AddBatchFn 5 Comps 4.9 ns 1000, memory already alloc. Map1.AddBatchFn 1 to 5 Comps 8.4 ns 1000, memory already alloc. Map1.RemoveBatch 1 Comp 5.3 ns 1000, memory already alloc. Map5.RemoveBatch 5 Comps 6.3 ns 1000, memory already alloc. Map1.RemoveBatch 1 of 5 Comps 8.2 ns 1000, memory already alloc. Exchange1.ExchangeBatchFn 1 Comp 5.4 ns 1000, memory already alloc. Exchange1.ExchangeBatchFn 1 of 5 Comps 8.0 ns 1000, memory already alloc. ","entities#Entities":" Operation Time Remark Entity.IsZero 0.3 ns World.NewEntity 17.4 ns memory already alloc. Map1.NewEntityFn w/ 1 Comp 36.3 ns memory already alloc. Map5.NewEntityFn w/ 5 Comps 53.5 ns memory already alloc. Map1.NewEntity w/ 1 Comp 45.1 ns memory already alloc. Map5.NewEntity w/ 5 Comps 74.0 ns memory already alloc. World.RemoveEntity 29.7 ns World.RemoveEntity w/ 1 Comp 38.0 ns World.RemoveEntity w/ 5 Comps 70.1 ns ","entities-batched#Entities, batched":" Operation Time Remark World.NewEntities 9.5 ns 1000, memory already alloc. Map1.NewBatchFn w/ 1 Comp 9.4 ns 1000, memory already alloc. Map5.NewBatchFn w/ 5 Comps 9.5 ns 1000, memory already alloc. World.RemoveEntities 5.7 ns 1000 World.RemoveEntities w/ 1 Comp 6.0 ns 1000 World.RemoveEntities w/ 5 Comps 7.1 ns 1000 ","other#Other":" Operation Time Remark ecs.NewWorld 22.9 μs World.Reset 81.2 ns empty world ecs.ComponentID 19.4 ns component already registered ","query#Query":" Operation Time Remark Query.Next 0.3 ns Query.Next + Query.Get 1 1.0 ns Query.Next + Query.Get 2 1.4 ns Query.Next + Query.Get 5 2.5 ns Query.Next + Query.Entity 1.2 ns Query.Next + Query.Relation 1.7 ns Filter1.Query + Query1.Close 36.9 ns Filter1.Query + Query1.Close 37.6 ns registered filter ","world-access#World access":" Operation Time Remark World.Alive 0.9 ns random, 1000 entities Map.Get 2.4 ns random, 1000 entities Map.GetUnchecked 1.8 ns random, 1000 entities Map.Has 2.2 ns random, 1000 entities Map.HasUnchecked 1.6 ns random, 1000 entities Map5.Get 5 7.8 ns random, 1000 entities Map5.HasAll 5 7.0 ns random, 1000 entities Map.GetRelation 2.6 ns random, 1000 entities Map.GetRelationUnchecked 2.1 ns random, 1000 entities "},"title":"_benchmarks"},"/ark/operations/":{"data":{"":"Components contain the data associated to your game or simulation entities. This chapter explains how to manipulate them. For general information on components, see section Components in chapter Concepts.","component-access#Component access":"Component mappers are also used to access components for specific entities:\n// Create a component mapper. mapper := ecs.NewMap2[Position, Velocity](\u0026world) // Create an entity with components. entity1 := mapper.NewEntity( \u0026Position{X: 0, Y: 0}, \u0026Velocity{X: 1, Y: -1}, ) // Get mapped components for an entity. pos, vel := mapper.Get(entity1) Important\nThe component pointers obtained should never be stored outside of the current context, as they are not persistent inside the world.","component-exchange#Component exchange":"Adding and removing components are relatively costly operations, as entities and their components must be moved between archetypes. It is most efficient to perform component additions and removals in a single operation, instead of using multiple operations.\nFor that sake, Ark provides Exchange1, Exchange2 etc., to do additions and removals in one go. It adds the components given by the generics, and removes those specified with Exchange2.Removes.\n// Create an entity with components. mapper := ecs.NewMap2[Position, Velocity](\u0026world) entity := mapper.NewEntity(\u0026Position{}, \u0026Velocity{}) // Create an exchange helper. exchange := ecs.NewExchange1[Altitude](\u0026world). Removes(ecs.C[Position](), ecs.C[Velocity]()) exchange.Exchange(entity, \u0026Altitude{Z: 100}) ","component-mappers#Component mappers":"Component mappers Map1, Map2 etc. are helpers that allow to create entities with components, to add components to entities, and to remove components from entities. They are parametrized by the component types they handle.\n// Create a component mapper. mapper := ecs.NewMap2[Position, Velocity](\u0026world) // Create an entity with components. entity1 := mapper.NewEntity( \u0026Position{X: 0, Y: 0}, \u0026Velocity{X: 1, Y: -1}, ) // Create an entity without components. entity2 := world.NewEntity() // Add components to it. mapper.Add( entity2, \u0026Position{X: 0, Y: 0}, \u0026Velocity{X: 1, Y: -1}, ) // Remove components. mapper.Remove(entity2) // Remove the entities. world.RemoveEntity(entity1) world.RemoveEntity(entity2) In this example, the 2 in NewMap2 denotes the number of mapped components. Unfortunately, this is required due to the limitations of Go’s generics.\nIn addition to Map1, Map2, etc., there is Map. It is a dedicated mapper for a single component and provides a few additional methods."},"title":"Component operations"},"/ark/overview/":{"data":{"":"","advanced#Advanced":" Entity relationships Batch operations Event system Unsafe ALI World statistics ","background#Background":" Error handling Performance tips Design philosophy Architecture Tools Benchmarks Cheat sheet ","basics#Basics":" Quickstart Concepts Filters \u0026 queries Component operations Resources "},"title":"Overview"},"/ark/performance/":{"data":{"":"","component-operations#Component operations":"As explained above, operations like adding and removing components or creating entities are relatively costly in an archetype-based ECS. However, Ark provides some optimizations here, and following a few principles can help keeping the performance cost at a minimum.\nAvoiding Different components are a great way to represent different states of otherwise similar entities. For example, it is completely valid to build a finite state machine to model behavior, using components to represent states. However, each state transition results in moving an entity and its components between archetypes. Thus, when transitions occur frequently (faster than approx. every 20 ticks), different components are not the most efficient way to represent states. Alternatively, states could be represented by a variable in a single component, avoiding the overhead of moving entities between archetypes, at the cost of overhead in the queries.\nIt is a matter of weighting, and potentially benchmarking, to decide on what is represented by components in a query-able way, and what is left to be managed inside query loops.\nMultiple at once, Exchange As explained above, moving entities between archetypes is relatively costly. It is necessary when adding or removing components, but multiple components can be added or removed with a single transition between archetypes.\nFor that sake, there are multiple component mappers like Map1, Map2, Map3 etc. Add or remove components together instead of one after another!\nFurther, Exchange1, Exchange2 etc. allow to add some components and remove others at the same time. This also requires only a single transition between archetypes.\nBatching Ark provides batched variants of all operations like creating entities, adding and removing components, etc. Batching can speed up operations by up to an order of magnitude. It allows for bulk allocation of component memory and entities, and cuts off the overhead that is otherwise required for each entity, repeatedly. Entity creation is the most common use case for batching. For details, see the chapter on Batch operations.\nSee also the Benchmarks for batched vs. un-batched operations.","filter-caching#Filter caching":"When working with many archetypes, queries can be sped up by caching the underlying filter. This way, the filter is not checked against archetypes during query iteration. Instead, the archetypes relevant for the filter are cached, and checks are only required when new archetypes are created.\nFor details, see the section on caching in chapter Filters \u0026 queries.","optimized-for-iteration#Optimized for Iteration":"","queries--components#Queries \u0026amp; Components":"Ark is highly optimized and can compete with other mature ECS implementations in terms of performance. It will probably not get into your way in this regard. Experience shows that in simulation built with Ark, ECS code like queries, entity creation etc. takes between 5% and 15% of the total CPU time. Keep in mind that this is not “on top” of the simulation, but replaces the overhead any other implementation for storing and iterating entities would have. Due to its cache-friendliness, archetype-based ECS can outperform e.g. an Array of Structs implementation, particularly for simulations with many entities and/or many variables per entity.\nNevertheless, each ECS has its strengths and weaknesses. This chapter provides tips on what you should pay attention to in order to get the most out of Ark.\nOptimized for Iteration Being an archetype-based ECS, Ark is optimized for queries and iteration. Adding and removing components is comparatively costly with this architecture, because components must be moved around between archetypes. The runtime difference between accessing a component and adding/removing a component is at least one order of magnitude. For some numbers for comparison, see the Benchmarks.\nQueries \u0026 Components The largest potential for optimizing queries is the clever design of components. The aim should be that queries access only data that is actually required, while at the same time reducing the amount of accessed components. Accessing fewer data means fewer cache misses, while accessing fewer components reduces array indexing. To access only data that it actually required primarily means that the accessed components should ideally contain only data that is used by the query.\nA component should only contain closely related data that is mostly or always accessed together. A Position component with X and Y is a good example. Vice versa, closely related data should be in the same component. What should be avoided are all-in-one components that mimic OOP classes to represent entities. A good (or rather, bad) example is a Tree component with X, Y, Biomass, Height, StemDiameter and LeaveAreaIndex (or more).\nFor fast memory access, the use of slices in components should be avoided. Use fixed-size arrays where possible.","store-filters-and-mappers#Store filters and mappers":"You may have noticed that there is a two-stage approach for creating queries and for creating and modifying entities: you need to create a ecs.FilterX or a ecs.MapX first, respectively. This may seem a bit tedious at first, but is motivated by performance considerations. The reason is that the lookup of IDs for component operations is a relatively costly operations with ≈20ns per component.\nThese ecs.FilterX and ecs.MapX instances should be stored persistently and re-used if possible. This avoids the repeated overhead of component ID lookup.","world-access#World access":"World access to components with Map2.Get et al. is per se slower than access through a query, as there is one more indirection and the alive status of the entity is checked for safety. Queries should be preferred over world access where possible.\nFurther, world access can’t benefit from the cache-friendly linearity of query iterations. This becomes more severe when the length of “jumps” between entities increases. Thus, is it more efficient to randomly access among e.g. 1000 entities compared to 100k entities.\nAs an example, say we have 1000 parent entities, 100k child entities, and don’t use Entity relationships. Here, it would be better to use a query over the children and access the parent of each child by world access. We jump around between 1000 entities. Alternatively, we could query the parents and access the children of each parent by world access. The number of accesses through the world would be the same, but we would jump around between 100k entities, which would be slower."},"title":"Performance tips"},"/ark/queries/":{"data":{"":"Queries are the core feature for writing logic in an ECS. A query iterates over all entities that possess all the component types specified by the query.\nQueries are constructed from filters. While queries are one-time use iterators that are cheap to create, filters are more costly to create and should be stored permanently, e.g. in your systems.","advanced-filters#Advanced filters":"Filters can be further specified using method chaining.\nWith Filter2.With (and related methods) allow to specify components that the queried entities should possess, but that are not used inside the query iteration:\n// Create a filter. filter := ecs.NewFilter1[Position](\u0026world). With(ecs.C[Velocity](), ecs.C[Altitude]()) // Obtain a query. _ = filter.Query() // ... With can also be called multiple times instead of specifying multiple components in one call:\n// Create a filter. filter := ecs.NewFilter1[Position](\u0026world). With(ecs.C[Velocity]()). With(ecs.C[Altitude]()) // Obtain a query. _ = filter.Query() // ... Without Filter2.Without (and related methods) allow to specify components that the queried entities should not possess:\n// Create a filter. filter := ecs.NewFilter1[Position](\u0026world). Without(ecs.C[Velocity](), ecs.C[Altitude]()) // Obtain a query. _ = filter.Query() // ... As with With, Without can be called multiple times:\n// Create a filter. filter := ecs.NewFilter1[Position](\u0026world). Without(ecs.C[Velocity]()). Without(ecs.C[Altitude]()) // Obtain a query. _ = filter.Query() // ... Exclusive Filter2.Exclusive (and related methods) make the filter exclusive on the given components, i.e. it excludes all other components:\n// Create a filter. filter := ecs.NewFilter1[Position](\u0026world). Exclusive() // Obtain a query. _ = filter.Query() // ... Optional There is no Optional provided, as it would require an additional check in Query2.Get et al. Instead, use Map.Has, Map.Get or similar methods in Map2 et al.:\n// Create a filter. filter := ecs.NewFilter2[Position, Velocity](\u0026world) // Create a component mapper. altMap := ecs.NewMap[Altitude](\u0026world) // Obtain a query. query := filter.Query() for query.Next() { // Get the current entity. entity := query.Entity() // Check whether the current entity has an Altitude component. if altMap.Has(entity) { alt := altMap.Get(entity) alt.Z += 1.0 } // Do other stuff... } ","filter-caching#Filter caching":"Although queries are highly performant, a huge number of archetypes (like hundreds or thousands) may cause a slowdown. To prevent this slowdown, filters can be registered to the world’s filter cache via Filter2.Register:\n// Create a filter. filter := ecs.NewFilter2[Position, Velocity](\u0026world). Register() // Register it to the cache. // Obtain a query. _ = filter.Query() // ... For registered filters, a list of matching archetypes is cached internally. Thus, no filter evaluations are required during iteration. Instead, filters are only evaluated when a new archetype is created.\nWhen a registered filter is not required anymore, it can be unregistered with Filter2.Unregister. However, this is rarely required as (registered) filters are usually used over an entire game session or simulation run.","filters-and-queries#Filters and queries":"With basic filters, queries iterate all entities that have the given components, and any additional components that are not of interest.\nIn the example below, the filter would match any entities that have Position and Velocity, and potentially further components like Altitude.\n// Create a filter. filter := ecs.NewFilter2[Position, Velocity](\u0026world) // Obtain a query. query := filter.Query() // Iterate the query. for query.Next() { pos, vel := query.Get() pos.X += vel.X pos.Y += vel.Y } Query2.Get returns all queried components of the current entity. The current entity can be obtained with Query2.Entity.","parallel-queries#Parallel queries":"Ark in general is not thread-safe (see chapter Design, section Limitations). However, it is possible to execute queries in parallel. This is especially useful for two scenarios:\nParallel execution of logic/systems that handle distinct sets of entities. Parallel execution inside a system, partitioning entities using entity relations. For the second use case, a stand-alone example is available that demonstrates the approach.\nIt is the user’s responsibility to avoid access to the same entities from parallel queries, which could cause data races and performance degradation due to false sharing. For the two use cases given above, this is guaranteed because the parallel queries affect different archetypes or relation sub-tables, respectively.","query-performance#Query performance":"Queries iteration is what an archetype-based ECS is optimized for, and it is really fast. This has two reasons.\nFirstly, all entities with the same component composition are stored in the same archetype, or “table”. This means that filters only need to be checked against archetypes, and the entities of a matching archetype can be iterated without any further checks. Further, Ark maintains a mapping from each component to the set of archetypes that include it. This is used to reduce the number of filter checks by pre-selecting archetypes by the most “rare” component of a query.\nSecondly, all components of the same type (like Position) are stored in a dedicated column of the archetype. A query only accesses the required components (i.e. columns), although entities may possess many more components. Memory access is therefore completely linear and contiguous, and the CPUs cache is used as efficiently as possible.","world-lock#World lock":"The world gets locked for component operations when a query is created. The lock is automatically released when query iteration has finished. When breaking out of the iteration, the query must be closed manually with Query2.Close.\nThe lock prevents entity creation and removal, as well as adding and removing components. Thus, it may be necessary to collect entities during the iteration, and perform the operation afterwards:\n// Create a filter. filter := ecs.NewFilter1[Altitude](\u0026world) // Create a slice to collect entities. // Ideally, store this permanently for re-use. toRemove := []ecs.Entity{} query := filter.Query() for query.Next() { alt := query.Get() alt.Z-- if alt.Z \u003c 0 { // Collect entities to remove. toRemove = append(toRemove, query.Entity()) } } // Do the removal. for _, e := range toRemove { world.RemoveEntity(e) } // Reset the slice for re-use. toRemove = toRemove[:0] "},"title":"Filters \u0026 queries"},"/ark/quickstart/":{"data":{"":"","installation#Installation":"","usage-example#Usage example":"","whats-next#What\u0026rsquo;s next?":"This page shows how to install Ark, and gives a minimal usage example.\nFinally, it points into possible directions to continue.\nInstallation To use Ark in a Go project, run:\ngo get github.com/mlange-42/ark Usage example Here is the classical Position/Velocity example that every ECS shows in the docs.\npackage main import ( \"math/rand/v2\" \"github.com/mlange-42/ark/ecs\" ) // Position component type Position struct { X, Y float64 } // Velocity component type Velocity struct { DX, DY float64 } func main() { // Create a new World world := ecs.NewWorld() // Create a component mapper // Save mappers permanently and re-use them for best performance mapper := ecs.NewMap2[Position, Velocity](\u0026world) // Create entities with components for range 1000 { _ = mapper.NewEntity( \u0026Position{X: rand.Float64() * 100, Y: rand.Float64() * 100}, \u0026Velocity{DX: rand.NormFloat64(), DY: rand.NormFloat64()}, ) } // Create a filter // Save filters permanently and re-use them for best performance filter := ecs.NewFilter2[Position, Velocity](\u0026world) // Time loop for range 5000 { // Get a fresh query and iterate it query := filter.Query() for query.Next() { // Component access through the Query pos, vel := query.Get() // Update component fields pos.X += vel.DX pos.Y += vel.DY } } } What’s next? If you ask “What is ECS?”, take a look at the great ECS FAQ by Sander Mertens, the author of the Flecs ECS.\nTo learn how to use Ark, read the following chapters, browse the API documentation, or take a look at the examples in the GitHub repository."},"title":"Quickstart"},"/ark/relations/":{"data":{"":"In a basic ECS, relations between entities, like hierarchies, can be represented by storing entities in components. E.g., we could have a child component like this:\ntype ChildOf struct { Parent ecs.Entity } Or, alternatively, a parent component with many children:\ntype Parent struct { Children []ecs.Entity } In conjunction with component mappers, this is often sufficient. However, we are not able to leverage the power of queries to e.g. get all children of a particular parent in an efficient way.\nTo make entity relations even more useful and efficient, Ark supports them as a first class feature. Relations are added to and removed from entities just like components, and hence can be queried like components, with the usual efficiency. This is achieved by creating separate sub-tables inside archetypes for relations with different target entities.","batch-operations#Batch operations":"All batch operation methods of MapX (e.g. Map2.NewBatch) can be used with relation targets just like the normal component operations shown above.","creating-relations#Creating relations":"Most methods of MapX (e.g. Map2) provide var-args for specifying relationship targets. These are of type Relation, which specifies a component type and a target entity. There are multiple constructors for Relation:\nRel uses a generic type parameter to identify the component. It is safe, but has some run-time overhead for component ID lookup on first usage. RelIdx uses an index to identify the component. It is fast but more error-prone. RelID uses a component ID. It is for use with the unsafe API. See the examples below for their usage.\nOn new entities When creating entities, we can use a MapX (e.g. Map2.NewEntity):\n// Create a component Mapper mapper := ecs.NewMap2[Position, ChildOf](\u0026world) // Create a parent entity. parent := world.NewEntity() // Create an entity with a parent entity, the slow way. _ = mapper.NewEntity(\u0026Position{}, \u0026ChildOf{}, ecs.Rel[ChildOf](parent)) // Create an entity with a parent entity, the fast way. _ = mapper.NewEntity(\u0026Position{}, \u0026ChildOf{}, ecs.RelIdx(1, parent)) For the faster variant RelIdx, note that the first argument is the zero-based index of the relation component in the Map2’s generic parameters.\nIf there are multiple relation components, multiple Rel/RelIdx arguments can (and must) be used.\nWhen adding components Relation target must also be given when adding relation components to an entity:\n// Create a component Mapper mapper := ecs.NewMap2[Position, ChildOf](\u0026world) // Create a parent entity. parent := world.NewEntity() // Create a child entity. child := world.NewEntity() // Add components and a relation target to the child, the slow way. mapper.Add(child, \u0026Position{}, \u0026ChildOf{}, ecs.Rel[ChildOf](parent)) // Add components and a relation target to an entity, the fast way. child2 := world.NewEntity() mapper.Add(child2, \u0026Position{}, \u0026ChildOf{}, ecs.RelIdx(1, parent)) ","dead-target-entities#Dead target entities":"Entities that are the target of any relationships can be removed from the world like any other entity. When this happens, all entities that have this target in a relation get assigned to the zero entity as target. The respective archetype sub-table is de-activated and marked for potential re-use for another target entity.","filters-and-queries#Filters and queries":"Filters support entity relationships using the same syntax as shown in the examples above.\nThere are two ways to specify target entities to filter for: when building the filter, and when getting the query. Both ways can be combined.\nRelation targets given via Filter2.Relations when building a filter are best used for permanent or long-lived targets.\n// Create a filter with a relation target. filter := ecs.NewFilter2[Position, ChildOf](\u0026world). Relations(ecs.Rel[ChildOf](parent)) // Get a query for iteration. query := filter.Query() With cached filters, the targets specified this way are included in the cache. For short-lived targets, it is better to pass them when building a query with Filter2.Query\n// Create a filter. filter := ecs.NewFilter2[Position, ChildOf](\u0026world) // Get a query with a relation target. query := filter.Query(ecs.RelIdx(1, parent)) These targets are not cached, but the same filter can be used for different targets.\nFilters also support both Rel and RelIdx. In the filter examples above, we used the slow but safe Rel when building the filter. When getting the query, we use the faster RelIdx, because in real-world use cases this is called more frequently than the one-time filter construction.\nRelation targets not specified by the filter are treated as wildcard. This means that the filter matches entities with any target.","limitation#Limitation":"Unlike Flecs, the ECS that pioneered entity relationships, Ark is limited to supporting only “exclusive” relationships. This means that any relationship (i.e. relationship type/component) can only have a single target entity. An entity can, however, have multiple different relationship types at the same time.\nThe limitation to a single target is mainly a performance consideration. Firstly, the possibility for multiple targets would require a different, slower approach for component mapping in archetypes. Secondly, usage of multiple targets would easily lead to archetype fragmentation, as a separate archetype sub-table would be created for each unique combination of targets.\nEntity relationships in Ark are still a very powerful feature, while discouraging use cases where they could easily lead to poor performance. For more details on when entity relationships are the most effective and efficient, see the next section.","longer-example#Longer example":"To conclude this chapter, here is a longer example that uses Ark’s entity relationships feature to represent animals of different species in multiple farms.\npackage relations import ( \"fmt\" \"math/rand/v2\" \"github.com/mlange-42/ark/ecs\" ) // ####################### Components ########################### // Farm component. type Farm struct{ ID int } // Weight component for animals. type Weight struct{ Kilograms float64 } // IsInFarm component for animals. type IsInFarm struct{ ecs.RelationMarker } // IsOfSpecies component for animals. type IsOfSpecies struct{ ecs.RelationMarker } func main() { // ####################### Preparations ########################### world := ecs.NewWorld() // Create a component mapper for farms. farmMap := ecs.NewMap1[Farm](\u0026world) // Create a component mapper for farm animals. animalMap := ecs.NewMap3[Weight, IsInFarm, IsOfSpecies](\u0026world) // Create a filter for farms. farmFilter := ecs.NewFilter1[Farm](\u0026world) // Create a filter for farm animals. animalFilter := ecs.NewFilter3[Weight, IsInFarm, IsOfSpecies](\u0026world) // ####################### Initialization ########################### // Create species. cow := world.NewEntity() pig := world.NewEntity() // Create farms. farms := []ecs.Entity{} for i := range 10 { farm := farmMap.NewEntity(\u0026Farm{i}) farms = append(farms, farm) } // Populate farms. for _, farm := range farms { // How many animals? numCows := rand.IntN(50) numPigs := rand.IntN(200) // Create cows. animalMap.NewBatch(numCows, // How many? \u0026Weight{500}, \u0026IsInFarm{}, \u0026IsOfSpecies{}, // Initial values. ecs.Rel[IsInFarm](farm), // This farm. ecs.Rel[IsOfSpecies](cow), // Species cow. ) // Create pigs. animalMap.NewBatch(numPigs, // How many? \u0026Weight{100}, \u0026IsInFarm{}, \u0026IsOfSpecies{}, // Initial values. ecs.Rel[IsInFarm](farm), // This farm. ecs.Rel[IsOfSpecies](pig), // Species pig. ) } // ####################### Logic in systems ########################### // Do something with all pigs. query := animalFilter.Query(ecs.Rel[IsOfSpecies](pig)) for query.Next() { weight, _, _ := query.Get() weight.Kilograms += rand.Float64() * 10 } // Print total weight of the pigs in each farm. // Iterate farms. farmQuery := farmFilter.Query() for farmQuery.Next() { farm := farmQuery.Get() farmEntity := farmQuery.Entity() totalWeight := 0.0 // Iterate pigs in the farm. animalQuery := animalFilter.Query( ecs.Rel[IsInFarm](farmEntity), // This farm. ecs.Rel[IsOfSpecies](pig), // Pigs only. ) for animalQuery.Next() { weight, _, _ := animalQuery.Get() totalWeight += weight.Kilograms } // Print the farm's result. fmt.Printf(\"Farm %d: %.0fkg\\n\", farm.ID, totalWeight) } } Note that this examples uses the safe and clear, but slower generic variant to specify relationship targets. As an optimization, RelIdx could be used instead of Rel, particularly for queries.","relation-components#Relation components":"To use entity relations, create components that have embedded a RelationMarker as their first member:\ntype ChildOf struct { ecs.RelationMarker } That’s all to make a component be treated as an entity relationship by Ark. The component can contain further variables, but the marker must be the first one.","set-and-get-relations#Set and get relations":"We can also change the target entity of an already assigned relation component. This is done via Map2.SetRelations et al.:\n// Create a component Mapper mapper := ecs.NewMap2[Position, ChildOf](\u0026world) // Create parent entities. parent1 := world.NewEntity() parent2 := world.NewEntity() // Create an entity with a parent entity. child := mapper.NewEntity(\u0026Position{}, \u0026ChildOf{}, ecs.RelIdx(1, parent1)) // Change the child's parent. mapper.SetRelations(child, ecs.RelIdx(1, parent2)) // Change the child's parent, the slow way. mapper.SetRelations(child, ecs.Rel[ChildOf](parent2)) Note that multiple relation targets can be changed in the same call.\nSimilarly, relation targets can be obtained with Map2.GetRelation et al.:\n// Create a component Mapper mapper := ecs.NewMap2[Position, ChildOf](\u0026world) // Create a parent entity. parent := world.NewEntity() // Create an entity with a parent entity. child := mapper.NewEntity(\u0026Position{}, \u0026ChildOf{}, ecs.RelIdx(1, parent)) // Get a relation target by component index. parent = mapper.GetRelation(child, 1) Note that, due to Go’s limitations on generics, the slow generic way is not possible here.\nFor a simpler syntax and when only a single relation component is accessed, Map can be used alternatively:\n// Create a component Mapper childMap := ecs.NewMap[ChildOf](\u0026world) // Create parent entities. parent1 := world.NewEntity() parent2 := world.NewEntity() // Create a child entity. child := world.NewEntity() // Add a component with a target parent entity. childMap.Add(child, \u0026ChildOf{}, parent1) // Change the entity's parent. childMap.SetRelation(child, parent2) // Get the relation target. parent := childMap.GetRelation(child) ","when-to-use-and-when-not#When to use, and when not":"When using Ark’s entity relations, an archetype sub-table is created for each target entity of a relation. Thus, entity relations are not efficient if the number of target entities is high (tens of thousands), while only a low number of entities has a relation to each particular target (less than a few dozens). Particularly in the extreme case of 1:1 relations, storing entities in components as explained in the introduction of this chapter is more efficient.\nHowever, with a moderate number of relation targets, particularly with many entities per target, entity relations are very efficient.\nBeyond use cases where the relation target is a “physical” entity that appears in a simulation or game, targets can also be more abstract, like categories. Examples:\nDifferent tree species in a forest model. Behavioral states in a finite state machine. The opposing factions in a strategy game. Render layers in a game or other graphical application. This concept is particularly useful for things that would best be expressed by components, but the possible components (or categories) are only known at runtime. Thus, it is not possible to create ordinary components for them. However, these categories can be represented by entities, which are used as relation targets."},"title":"Entity relationships"},"/ark/resources/":{"data":{"":"Resources are singular data structures in an ECS world. As such, they can be thought of as components that exist only once and are not associated to an entity. Examples could be the current game/simulation tick, a grid that your entities live on, or an acceleration structure for spatial indexing.\nA world can contain up to 256 resources (64 with build tag ark_tiny).","adding-resources#Adding resources":"Resources are Go structs that can contain any types of variables, just like components. Simply instantiate your resource and add a pointer to it to the world using AddResource, typically during world initialization:\n// Create a resource. var worldGrid Grid = NewGrid(100, 100) // Add it to the world. ecs.AddResource(\u0026world, \u0026worldGrid) The original resource struct can be stored and modified, and changes are reflected in code that retrieves the resource from the world (see the following sections).","direct-access#Direct access":"Resources can be retrieved from the world by their type, with GetResource:\n// Get a resource from the world. grid := ecs.GetResource[Grid](\u0026world) However, this method has an overhead of approx. 20ns for the type lookup. It is sufficient for one-time use of a resource. When accessing a resource regularly, Resource mappers should be used.","resource-mappers#Resource mappers":"Resource mappers are a more efficient way for retrieving a resource repeatedly. To use them, create an Resource, store it, and use it for retrieval:\n// In your system, create a resource mapper. // Store it permanently and reuse it for best performance. gridRes := ecs.NewResource[Grid](\u0026world) // Access the resource. grid := gridRes.Get() This way, resource access takes less than 1ns.\nResource mappers can also be used to add and remove resources, and to check for their existence:\n// In your system, create a resource mapper. // Store it permanently and reuse it for best performance. gridRes := ecs.NewResource[Grid](\u0026world) // Check for existence of the resource. if gridRes.Has() { // Remove the resource if it exists. gridRes.Remove() } else { // Add a new one otherwise. grid := NewGrid(100, 100) gridRes.Add(\u0026grid) } "},"title":"Resources"},"/ark/stats/":{"data":{"":"Ark only exposes the API required for actual use. Therefore, internals like the number of archetypes, memory used to store components etc. are not directly accessible.\nHowever, it might sometimes be useful to have access to such metrics, for example in order to judge effects of different ways of implementing something. Otherwise, users would have to rely on logic reasoning and sufficient understanding of Ark to derive these numbers.\nFor that sake, Ark provides statistics about its internals, prepared in a compact and digestible form.","accessing-statistics#Accessing statistics":"All internal statistics can be accessed via World.Stats, which returns a *stats.World. This, in turn, contains the other stats types described below. All these types have a method String() to bring them into a compact, human-readable form.\nworld := ecs.NewWorld() builder := ecs.NewMap2[Position, Heading](\u0026world) builder.NewBatchFn(100, nil) stats := world.Stats() fmt.Println(stats) Which prints:\nWorld -- Components: 2, Archetypes: 2, Filters: 0, Observers: 0, Memory: 4.7/56.0 kB, Locked: false Components: Position, Heading Entities -- Used: 100, Recycled: 0, Total: 100, Capacity: 1026 Archetype -- Tables: 1, Comps: 0, Entities: 0, Cap: 1024, Mem: 8.0 kB, Per entity: 8 B Components: Archetype -- Tables: 1, Comps: 2, Entities: 100, Cap: 1024, Mem: 32.0 kB, Per entity: 32 B Components: Position, Heading ","archetype-stats#Archetype stats":"stats.Archetype provides information about an archetype, like its components, memory in total and per entity, and more state information.\nFurther, it contains a stats.Table for each table.","entity-stats#Entity stats":"stats.Entities contains information about the entity pool, like capacity, alive entities and available entities for recycling.","table-stats#Table stats":"stats.Table contains size, capacity and memory information for a table. Tables are used to represent sub-archetypes with the same components, but a different combination of relationship targets.","world-stats#World stats":"stats.World provides world information like a list of all component types and the total memory reserved for entities and components. Further, it contains stats.Entities and a stats.Archetype for each archetype."},"title":"World statistics"},"/ark/tools/":{"data":{"":"A number of tools has been created for Ark.\nIf you wrote a tool and want it to be included here, please open an issue on GitHub.\nark-serde provides JSON serialization and deserialization for Ark’s World. ark-tools provides systems, a scheduler, and other useful stuff for Ark. ark-pixel provides OpenGL graphics and live plots via the Pixel game engine. "},"title":"Tools"},"/ark/unsafe/":{"data":{"":"So far, we used the type-safe, generic API of Ark throughout. However, there may be use cases where component types are not known at compile-time, like serialization and de-serializations. For these cases, Ark offers an unsafe, ID-based API. It is accessible via World.Unsafe.","component-access#Component access":"Components of entities can be accessed outside queries using Unsafe.Get/Unsafe.Has:\nentity := world.Unsafe().NewEntity(posID, velID) pos := (*Position)(world.Unsafe().Get(entity, posID)) Important\nAgain, note the type cast! See above for details.","component-ids#Component IDs":"Internally, each component type is mapped to an ID. We don’t see it in the generic API, but we can use it for more flexibility in the ID-based API. IDs can be obtained by the function ComponentID. If a component is not yet registered, it gets registered upon first use.\nworld := ecs.NewWorld() posID := ecs.ComponentID[Position](\u0026world) velID := ecs.ComponentID[Velocity](\u0026world) ","component-operations#Component operations":"Components can be added and removed using methods of Unsafe:\nentity := world.NewEntity() world.Unsafe().Add(entity, posID, velID) world.Unsafe().Remove(entity, posID, velID) ","creating-entities#Creating entities":"Entities are created with Unsafe.NewEntity, giving the desired component IDs:\nentity := world.Unsafe().NewEntity(posID, velID) ","filters-and-queries#Filters and queries":"Filters and queries work similar to the generic API, but also component IDs instead of generics:\nfilter := ecs.NewUnsafeFilter(\u0026world, posID, velID) query := filter.Query() for query.Next() { pos := (*Position)(query.Get(posID)) vel := (*Velocity)(query.Get(velID)) pos.X += vel.X pos.Y += vel.Y } Important\nNote the type casts! These are required because UnsafeQuery.Get returns an unsafe.Pointer to the underlying component storage. Extra care should be taken here, because this is a common source of bugs and the cast is not checked for the correct type.","limitations#Limitations":"Besides not being type-safe (i.e. you can cast to anything without an immediate error), the unsafe API has a few limitations:\nIt is slower than the type-safe API. Newly added components can’t be initialized directly.\nUnsafe.Get must be used for initialization. There are currently no batch operations provided for the unsafe API. "},"title":"Unsafe API"}}