package ecs

// Code generated by go generate; DO NOT EDIT.

// Filter0 is a filter for 0 components.
// Used to create [Query0] iterators.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Filter2] for a usage example.
type Filter0 struct {
	world        *World
	ids          []ID
	relations    []relationID
	components   []*componentStorage
	filter       filter
	generation   uint32
	rareComp     uint8
	numRelations uint8
}

// New creates a new [Filter0]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
//
// See [Filter2.New] for an example.
func (*Filter0) New(world *World) *Filter0 {
	return NewFilter0(world)
}

// NewFilter0 creates a new [Filter0].
//
// Use [Filter0.Query] to obtain a [Query0].
//
// See also [Filter0.New] for a shortcut when constructing an already defined instance.
func NewFilter0(world *World) *Filter0 {
	ids := []ID{}
	components := make([]*componentStorage, 0)
	return &Filter0{
		world:      world,
		ids:        ids,
		filter:     newFilter(ids...),
		components: components,
	}
}

// With specifies additional components to filter for.
// Can be called multiple times in chains, or once with multiple arguments.
func (f *Filter0) With(comps ...Comp) *Filter0 {
	f.checkModify()
	for _, c := range comps {
		id := f.world.componentID(c.tp)
		f.ids = append(f.ids, id)
		f.filter.mask.Set(id.id)
	}
	return f
}

// Without specifies components to exclude.
// Can be called multiple times in chains, or once with multiple arguments.
func (f *Filter0) Without(comps ...Comp) *Filter0 {
	f.checkModify()
	if len(comps) == 0 {
		return f
	}
	for _, c := range comps {
		id := f.world.componentID(c.tp)
		f.filter.without.Set(id.id)
		f.filter.hasWithout = true
	}
	return f
}

// Exclusive makes the filter exclusive in the sense that the component composition is matched exactly,
// and no other components are allowed. This includes components set via [Filter0.With].
//
// Overwrites components set via [Filter0.Without].
func (f *Filter0) Exclusive() *Filter0 {
	f.checkModify()
	f.filter = f.filter.Exclusive()
	return f
}

// Relations sets permanent entity relation targets for this filter.
// Relation targets set here are included in filter caching.
// Contrary, relation targets specified in [Filter0.Query] or [Filter0.Batch] are not cached.
//
// Relation components used here must be in the filter's parameters
// or added via [Filter0.With] beforehand.
//
// Can be called multiple times in chains, or once with multiple arguments.
func (f *Filter0) Relations(rel ...Relation) *Filter0 {
	f.checkModify()
	f.relations = relationSlice(rel).ToRelations(f.world, &f.filter.mask, f.ids, f.relations[:f.numRelations], nil)
	f.numRelations = uint8(len(f.relations))
	return f
}

// Register this filter to the world's filter cache.
//
// Registering filters is optional.
// It avoids a potential slowdown that may be caused by a very high number of archetypes, like hundreds or thousands.
func (f *Filter0) Register() *Filter0 {
	if f.filter.cache != maxCacheID {
		panic("filter is already registered, can't register")
	}
	f.world.storage.registerFilter(&f.filter, f.relations[:f.numRelations])
	return f
}

// Unregister this filter from the world's filter cache.
func (f *Filter0) Unregister() {
	if f.filter.cache == maxCacheID {
		panic("filter is not registered, can't unregister")
	}
	f.world.storage.unregisterFilter(&f.filter)
}

// Query creates a [Query0] from this filter.
// This must be used each time before iterating a query.
//
// Relation targets provided here are added to those specified with [Filter0.Relations].
// Relation components must be in the filter's parameters or added via [Filter0.With] beforehand.
func (f *Filter0) Query(rel ...Relation) Query0 {
	pooled := len(rel) > 0
	var relations []relationID

	f.world.storage.mu.Lock()
	lock := f.world.storage.lock()
	if pooled {
		relations = f.world.storage.slices.relationsPool.Get()
	}
	if f.filter.cache == maxCacheID && f.generation != f.world.storage.registry.getGeneration() {
		f.rareComp = f.world.storage.registry.rareComponent(f.ids).id
		f.generation = f.world.storage.registry.getGeneration()
	}
	f.world.storage.mu.Unlock()

	relations = relationSlice(rel).ToRelations(f.world, &f.filter.mask, f.ids, f.relations[:f.numRelations], relations)

	var start uint8
	var cache *cacheEntry
	if f.filter.cache != maxCacheID {
		start = f.numRelations
		cache = f.world.storage.getRegisteredFilter(f.filter.cache)
	}

	return Query0{
		world:      f.world,
		filter:     &f.filter,
		relations:  relations[start:],
		cache:      cache,
		lock:       lock,
		components: f.components,
		cursor: cursor{
			archetype: -1,
			table:     -1,
			index:     0,
			maxIndex:  -1,
		},
		rareComp:    f.rareComp,
		hasRareComp: len(f.ids) > 0,
		isPooled:    pooled,
	}
}

// Batch creates a [Batch] from this filter.
//
// Relation targets provided here are added to those specified with [Filter0.Relations].
// Relation components must be in the filter's parameters or added via [Filter0.With] beforehand.
//
// ⚠️ The returned [Batch] filter should not be stored, but used immediately and re-generated
// each time a batch operation is called.
// Otherwise, changes to the origin filter or calls to [Filter0.Batch] or [Filter0.Query]
// with different relationship targets may modify stored instances.
func (f *Filter0) Batch(rel ...Relation) Batch {
	f.relations = relationSlice(rel).ToRelations(f.world, &f.filter.mask, f.ids, f.relations[:f.numRelations], nil)
	var start uint8
	if f.filter.cache != maxCacheID {
		start = f.numRelations
	}
	return Batch{
		filter:    &f.filter,
		relations: f.relations[start:],
	}
}

func (f *Filter0) checkModify() {
	if f.filter.cache != maxCacheID {
		panic("can't modify a cached filter")
	}
	if f.generation != 0 {
		panic("can't modify a filter that was already queried")
	}
}

// Filter1 is a filter for 1 components.
// Used to create [Query1] iterators.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Filter2] for a usage example.
type Filter1[A any] struct {
	world        *World
	ids          []ID
	relations    []relationID
	components   []*componentStorage
	filter       filter
	generation   uint32
	rareComp     uint8
	numRelations uint8
}

// New creates a new [Filter1]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
//
// See [Filter2.New] for an example.
func (*Filter1[A]) New(world *World) *Filter1[A] {
	return NewFilter1[A](world)
}

// NewFilter1 creates a new [Filter1].
//
// Use [Filter1.Query] to obtain a [Query1].
//
// See also [Filter1.New] for a shortcut when constructing an already defined instance.
func NewFilter1[A any](world *World) *Filter1[A] {
	ids := []ID{
		ComponentID[A](world),
	}
	components := make([]*componentStorage, 1)
	components[0] = &world.storage.components[ids[0].id]
	return &Filter1[A]{
		world:      world,
		ids:        ids,
		filter:     newFilter(ids...),
		components: components,
	}
}

// With specifies additional components to filter for.
// Can be called multiple times in chains, or once with multiple arguments.
func (f *Filter1[A]) With(comps ...Comp) *Filter1[A] {
	f.checkModify()
	for _, c := range comps {
		id := f.world.componentID(c.tp)
		f.ids = append(f.ids, id)
		f.filter.mask.Set(id.id)
	}
	return f
}

// Without specifies components to exclude.
// Can be called multiple times in chains, or once with multiple arguments.
func (f *Filter1[A]) Without(comps ...Comp) *Filter1[A] {
	f.checkModify()
	if len(comps) == 0 {
		return f
	}
	for _, c := range comps {
		id := f.world.componentID(c.tp)
		f.filter.without.Set(id.id)
		f.filter.hasWithout = true
	}
	return f
}

// Exclusive makes the filter exclusive in the sense that the component composition is matched exactly,
// and no other components are allowed. This includes components set via [Filter1.With].
//
// Overwrites components set via [Filter1.Without].
func (f *Filter1[A]) Exclusive() *Filter1[A] {
	f.checkModify()
	f.filter = f.filter.Exclusive()
	return f
}

// Relations sets permanent entity relation targets for this filter.
// Relation targets set here are included in filter caching.
// Contrary, relation targets specified in [Filter1.Query] or [Filter1.Batch] are not cached.
//
// Relation components used here must be in the filter's parameters
// or added via [Filter1.With] beforehand.
//
// Can be called multiple times in chains, or once with multiple arguments.
func (f *Filter1[A]) Relations(rel ...Relation) *Filter1[A] {
	f.checkModify()
	f.relations = relationSlice(rel).ToRelations(f.world, &f.filter.mask, f.ids, f.relations[:f.numRelations], nil)
	f.numRelations = uint8(len(f.relations))
	return f
}

// Register this filter to the world's filter cache.
//
// Registering filters is optional.
// It avoids a potential slowdown that may be caused by a very high number of archetypes, like hundreds or thousands.
func (f *Filter1[A]) Register() *Filter1[A] {
	if f.filter.cache != maxCacheID {
		panic("filter is already registered, can't register")
	}
	f.world.storage.registerFilter(&f.filter, f.relations[:f.numRelations])
	return f
}

// Unregister this filter from the world's filter cache.
func (f *Filter1[A]) Unregister() {
	if f.filter.cache == maxCacheID {
		panic("filter is not registered, can't unregister")
	}
	f.world.storage.unregisterFilter(&f.filter)
}

// Query creates a [Query1] from this filter.
// This must be used each time before iterating a query.
//
// Relation targets provided here are added to those specified with [Filter1.Relations].
// Relation components must be in the filter's parameters or added via [Filter1.With] beforehand.
func (f *Filter1[A]) Query(rel ...Relation) Query1[A] {
	pooled := len(rel) > 0
	var relations []relationID

	f.world.storage.mu.Lock()
	lock := f.world.storage.lock()
	if pooled {
		relations = f.world.storage.slices.relationsPool.Get()
	}
	if f.filter.cache == maxCacheID && f.generation != f.world.storage.registry.getGeneration() {
		f.rareComp = f.world.storage.registry.rareComponent(f.ids).id
		f.generation = f.world.storage.registry.getGeneration()
	}
	f.world.storage.mu.Unlock()

	relations = relationSlice(rel).ToRelations(f.world, &f.filter.mask, f.ids, f.relations[:f.numRelations], relations)

	var start uint8
	var cache *cacheEntry
	if f.filter.cache != maxCacheID {
		start = f.numRelations
		cache = f.world.storage.getRegisteredFilter(f.filter.cache)
	}

	return Query1[A]{
		world:      f.world,
		filter:     &f.filter,
		relations:  relations[start:],
		cache:      cache,
		lock:       lock,
		components: f.components,
		cursor: cursor{
			archetype: -1,
			table:     -1,
			index:     0,
			maxIndex:  -1,
		},
		rareComp: f.rareComp,

		isPooled: pooled,
	}
}

// Batch creates a [Batch] from this filter.
//
// Relation targets provided here are added to those specified with [Filter1.Relations].
// Relation components must be in the filter's parameters or added via [Filter1.With] beforehand.
//
// ⚠️ The returned [Batch] filter should not be stored, but used immediately and re-generated
// each time a batch operation is called.
// Otherwise, changes to the origin filter or calls to [Filter1.Batch] or [Filter1.Query]
// with different relationship targets may modify stored instances.
func (f *Filter1[A]) Batch(rel ...Relation) Batch {
	f.relations = relationSlice(rel).ToRelations(f.world, &f.filter.mask, f.ids, f.relations[:f.numRelations], nil)
	var start uint8
	if f.filter.cache != maxCacheID {
		start = f.numRelations
	}
	return Batch{
		filter:    &f.filter,
		relations: f.relations[start:],
	}
}

func (f *Filter1[A]) checkModify() {
	if f.filter.cache != maxCacheID {
		panic("can't modify a cached filter")
	}
	if f.generation != 0 {
		panic("can't modify a filter that was already queried")
	}
}

// Filter2 is a filter for 2 components.
// Used to create [Query2] iterators.
//
// Instances should be created during initialization and stored, e.g. in systems.
type Filter2[A any, B any] struct {
	world        *World
	ids          []ID
	relations    []relationID
	components   []*componentStorage
	filter       filter
	generation   uint32
	rareComp     uint8
	numRelations uint8
}

// New creates a new [Filter2]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
func (*Filter2[A, B]) New(world *World) *Filter2[A, B] {
	return NewFilter2[A, B](world)
}

// NewFilter2 creates a new [Filter2].
//
// Use [Filter2.Query] to obtain a [Query2].
//
// See also [Filter2.New] for a shortcut when constructing an already defined instance.
func NewFilter2[A any, B any](world *World) *Filter2[A, B] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
	}
	components := make([]*componentStorage, 2)
	components[0] = &world.storage.components[ids[0].id]
	components[1] = &world.storage.components[ids[1].id]
	return &Filter2[A, B]{
		world:      world,
		ids:        ids,
		filter:     newFilter(ids...),
		components: components,
	}
}

// With specifies additional components to filter for.
// Can be called multiple times in chains, or once with multiple arguments.
func (f *Filter2[A, B]) With(comps ...Comp) *Filter2[A, B] {
	f.checkModify()
	for _, c := range comps {
		id := f.world.componentID(c.tp)
		f.ids = append(f.ids, id)
		f.filter.mask.Set(id.id)
	}
	return f
}

// Without specifies components to exclude.
// Can be called multiple times in chains, or once with multiple arguments.
func (f *Filter2[A, B]) Without(comps ...Comp) *Filter2[A, B] {
	f.checkModify()
	if len(comps) == 0 {
		return f
	}
	for _, c := range comps {
		id := f.world.componentID(c.tp)
		f.filter.without.Set(id.id)
		f.filter.hasWithout = true
	}
	return f
}

// Exclusive makes the filter exclusive in the sense that the component composition is matched exactly,
// and no other components are allowed. This includes components set via [Filter2.With].
//
// Overwrites components set via [Filter2.Without].
func (f *Filter2[A, B]) Exclusive() *Filter2[A, B] {
	f.checkModify()
	f.filter = f.filter.Exclusive()
	return f
}

// Relations sets permanent entity relation targets for this filter.
// Relation targets set here are included in filter caching.
// Contrary, relation targets specified in [Filter2.Query] or [Filter2.Batch] are not cached.
//
// Relation components used here must be in the filter's parameters
// or added via [Filter2.With] beforehand.
//
// Can be called multiple times in chains, or once with multiple arguments.
func (f *Filter2[A, B]) Relations(rel ...Relation) *Filter2[A, B] {
	f.checkModify()
	f.relations = relationSlice(rel).ToRelations(f.world, &f.filter.mask, f.ids, f.relations[:f.numRelations], nil)
	f.numRelations = uint8(len(f.relations))
	return f
}

// Register this filter to the world's filter cache.
//
// Registering filters is optional.
// It avoids a potential slowdown that may be caused by a very high number of archetypes, like hundreds or thousands.
func (f *Filter2[A, B]) Register() *Filter2[A, B] {
	if f.filter.cache != maxCacheID {
		panic("filter is already registered, can't register")
	}
	f.world.storage.registerFilter(&f.filter, f.relations[:f.numRelations])
	return f
}

// Unregister this filter from the world's filter cache.
func (f *Filter2[A, B]) Unregister() {
	if f.filter.cache == maxCacheID {
		panic("filter is not registered, can't unregister")
	}
	f.world.storage.unregisterFilter(&f.filter)
}

// Query creates a [Query2] from this filter.
// This must be used each time before iterating a query.
//
// Relation targets provided here are added to those specified with [Filter2.Relations].
// Relation components must be in the filter's parameters or added via [Filter2.With] beforehand.
func (f *Filter2[A, B]) Query(rel ...Relation) Query2[A, B] {
	pooled := len(rel) > 0
	var relations []relationID

	f.world.storage.mu.Lock()
	lock := f.world.storage.lock()
	if pooled {
		relations = f.world.storage.slices.relationsPool.Get()
	}
	if f.filter.cache == maxCacheID && f.generation != f.world.storage.registry.getGeneration() {
		f.rareComp = f.world.storage.registry.rareComponent(f.ids).id
		f.generation = f.world.storage.registry.getGeneration()
	}
	f.world.storage.mu.Unlock()

	relations = relationSlice(rel).ToRelations(f.world, &f.filter.mask, f.ids, f.relations[:f.numRelations], relations)

	var start uint8
	var cache *cacheEntry
	if f.filter.cache != maxCacheID {
		start = f.numRelations
		cache = f.world.storage.getRegisteredFilter(f.filter.cache)
	}

	return Query2[A, B]{
		world:      f.world,
		filter:     &f.filter,
		relations:  relations[start:],
		cache:      cache,
		lock:       lock,
		components: f.components,
		cursor: cursor{
			archetype: -1,
			table:     -1,
			index:     0,
			maxIndex:  -1,
		},
		rareComp: f.rareComp,

		isPooled: pooled,
	}
}

// Batch creates a [Batch] from this filter.
//
// Relation targets provided here are added to those specified with [Filter2.Relations].
// Relation components must be in the filter's parameters or added via [Filter2.With] beforehand.
//
// ⚠️ The returned [Batch] filter should not be stored, but used immediately and re-generated
// each time a batch operation is called.
// Otherwise, changes to the origin filter or calls to [Filter2.Batch] or [Filter2.Query]
// with different relationship targets may modify stored instances.
func (f *Filter2[A, B]) Batch(rel ...Relation) Batch {
	f.relations = relationSlice(rel).ToRelations(f.world, &f.filter.mask, f.ids, f.relations[:f.numRelations], nil)
	var start uint8
	if f.filter.cache != maxCacheID {
		start = f.numRelations
	}
	return Batch{
		filter:    &f.filter,
		relations: f.relations[start:],
	}
}

func (f *Filter2[A, B]) checkModify() {
	if f.filter.cache != maxCacheID {
		panic("can't modify a cached filter")
	}
	if f.generation != 0 {
		panic("can't modify a filter that was already queried")
	}
}

// Filter3 is a filter for 3 components.
// Used to create [Query3] iterators.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Filter2] for a usage example.
type Filter3[A any, B any, C any] struct {
	world        *World
	ids          []ID
	relations    []relationID
	components   []*componentStorage
	filter       filter
	generation   uint32
	rareComp     uint8
	numRelations uint8
}

// New creates a new [Filter3]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
//
// See [Filter2.New] for an example.
func (*Filter3[A, B, C]) New(world *World) *Filter3[A, B, C] {
	return NewFilter3[A, B, C](world)
}

// NewFilter3 creates a new [Filter3].
//
// Use [Filter3.Query] to obtain a [Query3].
//
// See also [Filter3.New] for a shortcut when constructing an already defined instance.
func NewFilter3[A any, B any, C any](world *World) *Filter3[A, B, C] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
	}
	components := make([]*componentStorage, 3)
	components[0] = &world.storage.components[ids[0].id]
	components[1] = &world.storage.components[ids[1].id]
	components[2] = &world.storage.components[ids[2].id]
	return &Filter3[A, B, C]{
		world:      world,
		ids:        ids,
		filter:     newFilter(ids...),
		components: components,
	}
}

// With specifies additional components to filter for.
// Can be called multiple times in chains, or once with multiple arguments.
func (f *Filter3[A, B, C]) With(comps ...Comp) *Filter3[A, B, C] {
	f.checkModify()
	for _, c := range comps {
		id := f.world.componentID(c.tp)
		f.ids = append(f.ids, id)
		f.filter.mask.Set(id.id)
	}
	return f
}

// Without specifies components to exclude.
// Can be called multiple times in chains, or once with multiple arguments.
func (f *Filter3[A, B, C]) Without(comps ...Comp) *Filter3[A, B, C] {
	f.checkModify()
	if len(comps) == 0 {
		return f
	}
	for _, c := range comps {
		id := f.world.componentID(c.tp)
		f.filter.without.Set(id.id)
		f.filter.hasWithout = true
	}
	return f
}

// Exclusive makes the filter exclusive in the sense that the component composition is matched exactly,
// and no other components are allowed. This includes components set via [Filter3.With].
//
// Overwrites components set via [Filter3.Without].
func (f *Filter3[A, B, C]) Exclusive() *Filter3[A, B, C] {
	f.checkModify()
	f.filter = f.filter.Exclusive()
	return f
}

// Relations sets permanent entity relation targets for this filter.
// Relation targets set here are included in filter caching.
// Contrary, relation targets specified in [Filter3.Query] or [Filter3.Batch] are not cached.
//
// Relation components used here must be in the filter's parameters
// or added via [Filter3.With] beforehand.
//
// Can be called multiple times in chains, or once with multiple arguments.
func (f *Filter3[A, B, C]) Relations(rel ...Relation) *Filter3[A, B, C] {
	f.checkModify()
	f.relations = relationSlice(rel).ToRelations(f.world, &f.filter.mask, f.ids, f.relations[:f.numRelations], nil)
	f.numRelations = uint8(len(f.relations))
	return f
}

// Register this filter to the world's filter cache.
//
// Registering filters is optional.
// It avoids a potential slowdown that may be caused by a very high number of archetypes, like hundreds or thousands.
func (f *Filter3[A, B, C]) Register() *Filter3[A, B, C] {
	if f.filter.cache != maxCacheID {
		panic("filter is already registered, can't register")
	}
	f.world.storage.registerFilter(&f.filter, f.relations[:f.numRelations])
	return f
}

// Unregister this filter from the world's filter cache.
func (f *Filter3[A, B, C]) Unregister() {
	if f.filter.cache == maxCacheID {
		panic("filter is not registered, can't unregister")
	}
	f.world.storage.unregisterFilter(&f.filter)
}

// Query creates a [Query3] from this filter.
// This must be used each time before iterating a query.
//
// Relation targets provided here are added to those specified with [Filter3.Relations].
// Relation components must be in the filter's parameters or added via [Filter3.With] beforehand.
func (f *Filter3[A, B, C]) Query(rel ...Relation) Query3[A, B, C] {
	pooled := len(rel) > 0
	var relations []relationID

	f.world.storage.mu.Lock()
	lock := f.world.storage.lock()
	if pooled {
		relations = f.world.storage.slices.relationsPool.Get()
	}
	if f.filter.cache == maxCacheID && f.generation != f.world.storage.registry.getGeneration() {
		f.rareComp = f.world.storage.registry.rareComponent(f.ids).id
		f.generation = f.world.storage.registry.getGeneration()
	}
	f.world.storage.mu.Unlock()

	relations = relationSlice(rel).ToRelations(f.world, &f.filter.mask, f.ids, f.relations[:f.numRelations], relations)

	var start uint8
	var cache *cacheEntry
	if f.filter.cache != maxCacheID {
		start = f.numRelations
		cache = f.world.storage.getRegisteredFilter(f.filter.cache)
	}

	return Query3[A, B, C]{
		world:      f.world,
		filter:     &f.filter,
		relations:  relations[start:],
		cache:      cache,
		lock:       lock,
		components: f.components,
		cursor: cursor{
			archetype: -1,
			table:     -1,
			index:     0,
			maxIndex:  -1,
		},
		rareComp: f.rareComp,

		isPooled: pooled,
	}
}

// Batch creates a [Batch] from this filter.
//
// Relation targets provided here are added to those specified with [Filter3.Relations].
// Relation components must be in the filter's parameters or added via [Filter3.With] beforehand.
//
// ⚠️ The returned [Batch] filter should not be stored, but used immediately and re-generated
// each time a batch operation is called.
// Otherwise, changes to the origin filter or calls to [Filter3.Batch] or [Filter3.Query]
// with different relationship targets may modify stored instances.
func (f *Filter3[A, B, C]) Batch(rel ...Relation) Batch {
	f.relations = relationSlice(rel).ToRelations(f.world, &f.filter.mask, f.ids, f.relations[:f.numRelations], nil)
	var start uint8
	if f.filter.cache != maxCacheID {
		start = f.numRelations
	}
	return Batch{
		filter:    &f.filter,
		relations: f.relations[start:],
	}
}

func (f *Filter3[A, B, C]) checkModify() {
	if f.filter.cache != maxCacheID {
		panic("can't modify a cached filter")
	}
	if f.generation != 0 {
		panic("can't modify a filter that was already queried")
	}
}

// Filter4 is a filter for 4 components.
// Used to create [Query4] iterators.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Filter2] for a usage example.
type Filter4[A any, B any, C any, D any] struct {
	world        *World
	ids          []ID
	relations    []relationID
	components   []*componentStorage
	filter       filter
	generation   uint32
	rareComp     uint8
	numRelations uint8
}

// New creates a new [Filter4]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
//
// See [Filter2.New] for an example.
func (*Filter4[A, B, C, D]) New(world *World) *Filter4[A, B, C, D] {
	return NewFilter4[A, B, C, D](world)
}

// NewFilter4 creates a new [Filter4].
//
// Use [Filter4.Query] to obtain a [Query4].
//
// See also [Filter4.New] for a shortcut when constructing an already defined instance.
func NewFilter4[A any, B any, C any, D any](world *World) *Filter4[A, B, C, D] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
	}
	components := make([]*componentStorage, 4)
	components[0] = &world.storage.components[ids[0].id]
	components[1] = &world.storage.components[ids[1].id]
	components[2] = &world.storage.components[ids[2].id]
	components[3] = &world.storage.components[ids[3].id]
	return &Filter4[A, B, C, D]{
		world:      world,
		ids:        ids,
		filter:     newFilter(ids...),
		components: components,
	}
}

// With specifies additional components to filter for.
// Can be called multiple times in chains, or once with multiple arguments.
func (f *Filter4[A, B, C, D]) With(comps ...Comp) *Filter4[A, B, C, D] {
	f.checkModify()
	for _, c := range comps {
		id := f.world.componentID(c.tp)
		f.ids = append(f.ids, id)
		f.filter.mask.Set(id.id)
	}
	return f
}

// Without specifies components to exclude.
// Can be called multiple times in chains, or once with multiple arguments.
func (f *Filter4[A, B, C, D]) Without(comps ...Comp) *Filter4[A, B, C, D] {
	f.checkModify()
	if len(comps) == 0 {
		return f
	}
	for _, c := range comps {
		id := f.world.componentID(c.tp)
		f.filter.without.Set(id.id)
		f.filter.hasWithout = true
	}
	return f
}

// Exclusive makes the filter exclusive in the sense that the component composition is matched exactly,
// and no other components are allowed. This includes components set via [Filter4.With].
//
// Overwrites components set via [Filter4.Without].
func (f *Filter4[A, B, C, D]) Exclusive() *Filter4[A, B, C, D] {
	f.checkModify()
	f.filter = f.filter.Exclusive()
	return f
}

// Relations sets permanent entity relation targets for this filter.
// Relation targets set here are included in filter caching.
// Contrary, relation targets specified in [Filter4.Query] or [Filter4.Batch] are not cached.
//
// Relation components used here must be in the filter's parameters
// or added via [Filter4.With] beforehand.
//
// Can be called multiple times in chains, or once with multiple arguments.
func (f *Filter4[A, B, C, D]) Relations(rel ...Relation) *Filter4[A, B, C, D] {
	f.checkModify()
	f.relations = relationSlice(rel).ToRelations(f.world, &f.filter.mask, f.ids, f.relations[:f.numRelations], nil)
	f.numRelations = uint8(len(f.relations))
	return f
}

// Register this filter to the world's filter cache.
//
// Registering filters is optional.
// It avoids a potential slowdown that may be caused by a very high number of archetypes, like hundreds or thousands.
func (f *Filter4[A, B, C, D]) Register() *Filter4[A, B, C, D] {
	if f.filter.cache != maxCacheID {
		panic("filter is already registered, can't register")
	}
	f.world.storage.registerFilter(&f.filter, f.relations[:f.numRelations])
	return f
}

// Unregister this filter from the world's filter cache.
func (f *Filter4[A, B, C, D]) Unregister() {
	if f.filter.cache == maxCacheID {
		panic("filter is not registered, can't unregister")
	}
	f.world.storage.unregisterFilter(&f.filter)
}

// Query creates a [Query4] from this filter.
// This must be used each time before iterating a query.
//
// Relation targets provided here are added to those specified with [Filter4.Relations].
// Relation components must be in the filter's parameters or added via [Filter4.With] beforehand.
func (f *Filter4[A, B, C, D]) Query(rel ...Relation) Query4[A, B, C, D] {
	pooled := len(rel) > 0
	var relations []relationID

	f.world.storage.mu.Lock()
	lock := f.world.storage.lock()
	if pooled {
		relations = f.world.storage.slices.relationsPool.Get()
	}
	if f.filter.cache == maxCacheID && f.generation != f.world.storage.registry.getGeneration() {
		f.rareComp = f.world.storage.registry.rareComponent(f.ids).id
		f.generation = f.world.storage.registry.getGeneration()
	}
	f.world.storage.mu.Unlock()

	relations = relationSlice(rel).ToRelations(f.world, &f.filter.mask, f.ids, f.relations[:f.numRelations], relations)

	var start uint8
	var cache *cacheEntry
	if f.filter.cache != maxCacheID {
		start = f.numRelations
		cache = f.world.storage.getRegisteredFilter(f.filter.cache)
	}

	return Query4[A, B, C, D]{
		world:      f.world,
		filter:     &f.filter,
		relations:  relations[start:],
		cache:      cache,
		lock:       lock,
		components: f.components,
		cursor: cursor{
			archetype: -1,
			table:     -1,
			index:     0,
			maxIndex:  -1,
		},
		rareComp: f.rareComp,

		isPooled: pooled,
	}
}

// Batch creates a [Batch] from this filter.
//
// Relation targets provided here are added to those specified with [Filter4.Relations].
// Relation components must be in the filter's parameters or added via [Filter4.With] beforehand.
//
// ⚠️ The returned [Batch] filter should not be stored, but used immediately and re-generated
// each time a batch operation is called.
// Otherwise, changes to the origin filter or calls to [Filter4.Batch] or [Filter4.Query]
// with different relationship targets may modify stored instances.
func (f *Filter4[A, B, C, D]) Batch(rel ...Relation) Batch {
	f.relations = relationSlice(rel).ToRelations(f.world, &f.filter.mask, f.ids, f.relations[:f.numRelations], nil)
	var start uint8
	if f.filter.cache != maxCacheID {
		start = f.numRelations
	}
	return Batch{
		filter:    &f.filter,
		relations: f.relations[start:],
	}
}

func (f *Filter4[A, B, C, D]) checkModify() {
	if f.filter.cache != maxCacheID {
		panic("can't modify a cached filter")
	}
	if f.generation != 0 {
		panic("can't modify a filter that was already queried")
	}
}

// Filter5 is a filter for 5 components.
// Used to create [Query5] iterators.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Filter2] for a usage example.
type Filter5[A any, B any, C any, D any, E any] struct {
	world        *World
	ids          []ID
	relations    []relationID
	components   []*componentStorage
	filter       filter
	generation   uint32
	rareComp     uint8
	numRelations uint8
}

// New creates a new [Filter5]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
//
// See [Filter2.New] for an example.
func (*Filter5[A, B, C, D, E]) New(world *World) *Filter5[A, B, C, D, E] {
	return NewFilter5[A, B, C, D, E](world)
}

// NewFilter5 creates a new [Filter5].
//
// Use [Filter5.Query] to obtain a [Query5].
//
// See also [Filter5.New] for a shortcut when constructing an already defined instance.
func NewFilter5[A any, B any, C any, D any, E any](world *World) *Filter5[A, B, C, D, E] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
	}
	components := make([]*componentStorage, 5)
	components[0] = &world.storage.components[ids[0].id]
	components[1] = &world.storage.components[ids[1].id]
	components[2] = &world.storage.components[ids[2].id]
	components[3] = &world.storage.components[ids[3].id]
	components[4] = &world.storage.components[ids[4].id]
	return &Filter5[A, B, C, D, E]{
		world:      world,
		ids:        ids,
		filter:     newFilter(ids...),
		components: components,
	}
}

// With specifies additional components to filter for.
// Can be called multiple times in chains, or once with multiple arguments.
func (f *Filter5[A, B, C, D, E]) With(comps ...Comp) *Filter5[A, B, C, D, E] {
	f.checkModify()
	for _, c := range comps {
		id := f.world.componentID(c.tp)
		f.ids = append(f.ids, id)
		f.filter.mask.Set(id.id)
	}
	return f
}

// Without specifies components to exclude.
// Can be called multiple times in chains, or once with multiple arguments.
func (f *Filter5[A, B, C, D, E]) Without(comps ...Comp) *Filter5[A, B, C, D, E] {
	f.checkModify()
	if len(comps) == 0 {
		return f
	}
	for _, c := range comps {
		id := f.world.componentID(c.tp)
		f.filter.without.Set(id.id)
		f.filter.hasWithout = true
	}
	return f
}

// Exclusive makes the filter exclusive in the sense that the component composition is matched exactly,
// and no other components are allowed. This includes components set via [Filter5.With].
//
// Overwrites components set via [Filter5.Without].
func (f *Filter5[A, B, C, D, E]) Exclusive() *Filter5[A, B, C, D, E] {
	f.checkModify()
	f.filter = f.filter.Exclusive()
	return f
}

// Relations sets permanent entity relation targets for this filter.
// Relation targets set here are included in filter caching.
// Contrary, relation targets specified in [Filter5.Query] or [Filter5.Batch] are not cached.
//
// Relation components used here must be in the filter's parameters
// or added via [Filter5.With] beforehand.
//
// Can be called multiple times in chains, or once with multiple arguments.
func (f *Filter5[A, B, C, D, E]) Relations(rel ...Relation) *Filter5[A, B, C, D, E] {
	f.checkModify()
	f.relations = relationSlice(rel).ToRelations(f.world, &f.filter.mask, f.ids, f.relations[:f.numRelations], nil)
	f.numRelations = uint8(len(f.relations))
	return f
}

// Register this filter to the world's filter cache.
//
// Registering filters is optional.
// It avoids a potential slowdown that may be caused by a very high number of archetypes, like hundreds or thousands.
func (f *Filter5[A, B, C, D, E]) Register() *Filter5[A, B, C, D, E] {
	if f.filter.cache != maxCacheID {
		panic("filter is already registered, can't register")
	}
	f.world.storage.registerFilter(&f.filter, f.relations[:f.numRelations])
	return f
}

// Unregister this filter from the world's filter cache.
func (f *Filter5[A, B, C, D, E]) Unregister() {
	if f.filter.cache == maxCacheID {
		panic("filter is not registered, can't unregister")
	}
	f.world.storage.unregisterFilter(&f.filter)
}

// Query creates a [Query5] from this filter.
// This must be used each time before iterating a query.
//
// Relation targets provided here are added to those specified with [Filter5.Relations].
// Relation components must be in the filter's parameters or added via [Filter5.With] beforehand.
func (f *Filter5[A, B, C, D, E]) Query(rel ...Relation) Query5[A, B, C, D, E] {
	pooled := len(rel) > 0
	var relations []relationID

	f.world.storage.mu.Lock()
	lock := f.world.storage.lock()
	if pooled {
		relations = f.world.storage.slices.relationsPool.Get()
	}
	if f.filter.cache == maxCacheID && f.generation != f.world.storage.registry.getGeneration() {
		f.rareComp = f.world.storage.registry.rareComponent(f.ids).id
		f.generation = f.world.storage.registry.getGeneration()
	}
	f.world.storage.mu.Unlock()

	relations = relationSlice(rel).ToRelations(f.world, &f.filter.mask, f.ids, f.relations[:f.numRelations], relations)

	var start uint8
	var cache *cacheEntry
	if f.filter.cache != maxCacheID {
		start = f.numRelations
		cache = f.world.storage.getRegisteredFilter(f.filter.cache)
	}

	return Query5[A, B, C, D, E]{
		world:      f.world,
		filter:     &f.filter,
		relations:  relations[start:],
		cache:      cache,
		lock:       lock,
		components: f.components,
		cursor: cursor{
			archetype: -1,
			table:     -1,
			index:     0,
			maxIndex:  -1,
		},
		rareComp: f.rareComp,

		isPooled: pooled,
	}
}

// Batch creates a [Batch] from this filter.
//
// Relation targets provided here are added to those specified with [Filter5.Relations].
// Relation components must be in the filter's parameters or added via [Filter5.With] beforehand.
//
// ⚠️ The returned [Batch] filter should not be stored, but used immediately and re-generated
// each time a batch operation is called.
// Otherwise, changes to the origin filter or calls to [Filter5.Batch] or [Filter5.Query]
// with different relationship targets may modify stored instances.
func (f *Filter5[A, B, C, D, E]) Batch(rel ...Relation) Batch {
	f.relations = relationSlice(rel).ToRelations(f.world, &f.filter.mask, f.ids, f.relations[:f.numRelations], nil)
	var start uint8
	if f.filter.cache != maxCacheID {
		start = f.numRelations
	}
	return Batch{
		filter:    &f.filter,
		relations: f.relations[start:],
	}
}

func (f *Filter5[A, B, C, D, E]) checkModify() {
	if f.filter.cache != maxCacheID {
		panic("can't modify a cached filter")
	}
	if f.generation != 0 {
		panic("can't modify a filter that was already queried")
	}
}

// Filter6 is a filter for 6 components.
// Used to create [Query6] iterators.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Filter2] for a usage example.
type Filter6[A any, B any, C any, D any, E any, F any] struct {
	world        *World
	ids          []ID
	relations    []relationID
	components   []*componentStorage
	filter       filter
	generation   uint32
	rareComp     uint8
	numRelations uint8
}

// New creates a new [Filter6]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
//
// See [Filter2.New] for an example.
func (*Filter6[A, B, C, D, E, F]) New(world *World) *Filter6[A, B, C, D, E, F] {
	return NewFilter6[A, B, C, D, E, F](world)
}

// NewFilter6 creates a new [Filter6].
//
// Use [Filter6.Query] to obtain a [Query6].
//
// See also [Filter6.New] for a shortcut when constructing an already defined instance.
func NewFilter6[A any, B any, C any, D any, E any, F any](world *World) *Filter6[A, B, C, D, E, F] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
		ComponentID[F](world),
	}
	components := make([]*componentStorage, 6)
	components[0] = &world.storage.components[ids[0].id]
	components[1] = &world.storage.components[ids[1].id]
	components[2] = &world.storage.components[ids[2].id]
	components[3] = &world.storage.components[ids[3].id]
	components[4] = &world.storage.components[ids[4].id]
	components[5] = &world.storage.components[ids[5].id]
	return &Filter6[A, B, C, D, E, F]{
		world:      world,
		ids:        ids,
		filter:     newFilter(ids...),
		components: components,
	}
}

// With specifies additional components to filter for.
// Can be called multiple times in chains, or once with multiple arguments.
func (f *Filter6[A, B, C, D, E, F]) With(comps ...Comp) *Filter6[A, B, C, D, E, F] {
	f.checkModify()
	for _, c := range comps {
		id := f.world.componentID(c.tp)
		f.ids = append(f.ids, id)
		f.filter.mask.Set(id.id)
	}
	return f
}

// Without specifies components to exclude.
// Can be called multiple times in chains, or once with multiple arguments.
func (f *Filter6[A, B, C, D, E, F]) Without(comps ...Comp) *Filter6[A, B, C, D, E, F] {
	f.checkModify()
	if len(comps) == 0 {
		return f
	}
	for _, c := range comps {
		id := f.world.componentID(c.tp)
		f.filter.without.Set(id.id)
		f.filter.hasWithout = true
	}
	return f
}

// Exclusive makes the filter exclusive in the sense that the component composition is matched exactly,
// and no other components are allowed. This includes components set via [Filter6.With].
//
// Overwrites components set via [Filter6.Without].
func (f *Filter6[A, B, C, D, E, F]) Exclusive() *Filter6[A, B, C, D, E, F] {
	f.checkModify()
	f.filter = f.filter.Exclusive()
	return f
}

// Relations sets permanent entity relation targets for this filter.
// Relation targets set here are included in filter caching.
// Contrary, relation targets specified in [Filter6.Query] or [Filter6.Batch] are not cached.
//
// Relation components used here must be in the filter's parameters
// or added via [Filter6.With] beforehand.
//
// Can be called multiple times in chains, or once with multiple arguments.
func (f *Filter6[A, B, C, D, E, F]) Relations(rel ...Relation) *Filter6[A, B, C, D, E, F] {
	f.checkModify()
	f.relations = relationSlice(rel).ToRelations(f.world, &f.filter.mask, f.ids, f.relations[:f.numRelations], nil)
	f.numRelations = uint8(len(f.relations))
	return f
}

// Register this filter to the world's filter cache.
//
// Registering filters is optional.
// It avoids a potential slowdown that may be caused by a very high number of archetypes, like hundreds or thousands.
func (f *Filter6[A, B, C, D, E, F]) Register() *Filter6[A, B, C, D, E, F] {
	if f.filter.cache != maxCacheID {
		panic("filter is already registered, can't register")
	}
	f.world.storage.registerFilter(&f.filter, f.relations[:f.numRelations])
	return f
}

// Unregister this filter from the world's filter cache.
func (f *Filter6[A, B, C, D, E, F]) Unregister() {
	if f.filter.cache == maxCacheID {
		panic("filter is not registered, can't unregister")
	}
	f.world.storage.unregisterFilter(&f.filter)
}

// Query creates a [Query6] from this filter.
// This must be used each time before iterating a query.
//
// Relation targets provided here are added to those specified with [Filter6.Relations].
// Relation components must be in the filter's parameters or added via [Filter6.With] beforehand.
func (f *Filter6[A, B, C, D, E, F]) Query(rel ...Relation) Query6[A, B, C, D, E, F] {
	pooled := len(rel) > 0
	var relations []relationID

	f.world.storage.mu.Lock()
	lock := f.world.storage.lock()
	if pooled {
		relations = f.world.storage.slices.relationsPool.Get()
	}
	if f.filter.cache == maxCacheID && f.generation != f.world.storage.registry.getGeneration() {
		f.rareComp = f.world.storage.registry.rareComponent(f.ids).id
		f.generation = f.world.storage.registry.getGeneration()
	}
	f.world.storage.mu.Unlock()

	relations = relationSlice(rel).ToRelations(f.world, &f.filter.mask, f.ids, f.relations[:f.numRelations], relations)

	var start uint8
	var cache *cacheEntry
	if f.filter.cache != maxCacheID {
		start = f.numRelations
		cache = f.world.storage.getRegisteredFilter(f.filter.cache)
	}

	return Query6[A, B, C, D, E, F]{
		world:      f.world,
		filter:     &f.filter,
		relations:  relations[start:],
		cache:      cache,
		lock:       lock,
		components: f.components,
		cursor: cursor{
			archetype: -1,
			table:     -1,
			index:     0,
			maxIndex:  -1,
		},
		rareComp: f.rareComp,

		isPooled: pooled,
	}
}

// Batch creates a [Batch] from this filter.
//
// Relation targets provided here are added to those specified with [Filter6.Relations].
// Relation components must be in the filter's parameters or added via [Filter6.With] beforehand.
//
// ⚠️ The returned [Batch] filter should not be stored, but used immediately and re-generated
// each time a batch operation is called.
// Otherwise, changes to the origin filter or calls to [Filter6.Batch] or [Filter6.Query]
// with different relationship targets may modify stored instances.
func (f *Filter6[A, B, C, D, E, F]) Batch(rel ...Relation) Batch {
	f.relations = relationSlice(rel).ToRelations(f.world, &f.filter.mask, f.ids, f.relations[:f.numRelations], nil)
	var start uint8
	if f.filter.cache != maxCacheID {
		start = f.numRelations
	}
	return Batch{
		filter:    &f.filter,
		relations: f.relations[start:],
	}
}

func (f *Filter6[A, B, C, D, E, F]) checkModify() {
	if f.filter.cache != maxCacheID {
		panic("can't modify a cached filter")
	}
	if f.generation != 0 {
		panic("can't modify a filter that was already queried")
	}
}

// Filter7 is a filter for 7 components.
// Used to create [Query7] iterators.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Filter2] for a usage example.
type Filter7[A any, B any, C any, D any, E any, F any, G any] struct {
	world        *World
	ids          []ID
	relations    []relationID
	components   []*componentStorage
	filter       filter
	generation   uint32
	rareComp     uint8
	numRelations uint8
}

// New creates a new [Filter7]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
//
// See [Filter2.New] for an example.
func (*Filter7[A, B, C, D, E, F, G]) New(world *World) *Filter7[A, B, C, D, E, F, G] {
	return NewFilter7[A, B, C, D, E, F, G](world)
}

// NewFilter7 creates a new [Filter7].
//
// Use [Filter7.Query] to obtain a [Query7].
//
// See also [Filter7.New] for a shortcut when constructing an already defined instance.
func NewFilter7[A any, B any, C any, D any, E any, F any, G any](world *World) *Filter7[A, B, C, D, E, F, G] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
		ComponentID[F](world),
		ComponentID[G](world),
	}
	components := make([]*componentStorage, 7)
	components[0] = &world.storage.components[ids[0].id]
	components[1] = &world.storage.components[ids[1].id]
	components[2] = &world.storage.components[ids[2].id]
	components[3] = &world.storage.components[ids[3].id]
	components[4] = &world.storage.components[ids[4].id]
	components[5] = &world.storage.components[ids[5].id]
	components[6] = &world.storage.components[ids[6].id]
	return &Filter7[A, B, C, D, E, F, G]{
		world:      world,
		ids:        ids,
		filter:     newFilter(ids...),
		components: components,
	}
}

// With specifies additional components to filter for.
// Can be called multiple times in chains, or once with multiple arguments.
func (f *Filter7[A, B, C, D, E, F, G]) With(comps ...Comp) *Filter7[A, B, C, D, E, F, G] {
	f.checkModify()
	for _, c := range comps {
		id := f.world.componentID(c.tp)
		f.ids = append(f.ids, id)
		f.filter.mask.Set(id.id)
	}
	return f
}

// Without specifies components to exclude.
// Can be called multiple times in chains, or once with multiple arguments.
func (f *Filter7[A, B, C, D, E, F, G]) Without(comps ...Comp) *Filter7[A, B, C, D, E, F, G] {
	f.checkModify()
	if len(comps) == 0 {
		return f
	}
	for _, c := range comps {
		id := f.world.componentID(c.tp)
		f.filter.without.Set(id.id)
		f.filter.hasWithout = true
	}
	return f
}

// Exclusive makes the filter exclusive in the sense that the component composition is matched exactly,
// and no other components are allowed. This includes components set via [Filter7.With].
//
// Overwrites components set via [Filter7.Without].
func (f *Filter7[A, B, C, D, E, F, G]) Exclusive() *Filter7[A, B, C, D, E, F, G] {
	f.checkModify()
	f.filter = f.filter.Exclusive()
	return f
}

// Relations sets permanent entity relation targets for this filter.
// Relation targets set here are included in filter caching.
// Contrary, relation targets specified in [Filter7.Query] or [Filter7.Batch] are not cached.
//
// Relation components used here must be in the filter's parameters
// or added via [Filter7.With] beforehand.
//
// Can be called multiple times in chains, or once with multiple arguments.
func (f *Filter7[A, B, C, D, E, F, G]) Relations(rel ...Relation) *Filter7[A, B, C, D, E, F, G] {
	f.checkModify()
	f.relations = relationSlice(rel).ToRelations(f.world, &f.filter.mask, f.ids, f.relations[:f.numRelations], nil)
	f.numRelations = uint8(len(f.relations))
	return f
}

// Register this filter to the world's filter cache.
//
// Registering filters is optional.
// It avoids a potential slowdown that may be caused by a very high number of archetypes, like hundreds or thousands.
func (f *Filter7[A, B, C, D, E, F, G]) Register() *Filter7[A, B, C, D, E, F, G] {
	if f.filter.cache != maxCacheID {
		panic("filter is already registered, can't register")
	}
	f.world.storage.registerFilter(&f.filter, f.relations[:f.numRelations])
	return f
}

// Unregister this filter from the world's filter cache.
func (f *Filter7[A, B, C, D, E, F, G]) Unregister() {
	if f.filter.cache == maxCacheID {
		panic("filter is not registered, can't unregister")
	}
	f.world.storage.unregisterFilter(&f.filter)
}

// Query creates a [Query7] from this filter.
// This must be used each time before iterating a query.
//
// Relation targets provided here are added to those specified with [Filter7.Relations].
// Relation components must be in the filter's parameters or added via [Filter7.With] beforehand.
func (f *Filter7[A, B, C, D, E, F, G]) Query(rel ...Relation) Query7[A, B, C, D, E, F, G] {
	pooled := len(rel) > 0
	var relations []relationID

	f.world.storage.mu.Lock()
	lock := f.world.storage.lock()
	if pooled {
		relations = f.world.storage.slices.relationsPool.Get()
	}
	if f.filter.cache == maxCacheID && f.generation != f.world.storage.registry.getGeneration() {
		f.rareComp = f.world.storage.registry.rareComponent(f.ids).id
		f.generation = f.world.storage.registry.getGeneration()
	}
	f.world.storage.mu.Unlock()

	relations = relationSlice(rel).ToRelations(f.world, &f.filter.mask, f.ids, f.relations[:f.numRelations], relations)

	var start uint8
	var cache *cacheEntry
	if f.filter.cache != maxCacheID {
		start = f.numRelations
		cache = f.world.storage.getRegisteredFilter(f.filter.cache)
	}

	return Query7[A, B, C, D, E, F, G]{
		world:      f.world,
		filter:     &f.filter,
		relations:  relations[start:],
		cache:      cache,
		lock:       lock,
		components: f.components,
		cursor: cursor{
			archetype: -1,
			table:     -1,
			index:     0,
			maxIndex:  -1,
		},
		rareComp: f.rareComp,

		isPooled: pooled,
	}
}

// Batch creates a [Batch] from this filter.
//
// Relation targets provided here are added to those specified with [Filter7.Relations].
// Relation components must be in the filter's parameters or added via [Filter7.With] beforehand.
//
// ⚠️ The returned [Batch] filter should not be stored, but used immediately and re-generated
// each time a batch operation is called.
// Otherwise, changes to the origin filter or calls to [Filter7.Batch] or [Filter7.Query]
// with different relationship targets may modify stored instances.
func (f *Filter7[A, B, C, D, E, F, G]) Batch(rel ...Relation) Batch {
	f.relations = relationSlice(rel).ToRelations(f.world, &f.filter.mask, f.ids, f.relations[:f.numRelations], nil)
	var start uint8
	if f.filter.cache != maxCacheID {
		start = f.numRelations
	}
	return Batch{
		filter:    &f.filter,
		relations: f.relations[start:],
	}
}

func (f *Filter7[A, B, C, D, E, F, G]) checkModify() {
	if f.filter.cache != maxCacheID {
		panic("can't modify a cached filter")
	}
	if f.generation != 0 {
		panic("can't modify a filter that was already queried")
	}
}

// Filter8 is a filter for 8 components.
// Used to create [Query8] iterators.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Filter2] for a usage example.
type Filter8[A any, B any, C any, D any, E any, F any, G any, H any] struct {
	world        *World
	ids          []ID
	relations    []relationID
	components   []*componentStorage
	filter       filter
	generation   uint32
	rareComp     uint8
	numRelations uint8
}

// New creates a new [Filter8]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
//
// See [Filter2.New] for an example.
func (*Filter8[A, B, C, D, E, F, G, H]) New(world *World) *Filter8[A, B, C, D, E, F, G, H] {
	return NewFilter8[A, B, C, D, E, F, G, H](world)
}

// NewFilter8 creates a new [Filter8].
//
// Use [Filter8.Query] to obtain a [Query8].
//
// See also [Filter8.New] for a shortcut when constructing an already defined instance.
func NewFilter8[A any, B any, C any, D any, E any, F any, G any, H any](world *World) *Filter8[A, B, C, D, E, F, G, H] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
		ComponentID[F](world),
		ComponentID[G](world),
		ComponentID[H](world),
	}
	components := make([]*componentStorage, 8)
	components[0] = &world.storage.components[ids[0].id]
	components[1] = &world.storage.components[ids[1].id]
	components[2] = &world.storage.components[ids[2].id]
	components[3] = &world.storage.components[ids[3].id]
	components[4] = &world.storage.components[ids[4].id]
	components[5] = &world.storage.components[ids[5].id]
	components[6] = &world.storage.components[ids[6].id]
	components[7] = &world.storage.components[ids[7].id]
	return &Filter8[A, B, C, D, E, F, G, H]{
		world:      world,
		ids:        ids,
		filter:     newFilter(ids...),
		components: components,
	}
}

// With specifies additional components to filter for.
// Can be called multiple times in chains, or once with multiple arguments.
func (f *Filter8[A, B, C, D, E, F, G, H]) With(comps ...Comp) *Filter8[A, B, C, D, E, F, G, H] {
	f.checkModify()
	for _, c := range comps {
		id := f.world.componentID(c.tp)
		f.ids = append(f.ids, id)
		f.filter.mask.Set(id.id)
	}
	return f
}

// Without specifies components to exclude.
// Can be called multiple times in chains, or once with multiple arguments.
func (f *Filter8[A, B, C, D, E, F, G, H]) Without(comps ...Comp) *Filter8[A, B, C, D, E, F, G, H] {
	f.checkModify()
	if len(comps) == 0 {
		return f
	}
	for _, c := range comps {
		id := f.world.componentID(c.tp)
		f.filter.without.Set(id.id)
		f.filter.hasWithout = true
	}
	return f
}

// Exclusive makes the filter exclusive in the sense that the component composition is matched exactly,
// and no other components are allowed. This includes components set via [Filter8.With].
//
// Overwrites components set via [Filter8.Without].
func (f *Filter8[A, B, C, D, E, F, G, H]) Exclusive() *Filter8[A, B, C, D, E, F, G, H] {
	f.checkModify()
	f.filter = f.filter.Exclusive()
	return f
}

// Relations sets permanent entity relation targets for this filter.
// Relation targets set here are included in filter caching.
// Contrary, relation targets specified in [Filter8.Query] or [Filter8.Batch] are not cached.
//
// Relation components used here must be in the filter's parameters
// or added via [Filter8.With] beforehand.
//
// Can be called multiple times in chains, or once with multiple arguments.
func (f *Filter8[A, B, C, D, E, F, G, H]) Relations(rel ...Relation) *Filter8[A, B, C, D, E, F, G, H] {
	f.checkModify()
	f.relations = relationSlice(rel).ToRelations(f.world, &f.filter.mask, f.ids, f.relations[:f.numRelations], nil)
	f.numRelations = uint8(len(f.relations))
	return f
}

// Register this filter to the world's filter cache.
//
// Registering filters is optional.
// It avoids a potential slowdown that may be caused by a very high number of archetypes, like hundreds or thousands.
func (f *Filter8[A, B, C, D, E, F, G, H]) Register() *Filter8[A, B, C, D, E, F, G, H] {
	if f.filter.cache != maxCacheID {
		panic("filter is already registered, can't register")
	}
	f.world.storage.registerFilter(&f.filter, f.relations[:f.numRelations])
	return f
}

// Unregister this filter from the world's filter cache.
func (f *Filter8[A, B, C, D, E, F, G, H]) Unregister() {
	if f.filter.cache == maxCacheID {
		panic("filter is not registered, can't unregister")
	}
	f.world.storage.unregisterFilter(&f.filter)
}

// Query creates a [Query8] from this filter.
// This must be used each time before iterating a query.
//
// Relation targets provided here are added to those specified with [Filter8.Relations].
// Relation components must be in the filter's parameters or added via [Filter8.With] beforehand.
func (f *Filter8[A, B, C, D, E, F, G, H]) Query(rel ...Relation) Query8[A, B, C, D, E, F, G, H] {
	pooled := len(rel) > 0
	var relations []relationID

	f.world.storage.mu.Lock()
	lock := f.world.storage.lock()
	if pooled {
		relations = f.world.storage.slices.relationsPool.Get()
	}
	if f.filter.cache == maxCacheID && f.generation != f.world.storage.registry.getGeneration() {
		f.rareComp = f.world.storage.registry.rareComponent(f.ids).id
		f.generation = f.world.storage.registry.getGeneration()
	}
	f.world.storage.mu.Unlock()

	relations = relationSlice(rel).ToRelations(f.world, &f.filter.mask, f.ids, f.relations[:f.numRelations], relations)

	var start uint8
	var cache *cacheEntry
	if f.filter.cache != maxCacheID {
		start = f.numRelations
		cache = f.world.storage.getRegisteredFilter(f.filter.cache)
	}

	return Query8[A, B, C, D, E, F, G, H]{
		world:      f.world,
		filter:     &f.filter,
		relations:  relations[start:],
		cache:      cache,
		lock:       lock,
		components: f.components,
		cursor: cursor{
			archetype: -1,
			table:     -1,
			index:     0,
			maxIndex:  -1,
		},
		rareComp: f.rareComp,

		isPooled: pooled,
	}
}

// Batch creates a [Batch] from this filter.
//
// Relation targets provided here are added to those specified with [Filter8.Relations].
// Relation components must be in the filter's parameters or added via [Filter8.With] beforehand.
//
// ⚠️ The returned [Batch] filter should not be stored, but used immediately and re-generated
// each time a batch operation is called.
// Otherwise, changes to the origin filter or calls to [Filter8.Batch] or [Filter8.Query]
// with different relationship targets may modify stored instances.
func (f *Filter8[A, B, C, D, E, F, G, H]) Batch(rel ...Relation) Batch {
	f.relations = relationSlice(rel).ToRelations(f.world, &f.filter.mask, f.ids, f.relations[:f.numRelations], nil)
	var start uint8
	if f.filter.cache != maxCacheID {
		start = f.numRelations
	}
	return Batch{
		filter:    &f.filter,
		relations: f.relations[start:],
	}
}

func (f *Filter8[A, B, C, D, E, F, G, H]) checkModify() {
	if f.filter.cache != maxCacheID {
		panic("can't modify a cached filter")
	}
	if f.generation != 0 {
		panic("can't modify a filter that was already queried")
	}
}
