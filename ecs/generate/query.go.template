{{- define "template" -}}
package ecs

// Code generated by go generate; DO NOT EDIT.

type cursor struct {
	archetype int
	table     int
	index     uintptr
	maxIndex  int64
}

{{range makeRange 0 8}}
{{- $n := . -}}
{{- $upper := upperLetters . -}}
{{- $generics := "" -}}
{{- $genericsShort := "" -}}
{{- $return := "" -}}
{{- $mask := "" -}}
{{- if .}}
{{- $generics = join "[" " any, " " any]" $upper -}}
{{- $genericsShort = join "[" ", " "]" $upper -}}
{{- $return = join "(*" ", *" ")" $upper -}}
{{- $mask = join "id" ", id" "" $upper -}}
{{- end}}

// Query{{.}} is a query for {{.}} components.
// Use a [NewFilter{{.}}] to create one.
type Query{{.}}{{$generics}} struct {
	world      *World
	mask       Mask
	without    Mask
	relations  []relationID
	lock       uint8
	cursor     cursor
	tables     []tableID
	table      *table
	components []*componentStorage
	{{- range $upper}}
	column{{.}}    *column
	{{- end}}
	hasWithout bool
}

func newQuery{{.}}{{$generics}}(world *World, mask Mask, without Mask{{if .}}, ids []ID{{end}}, relations []relationID) Query{{.}}{{$genericsShort}} {
	components := make([]*componentStorage, {{.}})
	{{if .}}for i := range {{.}} {
		components[i] = &world.storage.components[ids[i].id]
	}{{end}}
	
	return Query{{.}}{{$genericsShort}}{
		world:      world,
		mask:       mask,
		without:    without,
		relations:  relations,
		hasWithout: !without.IsZero(),
		lock:       world.lock(),
		components: components,
		cursor: cursor{
			archetype: -1,
			table:     -1,
			index:     0,
			maxIndex:  -1,
		},
	}
}

// Next advances the query's cursor to the next entity.
func (q *Query{{.}}{{$genericsShort}}) Next() bool {
	checkQueryNext(&q.cursor)
	if int64(q.cursor.index) < q.cursor.maxIndex {
		q.cursor.index++
		return true
	}
	return q.nextTableOrArchetype()
}

// Entity returns the current entity.
func (q *Query{{.}}{{$genericsShort}}) Entity() Entity {
	checkQueryGet(&q.cursor)
	return q.table.GetEntity(q.cursor.index)
}

{{if . -}}
// Get returns the queried components of the current entity.
func (q *Query{{.}}{{$genericsShort}}) Get() {{$return}} {
	checkQueryGet(&q.cursor)
	return {{range $i, $v := $upper}}{{if $i}},
		{{end}}(*{{$v}})(q.column{{$v}}.Get(q.cursor.index)){{end}}
}

// GetRelation returns the entity relation target of the component at the given index.
func (q *Query{{.}}{{$genericsShort}}) GetRelation(index int) Entity {
	return q.components[index].columns[q.table.id].target
}
{{- end}}

// Close closes the Query and unlocks the world.
//
// Automatically called when iteration finishes.
// Needs to be called only if breaking out of the query iteration or not iterating at all.
func (q *Query{{.}}{{$genericsShort}}) Close() {
	q.cursor.archetype = -2
	q.cursor.table = -2
	q.tables = nil
	q.table = nil
	{{- range $i, $v := $upper}}
	q.column{{$v}} = nil
	{{- end}}
	q.world.unlock(q.lock)
}

func (q *Query{{.}}{{$genericsShort}}) nextTableOrArchetype() bool {
	if q.cursor.archetype >= 0 && q.nextTable() {
		return true
	}
	return q.nextArchetype()
}

func (q *Query{{.}}{{$genericsShort}}) nextArchetype() bool {
	maxArchIndex := len(q.world.storage.archetypes) - 1
	for q.cursor.archetype < maxArchIndex {
		q.cursor.archetype++
		archetype := &q.world.storage.archetypes[q.cursor.archetype]
		if !archetype.mask.Contains(&q.mask) ||
			archetype.mask.ContainsAny(&q.without) {
			continue
		}

		if !archetype.HasRelations() {
			table := &q.world.storage.tables[archetype.tables[0]]
			if table.Len() > 0 {
				q.setTable(0, table)
				return true
			}
			continue
		}

		q.tables = archetype.GetTables(q.relations)
		q.cursor.table = -1
		if q.nextTable() {
			return true
		}
	}
	q.Close()
	return false
}

func (q *Query{{.}}{{$genericsShort}}) nextTable() bool {
	maxTableIndex := len(q.tables) - 1
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		table := &q.world.storage.tables[q.tables[q.cursor.table]]
		if table.Len() == 0 {
			continue
		}
		if !table.Matches(q.relations) {
			continue
		}
		q.setTable(q.cursor.table, table)
		return true
	}
	return false
}

func (q *Query{{.}}{{$genericsShort}}) setTable(index int, table *table) {
	q.cursor.table = index
	q.table = table
	{{- range $i, $v := $upper}}
	q.column{{$v}} = q.components[{{$i}}].columns[q.table.id]
	{{- end}}
	q.cursor.index = 0
	q.cursor.maxIndex = int64(q.table.entities.Len() - 1)
}

{{end -}}
{{end -}}
