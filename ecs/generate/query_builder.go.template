{{- define "template" -}}
package ecs

// Code generated by go generate; DO NOT EDIT.

{{range makeRange 0 8}}
{{- $upper := upperLetters . -}}
{{- $generics := "" -}}
{{- $genericsShort := "" -}}
{{- if .}}
{{- $generics = join "[" " any, " " any]" $upper -}}
{{- $genericsShort = join "[" ", " "]" $upper -}}
{{- end}}

// QueryBuilder{{.}} builds a [Query{{.}}].
type QueryBuilder{{.}}{{$generics}} struct {
	world *World
	mask  Mask
	ids   []ID
}

// NewQuery{{.}} creates a new [QueryBuilder{{.}}].
//
// Use [QueryBuilder{{.}}.Build] to obtain a [Query{{.}}].
func NewQuery{{.}}{{$generics}}(world *World) *QueryBuilder{{.}}{{$genericsShort}} {
	ids := make([]ID, {{.}})
	{{- range $i, $v := $upper}}
	ids[{{$i}}] = ComponentID[{{$v}}](world)
	{{- end}}

	return &QueryBuilder{{.}}{{$genericsShort}}{
		world: world,
		mask:  All(ids[:]...),
		ids:   ids,
	}
}

// Build creates a [Query{{.}}] from this builder.
func (q *QueryBuilder{{.}}{{$genericsShort}}) Build() Query{{.}}{{$genericsShort}} {
	components := make([]*componentStorage, {{.}})
	{{if .}}for i := range {{.}} {
		components[i] = &q.world.storage.components[q.ids[i].id]
	}{{end}}
	
	return Query{{.}}{{$genericsShort}}{
		world:      q.world,
		mask:       q.mask,
		components: components,
		cursor: cursor{
			table:    -1,
			index:    0,
			maxIndex: -1,
		},
	}
}
{{end -}}
{{end -}}
