{{- define "template" -}}
package ecs

// Code generated by go generate; DO NOT EDIT.

import (
	"testing"
)

{{range makeRange 1 8}}
{{- $n := . -}}
{{- $upper := upperLetters . -}}
{{- $lower := lowerLetters . -}}

{{- $generics := join "[Comp" ", Comp" "]" $upper -}}
{{- $args := arguments $lower $upper "" "Comp" -}}
{{- $mapArgs := join "&Comp" "{}, &Comp" "{}" $upper -}}
{{- $comps := join "" ", " "" $lower -}}

func TestExchange{{.}}(t *testing.T) {
	w := NewWorld(16)

	posMap := NewMap2[Position, Velocity](&w)
	mapper := NewMap{{.}}{{$generics}}(&w)

	var ex *Exchange{{.}}{{$generics}}
	ex = ex.New(&w).Removes(C[Velocity](), C[Position]())

	e := posMap.NewEntity(&Position{}, &Velocity{})

	ex.Exchange(e, {{$mapArgs}})
	if posMap.HasAll(e) {
		t.Errorf("expected posMap.HasAll(e) to be false")
	}
	if !mapper.HasAll(e) {
		t.Errorf("expected mapper.HasAll(e) to be true")
	}
	
	e = posMap.NewEntity(&Position{}, &Velocity{})
	ex.ExchangeFn(e, func({{$args}}){
		a.X = 100
	})
	if posMap.HasAll(e) {
		t.Errorf("expected posMap.HasAll(e) to be false")
	}
	if !mapper.HasAll(e) {
		t.Errorf("expected mapper.HasAll(e) to be true")
	}
}

func TestExchange{{.}}Add(t *testing.T) {
	w := NewWorld(16)

	posMap := NewMap2[Position, Velocity](&w)
	mapper := NewMap{{.}}{{$generics}}(&w)
	ex := NewExchange{{.}}{{$generics}}(&w).Removes(C[Velocity](), C[Position]())

	e := posMap.NewEntity(&Position{}, &Velocity{})

	ex.Add(e, {{$mapArgs}})
	if !posMap.HasAll(e) {
		t.Errorf("expected posMap.HasAll(e) to be true")
	}
	if !mapper.HasAll(e) {
		t.Errorf("expected mapper.HasAll(e) to be true")
	}
	
	e = posMap.NewEntity(&Position{}, &Velocity{})
	ex.AddFn(e, func({{$args}}){
		a.X = 100
	})
	if !posMap.HasAll(e) {
		t.Errorf("expected posMap.HasAll(e) to be true")
	}
	if !mapper.HasAll(e) {
		t.Errorf("expected mapper.HasAll(e) to be true")
	}
}

func TestExchange{{.}}Remove(t *testing.T) {
	w := NewWorld(16)

	posMap := NewMap2[Position, Velocity](&w)
	mapper := NewMap{{.}}{{$generics}}(&w)
	ex := NewExchange{{.}}{{$generics}}(&w).Removes(C[Velocity](), C[Position]())

	e := posMap.NewEntity(&Position{}, &Velocity{})

	ex.Remove(e)
	if posMap.HasAll(e) {
		t.Errorf("expected posMap.HasAll(e) to be false")
	}
	if mapper.HasAll(e) {
		t.Errorf("expected mapper.HasAll(e) to be false")
	}
}

func TestExchange{{.}}AddBatch(t *testing.T) {
	n := 12
	w := NewWorld(8)

	exchange := NewExchange{{.}}{{$generics}}(&w).Removes(C[CompA]())
	posMap := NewMap1[Position](&w)
	posVelMap := NewMap2[Position, Velocity](&w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position){
		pos.X = float64(cnt)
		cnt++
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity){
		pos.X = float64(cnt)
		cnt++
	})
	if cnt != 2*n+1 {
		t.Errorf("expected cnt to be %d, got %d", 2*n+1, cnt)
	}

	filter := NewFilter1[Position](&w)
	exchange.AddBatch(filter.Batch(), {{$mapArgs}})

	filter2 := NewFilter1[CompA](&w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		pos := posMap.Get(query.Entity())
		if pos.X <= 0.0 {
			t.Errorf("expected pos.X > 0.0, got %f", pos.X)
		}
		cnt++
	}
	if cnt != 2*n {
		t.Errorf("expected cnt to be %d, got %d", 2*n, cnt)
	}

	exchange.RemoveBatch(filter2.Batch(), nil)
	
	query = filter2.Query()
	cnt = 0
	for query.Next() {
		cnt++
	}
	if cnt != 0 {
		t.Errorf("expected cnt to be 0 after removal, got %d", cnt)
	}
}

func TestExchange{{.}}AddBatchFn(t *testing.T) {
	n := 12
	w := NewWorld(8)

	exchange := NewExchange{{.}}{{$generics}}(&w).Removes(C[CompA]())
	posMap := NewMap1[Position](&w)
	posVelMap := NewMap2[Position, Velocity](&w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position){
		pos.X = float64(cnt)
		cnt++
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity){
		pos.X = float64(cnt)
		cnt++
	})
	if cnt != 2*n+1 {
		t.Errorf("expected cnt to be %d, got %d", 2*n+1, cnt)
	}

	filter := NewFilter1[Position](&w)
	cnt = 0
	exchange.AddBatchFn(filter.Batch(), func(entity Entity, {{$args}}){
		a.X = float64(cnt)
		cnt++
	})

	filter2 := NewFilter1[CompA](&w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		a := query.Get()
		if a.X != float64(cnt) {
			t.Errorf("expected a.X to be %f, got %f", float64(cnt), a.X)
		}
		pos := posMap.Get(query.Entity())
		if pos.X <= 0.0 {
			t.Errorf("expected pos.X > 0.0, got %f", pos.X)
		}
		cnt++
	}
	if cnt != 2*n {
		t.Errorf("expected cnt to be %d, got %d", 2*n, cnt)
	}
	
	cnt = 0
	exchange.RemoveBatch(filter2.Batch(), func(entity Entity){
		cnt++
	})
	if cnt != 2*n {
		t.Errorf("expected cnt to be %d, got %d", 2*n, cnt)
	}
	
	query = filter2.Query()
	cnt = 0
	for query.Next() {
		cnt++
	}
	if cnt != 0 {
		t.Errorf("expected cnt to be 0 after removal, got %d", cnt)
	}
}

func TestExchange{{.}}ExchangeBatch(t *testing.T) {
	n := 12
	w := NewWorld(8)

	exchange := NewExchange{{.}}{{$generics}}(&w).Removes(C[Position]())
	posMap := NewMap1[Position](&w)
	posVelMap := NewMap2[Position, Velocity](&w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position){
		pos.X = float64(cnt)
		cnt++
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity){
		pos.X = float64(cnt)
		cnt++
	})
	if cnt != 2*n+1 {
		t.Errorf("expected cnt to be %d, got %d", 2*n+1, cnt)
	}

	filter := NewFilter1[Position](&w)
	exchange.ExchangeBatch(filter.Batch(), {{$mapArgs}})

	filter2 := NewFilter1[CompA](&w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		if posMap.HasAll(query.Entity()) {
			t.Errorf("expected posMap.HasAll(entity) to be false")
		}
		cnt++
	}
	if cnt != 2*n {
		t.Errorf("expected cnt to be %d, got %d", 2*n, cnt)
	}
}

func TestExchange{{.}}ExchangeBatchFn(t *testing.T) {
	n := 12
	w := NewWorld(8)

	exchange := NewExchange{{.}}{{$generics}}(&w).Removes(C[Position]())
	posMap := NewMap1[Position](&w)
	posVelMap := NewMap2[Position, Velocity](&w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position) {
		pos.X = float64(cnt)
		cnt++
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity) {
		pos.X = float64(cnt)
		cnt++
	})
	if cnt != 2*n+1 {
		t.Errorf("expected cnt to be %d, got %d", 2*n+1, cnt)
	}

	filter := NewFilter1[Position](&w)
	cnt = 0
	exchange.ExchangeBatchFn(filter.Batch(), func(entity Entity, {{$args}}) {
		a.X = float64(cnt)
		cnt++
	})

	filter2 := NewFilter1[CompA](&w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		a := query.Get()
		if a.X != float64(cnt) {
			t.Errorf("expected a.X to be %f, got %f", float64(cnt), a.X)
		}
		if posMap.HasAll(query.Entity()) {
			t.Errorf("expected posMap.HasAll(entity) to be false")
		}
		cnt++
	}
	if cnt != 2*n {
		t.Errorf("expected cnt to be %d, got %d", 2*n, cnt)
	}
}

{{end -}}
{{end -}}