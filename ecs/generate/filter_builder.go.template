{{- define "template" -}}
package ecs

// Code generated by go generate; DO NOT EDIT.

{{range makeRange 0 8}}
{{- $upper := upperLetters . -}}
{{- $generics := "" -}}
{{- $genericsShort := "" -}}
{{- if .}}
{{- $generics = join "[" " any, " " any]" $upper -}}
{{- $genericsShort = join "[" ", " "]" $upper -}}
{{- end}}

// FilterBuilder{{.}} builds a [Filter{{.}}].
type FilterBuilder{{.}}{{$generics}} struct {
	world   *World
	ids     []ID
	mask    Mask
	without Mask
}

// NewFilter{{.}} creates a new [FilterBuilder{{.}}].
//
// Use [FilterBuilder{{.}}.Build] to obtain a [Filter{{.}}].
func NewFilter{{.}}{{$generics}}(world *World) *FilterBuilder{{.}}{{$genericsShort}} {
	ids := []ID{
		{{- range $i, $v := $upper}}
		ComponentID[{{$v}}](world),
		{{- end}}
	}

	return &FilterBuilder{{.}}{{$genericsShort}}{
		world: world,
		ids:   ids,
		mask:  All(ids...),
	}
}

// With specifies additional components to filter for.
func (q *FilterBuilder{{.}}{{$genericsShort}}) With(comps ...Comp) *FilterBuilder{{.}}{{$genericsShort}} {
	for _,c := range comps {
		id := q.world.componentID(c.tp)
		q.mask.Set(id, true)
	}
	return q
}

// With specifies components to exclude.
func (q *FilterBuilder{{.}}{{$genericsShort}}) Without(comps ...Comp) *FilterBuilder{{.}}{{$genericsShort}} {
	for _,c := range comps {
		id := q.world.componentID(c.tp)
		q.without.Set(id, true)
	}
	return q
}

// Build creates a [Filter{{.}}] from this builder.
func (q *FilterBuilder{{.}}{{$genericsShort}}) Build() *Filter{{.}}{{$genericsShort}} {
	return &Filter{{.}}{{$genericsShort}}{
		world:   q.world,
		ids:     q.ids,
		mask:    q.mask,
		without: q.without,
	}
}
{{end -}}
{{end -}}
