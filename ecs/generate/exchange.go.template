{{- define "template" -}}
package ecs

// Code generated by go generate; DO NOT EDIT.

import "unsafe"

{{range makeRange 1 8}}
{{- $n := . -}}
{{- $lower := lowerLetters . -}}
{{- $upper := upperLetters . -}}
{{- $generics := join "[" " any, " " any]" $upper -}}
{{- $genericsShort := join "[" ", " "]" $upper -}}
{{- $return := join "(*" ", *" ")" $upper -}}
{{- $args := arguments $lower $upper "" -}}
{{- $mask := join "id" ", id" "" $upper -}}

// Exchange{{.}} allows to exchange components of entities.
// It adds the given components. Use [Exchange{{.}}.Removes]
// to set components to be removed.
//
// Instances should be created during initialization and stored, e.g. in systems.
{{- if ne . 2 }}
//
// See [Exchange2] for a usage example.
{{- end}}
type Exchange{{.}}{{$generics}} struct {
	world     *World
	ids       []ID
	remove    []ID
	relations []RelationID
}

// NewExchange{{.}} creates an [Exchange{{.}}].
func NewExchange{{.}}{{$generics}}(world *World) *Exchange{{.}}{{$genericsShort}} {
	ids := []ID{
		{{- range $upper}}
		ComponentID[{{.}}](world),
		{{- end}}
	}
	return &Exchange{{.}}{{$genericsShort}}{
		world: world,
		ids:   ids,
	}
}

// Removes sets the components that this [Exchange{{.}}] removes.
// Can be called multiple times in chains, or once with multiple arguments.
func (ex *Exchange{{.}}{{$genericsShort}}) Removes(components ...Comp) *Exchange{{.}}{{$genericsShort}} {
	for _, c := range components {
		ex.remove = append(ex.remove, ex.world.componentID(c.tp))
	}
	return ex
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange{{.}}{{$genericsShort}}) Add(entity Entity, {{$args}}, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, ex.relations)
	ex.world.exchange(entity, ex.ids, nil, []unsafe.Pointer{
		{{- range $lower}}
		unsafe.Pointer({{.}}),
		{{- end}}
	}, ex.relations)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange{{.}}{{$genericsShort}}) AddFn(entity Entity, fn func({{$args}}), rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, ex.relations)
	ex.world.exchange(entity, ex.ids, nil, nil, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
}

// Remove the components previously specified with [Exchange{{.}}.Removes] from the given entity.
func (ex *Exchange{{.}}{{$genericsShort}}) Remove(entity Entity) {
	ex.world.exchange(entity, nil, ex.remove, nil, nil)
}

// Exchange performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange{{.}}.Removes].
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange{{.}}{{$genericsShort}}) Exchange(entity Entity, {{$args}}, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, ex.relations)
	ex.world.exchange(entity, ex.ids, ex.remove, []unsafe.Pointer{
		{{- range $lower}}
		unsafe.Pointer({{.}}),
		{{- end}}
	}, ex.relations)
}

// ExchangeFn performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange{{.}}.Removes].
// It runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange{{.}}{{$genericsShort}}) ExchangeFn(entity Entity, fn func({{$args}}), rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, ex.relations)
	ex.world.exchange(entity, ex.ids, ex.remove, nil, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange{{.}}{{$genericsShort}}) AddBatch(batch *Batch, {{$args}}, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, ex.relations)
	ex.world.exchangeBatch(batch, ex.ids, nil, []unsafe.Pointer{
		{{- range $lower}}
		unsafe.Pointer({{.}}),
		{{- end}}
	}, ex.relations, nil)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange{{.}}{{$genericsShort}}) AddBatchFn(batch *Batch, fn func(entity Entity, {{$args}}), rel ...Relation) {
	ex.exchangeBatchFn(batch, fn, false, rel...)
}

// RemoveBatch removes the components previously specified with [Exchange{{.}}.Removes]
// from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (ex *Exchange{{.}}{{$genericsShort}}) RemoveBatch(batch *Batch, fn func(entity Entity)) {
	removeBatch(ex.world, batch, ex.remove, fn)
}

// ExchangeBatch performs the exchange on all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange{{.}}{{$genericsShort}}) ExchangeBatch(batch *Batch, {{$args}}, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, ex.relations)
	ex.world.exchangeBatch(batch, ex.ids, ex.remove, []unsafe.Pointer{
		{{- range $lower}}
		unsafe.Pointer({{.}}),
		{{- end}}
	}, ex.relations, nil)
}

// ExchangeBatchFn performs the exchange on all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange{{.}}{{$genericsShort}}) ExchangeBatchFn(batch *Batch, fn func(entity Entity, {{$args}}), rel ...Relation) {
	ex.exchangeBatchFn(batch, fn, true, rel...)
}


func (ex *Exchange{{.}}{{$genericsShort}}) exchangeBatchFn(batch *Batch, fn func(entity Entity, {{$args}}), remove bool, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, ex.relations)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &ex.world.storage.tables[tableID]
			{{- range $i, $v := $upper}}
			column{{$v}} := table.GetColumn(ex.ids[{{$i}}])
			{{- end}}

			lock := ex.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					{{- range $upper}}
					(*{{.}})(column{{.}}.Get(index)),
					{{- end}}
				)
			}
			ex.world.unlock(lock)
		}
	}
	if remove {
		ex.world.exchangeBatch(batch, ex.ids, ex.remove, nil, ex.relations, process)
	} else {
		ex.world.exchangeBatch(batch, ex.ids, nil, nil, ex.relations, process)
	}
}

func (ex *Exchange{{.}}{{$genericsShort}}) runCallback(entity Entity, fn func({{$args}})) {
	index := &ex.world.storage.entities[entity.id]
	table := &ex.world.storage.tables[index.table]
	row := uintptr(index.row)
	fn(
		{{- range $i, $v := $upper}}
		(*{{$v}})(table.GetColumn(ex.ids[{{$i}}]).Get(row)),
		{{- end}}
	)
}

{{end -}}
{{end -}}
