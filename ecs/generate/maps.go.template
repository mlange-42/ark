{{- define "template" -}}
package ecs

// Code generated by go generate; DO NOT EDIT.

import "unsafe"

{{range makeRange 1 8}}
{{- $n := . -}}
{{- $lower := lowerLetters . -}}
{{- $upper := upperLetters . -}}
{{- $generics := join "[" " any, " " any]" $upper -}}
{{- $genericsShort := join "[" ", " "]" $upper -}}
{{- $return := join "(*" ", *" ")" $upper -}}
{{- $args := arguments $lower $upper -}}
{{- $mask := join "id" ", id" "" $upper -}}

// Map{{.}} is a mapper to access {{.}} components of an entity.
type Map{{.}}{{$generics}} struct {
	world    *World
	ids      []ID
	{{- range $upper}}
	storage{{.}} *componentStorage
	{{- end}}
	relations []relationID
}

// NewMap{{.}} creates a new [Map{{.}}].
func NewMap{{.}}{{$generics}}(world *World) Map{{.}}{{$genericsShort}} {
	ids := []ID{
		{{- range $upper}}
		ComponentID[{{.}}](world),
		{{- end}}
	}
	return Map{{.}}{{$genericsShort}}{
		world:    world,
		ids:      ids,
		{{- range $i, $v := $upper}}
		storage{{$v}}: &world.storage.components[ids[{{$i}}].id],
		{{- end}}
	}
}

// NewEntity creates a new entity with the mapped components.
func (m *Map{{.}}{{$genericsShort}}) NewEntity({{$args}}, rel ...RelationIndex) Entity {
	m.relations = relations(rel).toRelations(&m.world.storage.registry, m.ids, m.relations)
	return m.world.newEntityWith(m.ids, []unsafe.Pointer{
		{{- range $lower}}
		unsafe.Pointer({{.}}),
		{{- end}}
	}, m.relations)
}

// NewBatch creates a batch of new entities with the mapped components.
func (m *Map{{.}}{{$genericsShort}}) NewBatch(count int, {{$args}}, rel ...RelationIndex) {
	m.relations = relations(rel).toRelations(&m.world.storage.registry, m.ids, m.relations)
	m.world.newEntitiesWith(count, m.ids, []unsafe.Pointer{
		{{- range $lower}}
		unsafe.Pointer({{.}}),
		{{- end}}
	}, m.relations)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
func (m *Map{{.}}{{$genericsShort}}) NewBatchFn(count int, fn func(entity Entity, {{$args}}), rel ...RelationIndex) {
	m.relations = relations(rel).toRelations(&m.world.storage.registry, m.ids, m.relations)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)
	if fn == nil {
		return
	}

	table := &m.world.storage.tables[tableID]
	{{- range $upper}}
	column{{.}} := m.storage{{.}}.columns[tableID]
	{{- end}}

	for i := range count {
		index := uintptr(start + i)
		fn(
			table.GetEntity(index),
			{{- range $upper}}
			(*{{.}})(column{{.}}.Get(index)),
			{{- end}}
		)
	}
}

// Get returns the mapped components for the given entity.
func (m *Map{{.}}{{$genericsShort}}) Get(entity Entity) {{$return}} {
	if !m.world.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	return m.GetUnchecked(entity)
}

// GetUnchecked returns the mapped components for the given entity.
// It does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map{{.}}{{$genericsShort}}) GetUnchecked(entity Entity) {{$return}} {
	index := m.world.storage.entities[entity.id]
	row := uintptr(index.row)

	{{- range $upper}}
	checkMapHasComponent(m.storage{{.}}, index.table)
	{{- end}}

	return {{range $i, $v := $upper}}{{if $i}},
		{{end}}(*{{$v}})(m.storage{{$v}}.columns[index.table].Get(row)){{end}}
}

// HasAll return whether the given entity has all mapped components.
func (m *Map{{.}}{{$genericsShort}}) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	index := m.world.storage.entities[entity.id]
	return {{range $i, $v := $upper}}{{if $i}} &&
		{{end}}m.storage{{$v}}.columns[index.table] != nil{{end}}
}

// Add the mapped components to the given entity.
func (m *Map{{.}}{{$genericsShort}}) Add(entity Entity, {{$args}}, rel ...RelationIndex) {
	if !m.world.Alive(entity) {
		panic("can't add components to a dead entity")
	}
	m.relations = relations(rel).toRelations(&m.world.storage.registry, m.ids, m.relations)
	m.world.exchange(entity, m.ids, nil, []unsafe.Pointer{
		{{- range $lower}}
		unsafe.Pointer({{.}}),
		{{- end}}
	}, m.relations)
}

// Remove the mapped components from the given entity.
func (m *Map{{.}}{{$genericsShort}}) Remove(entity Entity) {
	if !m.world.Alive(entity) {
		panic("can't remove components from a dead entity")
	}
	m.world.exchange(entity, nil, m.ids, nil, nil)
}

// Remove the mapped components from the given entity.
func (m *Map{{.}}{{$genericsShort}}) SetRelations(entity Entity, rel ...RelationIndex) {
	if !m.world.Alive(entity) {
		panic("can't remove components from a dead entity")
	}
	m.relations = relations(rel).toRelations(&m.world.storage.registry, m.ids, m.relations)
	m.world.setRelations(entity, m.relations)
}
{{end -}}
{{end -}}
