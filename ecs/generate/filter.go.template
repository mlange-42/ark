{{- define "template" -}}
package ecs

// Code generated by go generate; DO NOT EDIT.

{{range makeRange 0 8}}
{{- $upper := upperLetters . -}}
{{- $generics := "" -}}
{{- $genericsShort := "" -}}
{{- if .}}
{{- $generics = join "[" " any, " " any]" $upper -}}
{{- $genericsShort = join "[" ", " "]" $upper -}}
{{- end}}

// Filter{{.}} is a filter for {{.}} components.
type Filter{{.}}{{$generics}} struct {
	world         *World
	ids           []ID
	filter        Filter
	relations     []RelationID
	tempRelations []RelationID
	cache         cacheID
}

// NewFilter{{.}} creates a new [Filter{{.}}].
//
// Use [Filter{{.}}.Query] to obtain a [Query{{.}}].
func NewFilter{{.}}{{$generics}}(world *World) *Filter{{.}}{{$genericsShort}} {
	ids := []ID{
		{{- range $i, $v := $upper}}
		ComponentID[{{$v}}](world),
		{{- end}}
	}

	return &Filter{{.}}{{$genericsShort}}{
		world:  world,
		ids:    ids,
		filter: NewFilter(ids...),
		cache:  maxCacheID,
	}
}

// With specifies additional components to filter for.
func (f *Filter{{.}}{{$genericsShort}}) With(comps ...Comp) *Filter{{.}}{{$genericsShort}} {
	f.checkCached()
	for _, c := range comps {
		id := f.world.componentID(c.tp)
		f.filter.mask.Set(id, true)
	}
	return f
}

// Without specifies components to exclude.
func (f *Filter{{.}}{{$genericsShort}}) Without(comps ...Comp) *Filter{{.}}{{$genericsShort}} {
	f.checkCached()
	for _,c := range comps {
		id := f.world.componentID(c.tp)
		f.filter.without.Set(id, true)
		f.filter.hasWithout = true
	}
	return f
}

// Exclusive makes the filter exclusive in the sense that the component composition is matched exactly,
// and no other components are allowed.
func (f *Filter{{.}}{{$genericsShort}}) Exclusive() *Filter{{.}}{{$genericsShort}} {
	f.checkCached()
	f.filter = f.filter.Exclusive()
	return f
}

{{if . -}}
// Relations sets permanent entity relation targets for this filter.
// Relation targets set here are included in filter caching.
// Contrary, relation targets specified in [Filter{{.}}.Query] or [Filter{{.}}.Batch] are not cached.
func (f *Filter{{.}}{{$genericsShort}}) Relations(rel ...Relation) *Filter{{.}}{{$genericsShort}} {
	f.checkCached()
	f.relations = relations(rel).toRelations(f.world, f.ids, nil, f.relations)
	return f
}
{{- end}}

// Register this filter to the world's filter cache.
func (f *Filter{{.}}{{$genericsShort}}) Register() *Filter{{.}}{{$genericsShort}} {
	if f.cache != maxCacheID {
		panic("filter is already registered, can't register")
	}
	f.cache = f.world.storage.registerFilter(f.Batch())
	return f
}

// Unregister this filter from the world's filter cache.
func (f *Filter{{.}}{{$genericsShort}}) Unregister() {
	if f.cache == maxCacheID {
		panic("filter is not registered, can't unregister")
	}
	f.world.storage.unregisterFilter(f.cache)
	f.cache = maxCacheID
}

// Query creates a [Query{{.}}] from this filter.
// This must be used each time before iterating a query.
//
// Relation targets provided here are added to those specified with [Filter{{.}}.Relations].
func (f *Filter{{.}}{{$genericsShort}}) Query(rel ...Relation) Query{{.}}{{$genericsShort}} {
	if f.cache == maxCacheID {
		f.tempRelations = relations(rel).toRelations(f.world, f.ids, f.relations, f.tempRelations)
	} else {
		f.tempRelations = relations(rel).toRelations(f.world, f.ids, nil, f.tempRelations)
	}
	return newQuery{{.}}{{$genericsShort}}(f.world, f.filter{{if .}}, f.ids{{end}}, f.tempRelations, f.cache)
}

// Batch creates a [Batch] from this filter.
//
// Relation targets provided here are added to those specified with [Filter{{.}}.Relations].
func (f *Filter{{.}}{{$genericsShort}}) Batch(rel ...Relation) *Batch {
	// TODO: use cache?
	f.tempRelations = relations(rel).toRelations(f.world, f.ids, f.relations, f.tempRelations)
	return &Batch {
		filter:    f.filter,
		relations: f.tempRelations,
	}
}

func (f *Filter{{.}}{{$genericsShort}}) checkCached() {
	if f.cache != maxCacheID {
		panic("can't modify a cached filter")
	}
}

{{end -}}
{{end -}}
