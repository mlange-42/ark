//go:build ark_debug

package ecs

// Code generated by go generate; DO NOT EDIT.

import "unsafe"

// Next advances the query's cursor to the next entity.
func (q *Query0) Next() bool {
	q.cursor.checkQueryNext()
	if int64(q.cursor.index) < q.cursor.maxIndex {
		q.cursor.index++
		return true
	}
	return q.nextTableOrArchetype()
}

// Entity returns the current entity.
func (q *Query0) Entity() Entity {
	q.cursor.checkQueryGet()
	return q.table.GetEntity(q.cursor.index)
}

// Next advances the query's cursor to the next entity.
func (q *Query1[A]) Next() bool {
	q.cursor.checkQueryNext()
	if int64(q.cursor.index) < q.cursor.maxIndex {
		q.cursor.index++
		return true
	}
	return q.nextTableOrArchetype()
}

// Entity returns the current entity.
func (q *Query1[A]) Entity() Entity {
	q.cursor.checkQueryGet()
	return q.table.GetEntity(q.cursor.index)
}

// Get returns the queried components of the current entity.
//
// ⚠️ Do not store the obtained pointers outside of the current context (i.e. the query loop)!
func (q *Query1[A]) Get() *A {
	q.cursor.checkQueryGet()
	index := q.cursor.index
	return (*A)(unsafe.Add(q.columnPtrA, index*q.itemSizeA))
}

// Next advances the query's cursor to the next entity.
func (q *Query2[A, B]) Next() bool {
	q.cursor.checkQueryNext()
	if int64(q.cursor.index) < q.cursor.maxIndex {
		q.cursor.index++
		return true
	}
	return q.nextTableOrArchetype()
}

// Entity returns the current entity.
func (q *Query2[A, B]) Entity() Entity {
	q.cursor.checkQueryGet()
	return q.table.GetEntity(q.cursor.index)
}

// Get returns the queried components of the current entity.
//
// ⚠️ Do not store the obtained pointers outside of the current context (i.e. the query loop)!
func (q *Query2[A, B]) Get() (*A, *B) {
	q.cursor.checkQueryGet()
	index := q.cursor.index
	return (*A)(unsafe.Add(q.columnPtrA, index*q.itemSizeA)),
		(*B)(unsafe.Add(q.columnPtrB, index*q.itemSizeB))
}

// Next advances the query's cursor to the next entity.
func (q *Query3[A, B, C]) Next() bool {
	q.cursor.checkQueryNext()
	if int64(q.cursor.index) < q.cursor.maxIndex {
		q.cursor.index++
		return true
	}
	return q.nextTableOrArchetype()
}

// Entity returns the current entity.
func (q *Query3[A, B, C]) Entity() Entity {
	q.cursor.checkQueryGet()
	return q.table.GetEntity(q.cursor.index)
}

// Get returns the queried components of the current entity.
//
// ⚠️ Do not store the obtained pointers outside of the current context (i.e. the query loop)!
func (q *Query3[A, B, C]) Get() (*A, *B, *C) {
	q.cursor.checkQueryGet()
	index := q.cursor.index
	return (*A)(unsafe.Add(q.columnPtrA, index*q.itemSizeA)),
		(*B)(unsafe.Add(q.columnPtrB, index*q.itemSizeB)),
		(*C)(unsafe.Add(q.columnPtrC, index*q.itemSizeC))
}

// Next advances the query's cursor to the next entity.
func (q *Query4[A, B, C, D]) Next() bool {
	q.cursor.checkQueryNext()
	if int64(q.cursor.index) < q.cursor.maxIndex {
		q.cursor.index++
		return true
	}
	return q.nextTableOrArchetype()
}

// Entity returns the current entity.
func (q *Query4[A, B, C, D]) Entity() Entity {
	q.cursor.checkQueryGet()
	return q.table.GetEntity(q.cursor.index)
}

// Get returns the queried components of the current entity.
//
// ⚠️ Do not store the obtained pointers outside of the current context (i.e. the query loop)!
func (q *Query4[A, B, C, D]) Get() (*A, *B, *C, *D) {
	q.cursor.checkQueryGet()
	index := q.cursor.index
	return (*A)(unsafe.Add(q.columnPtrA, index*q.itemSizeA)),
		(*B)(unsafe.Add(q.columnPtrB, index*q.itemSizeB)),
		(*C)(unsafe.Add(q.columnPtrC, index*q.itemSizeC)),
		(*D)(unsafe.Add(q.columnPtrD, index*q.itemSizeD))
}

// Next advances the query's cursor to the next entity.
func (q *Query5[A, B, C, D, E]) Next() bool {
	q.cursor.checkQueryNext()
	if int64(q.cursor.index) < q.cursor.maxIndex {
		q.cursor.index++
		return true
	}
	return q.nextTableOrArchetype()
}

// Entity returns the current entity.
func (q *Query5[A, B, C, D, E]) Entity() Entity {
	q.cursor.checkQueryGet()
	return q.table.GetEntity(q.cursor.index)
}

// Get returns the queried components of the current entity.
//
// ⚠️ Do not store the obtained pointers outside of the current context (i.e. the query loop)!
func (q *Query5[A, B, C, D, E]) Get() (*A, *B, *C, *D, *E) {
	q.cursor.checkQueryGet()
	index := q.cursor.index
	return (*A)(unsafe.Add(q.columnPtrA, index*q.itemSizeA)),
		(*B)(unsafe.Add(q.columnPtrB, index*q.itemSizeB)),
		(*C)(unsafe.Add(q.columnPtrC, index*q.itemSizeC)),
		(*D)(unsafe.Add(q.columnPtrD, index*q.itemSizeD)),
		(*E)(unsafe.Add(q.columnPtrE, index*q.itemSizeE))
}

// Next advances the query's cursor to the next entity.
func (q *Query6[A, B, C, D, E, F]) Next() bool {
	q.cursor.checkQueryNext()
	if int64(q.cursor.index) < q.cursor.maxIndex {
		q.cursor.index++
		return true
	}
	return q.nextTableOrArchetype()
}

// Entity returns the current entity.
func (q *Query6[A, B, C, D, E, F]) Entity() Entity {
	q.cursor.checkQueryGet()
	return q.table.GetEntity(q.cursor.index)
}

// Get returns the queried components of the current entity.
//
// ⚠️ Do not store the obtained pointers outside of the current context (i.e. the query loop)!
func (q *Query6[A, B, C, D, E, F]) Get() (*A, *B, *C, *D, *E, *F) {
	q.cursor.checkQueryGet()
	index := q.cursor.index
	return (*A)(unsafe.Add(q.columnPtrA, index*q.itemSizeA)),
		(*B)(unsafe.Add(q.columnPtrB, index*q.itemSizeB)),
		(*C)(unsafe.Add(q.columnPtrC, index*q.itemSizeC)),
		(*D)(unsafe.Add(q.columnPtrD, index*q.itemSizeD)),
		(*E)(unsafe.Add(q.columnPtrE, index*q.itemSizeE)),
		(*F)(unsafe.Add(q.columnPtrF, index*q.itemSizeF))
}

// Next advances the query's cursor to the next entity.
func (q *Query7[A, B, C, D, E, F, G]) Next() bool {
	q.cursor.checkQueryNext()
	if int64(q.cursor.index) < q.cursor.maxIndex {
		q.cursor.index++
		return true
	}
	return q.nextTableOrArchetype()
}

// Entity returns the current entity.
func (q *Query7[A, B, C, D, E, F, G]) Entity() Entity {
	q.cursor.checkQueryGet()
	return q.table.GetEntity(q.cursor.index)
}

// Get returns the queried components of the current entity.
//
// ⚠️ Do not store the obtained pointers outside of the current context (i.e. the query loop)!
func (q *Query7[A, B, C, D, E, F, G]) Get() (*A, *B, *C, *D, *E, *F, *G) {
	q.cursor.checkQueryGet()
	index := q.cursor.index
	return (*A)(unsafe.Add(q.columnPtrA, index*q.itemSizeA)),
		(*B)(unsafe.Add(q.columnPtrB, index*q.itemSizeB)),
		(*C)(unsafe.Add(q.columnPtrC, index*q.itemSizeC)),
		(*D)(unsafe.Add(q.columnPtrD, index*q.itemSizeD)),
		(*E)(unsafe.Add(q.columnPtrE, index*q.itemSizeE)),
		(*F)(unsafe.Add(q.columnPtrF, index*q.itemSizeF)),
		(*G)(unsafe.Add(q.columnPtrG, index*q.itemSizeG))
}

// Next advances the query's cursor to the next entity.
func (q *Query8[A, B, C, D, E, F, G, H]) Next() bool {
	q.cursor.checkQueryNext()
	if int64(q.cursor.index) < q.cursor.maxIndex {
		q.cursor.index++
		return true
	}
	return q.nextTableOrArchetype()
}

// Entity returns the current entity.
func (q *Query8[A, B, C, D, E, F, G, H]) Entity() Entity {
	q.cursor.checkQueryGet()
	return q.table.GetEntity(q.cursor.index)
}

// Get returns the queried components of the current entity.
//
// ⚠️ Do not store the obtained pointers outside of the current context (i.e. the query loop)!
func (q *Query8[A, B, C, D, E, F, G, H]) Get() (*A, *B, *C, *D, *E, *F, *G, *H) {
	q.cursor.checkQueryGet()
	index := q.cursor.index
	return (*A)(unsafe.Add(q.columnPtrA, index*q.itemSizeA)),
		(*B)(unsafe.Add(q.columnPtrB, index*q.itemSizeB)),
		(*C)(unsafe.Add(q.columnPtrC, index*q.itemSizeC)),
		(*D)(unsafe.Add(q.columnPtrD, index*q.itemSizeD)),
		(*E)(unsafe.Add(q.columnPtrE, index*q.itemSizeE)),
		(*F)(unsafe.Add(q.columnPtrF, index*q.itemSizeF)),
		(*G)(unsafe.Add(q.columnPtrG, index*q.itemSizeG)),
		(*H)(unsafe.Add(q.columnPtrH, index*q.itemSizeH))
}
