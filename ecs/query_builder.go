package ecs

// Code generated by go generate; DO NOT EDIT.

// QueryBuilder0 builds a [Query0].
type QueryBuilder0 struct {
	world *World
	mask  Mask
	ids   []ID
}

// NewQuery0 creates a new [QueryBuilder0].
//
// Use [QueryBuilder0.Build] to obtain a [Query0].
func NewQuery0(world *World) *QueryBuilder0 {
	ids := []ID{}

	return &QueryBuilder0{
		world: world,
		mask:  All(ids[:]...),
		ids:   ids,
	}
}

// Build creates a [Query0] from this builder.
func (q *QueryBuilder0) Build() Query0 {
	components := make([]*componentStorage, 0)

	return Query0{
		world:      q.world,
		mask:       q.mask,
		components: components,
		cursor: cursor{
			table:    -1,
			index:    0,
			maxIndex: -1,
		},
	}
}

// QueryBuilder1 builds a [Query1].
type QueryBuilder1[A any] struct {
	world *World
	mask  Mask
	ids   []ID
}

// NewQuery1 creates a new [QueryBuilder1].
//
// Use [QueryBuilder1.Build] to obtain a [Query1].
func NewQuery1[A any](world *World) *QueryBuilder1[A] {
	ids := []ID{
		ComponentID[A](world),
	}

	return &QueryBuilder1[A]{
		world: world,
		mask:  All(ids[:]...),
		ids:   ids,
	}
}

// Build creates a [Query1] from this builder.
func (q *QueryBuilder1[A]) Build() Query1[A] {
	components := make([]*componentStorage, 1)
	for i := range 1 {
		components[i] = &q.world.storage.components[q.ids[i].id]
	}

	return Query1[A]{
		world:      q.world,
		mask:       q.mask,
		components: components,
		cursor: cursor{
			table:    -1,
			index:    0,
			maxIndex: -1,
		},
	}
}

// QueryBuilder2 builds a [Query2].
type QueryBuilder2[A any, B any] struct {
	world *World
	mask  Mask
	ids   []ID
}

// NewQuery2 creates a new [QueryBuilder2].
//
// Use [QueryBuilder2.Build] to obtain a [Query2].
func NewQuery2[A any, B any](world *World) *QueryBuilder2[A, B] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
	}

	return &QueryBuilder2[A, B]{
		world: world,
		mask:  All(ids[:]...),
		ids:   ids,
	}
}

// Build creates a [Query2] from this builder.
func (q *QueryBuilder2[A, B]) Build() Query2[A, B] {
	components := make([]*componentStorage, 2)
	for i := range 2 {
		components[i] = &q.world.storage.components[q.ids[i].id]
	}

	return Query2[A, B]{
		world:      q.world,
		mask:       q.mask,
		components: components,
		cursor: cursor{
			table:    -1,
			index:    0,
			maxIndex: -1,
		},
	}
}

// QueryBuilder3 builds a [Query3].
type QueryBuilder3[A any, B any, C any] struct {
	world *World
	mask  Mask
	ids   []ID
}

// NewQuery3 creates a new [QueryBuilder3].
//
// Use [QueryBuilder3.Build] to obtain a [Query3].
func NewQuery3[A any, B any, C any](world *World) *QueryBuilder3[A, B, C] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
	}

	return &QueryBuilder3[A, B, C]{
		world: world,
		mask:  All(ids[:]...),
		ids:   ids,
	}
}

// Build creates a [Query3] from this builder.
func (q *QueryBuilder3[A, B, C]) Build() Query3[A, B, C] {
	components := make([]*componentStorage, 3)
	for i := range 3 {
		components[i] = &q.world.storage.components[q.ids[i].id]
	}

	return Query3[A, B, C]{
		world:      q.world,
		mask:       q.mask,
		components: components,
		cursor: cursor{
			table:    -1,
			index:    0,
			maxIndex: -1,
		},
	}
}

// QueryBuilder4 builds a [Query4].
type QueryBuilder4[A any, B any, C any, D any] struct {
	world *World
	mask  Mask
	ids   []ID
}

// NewQuery4 creates a new [QueryBuilder4].
//
// Use [QueryBuilder4.Build] to obtain a [Query4].
func NewQuery4[A any, B any, C any, D any](world *World) *QueryBuilder4[A, B, C, D] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
	}

	return &QueryBuilder4[A, B, C, D]{
		world: world,
		mask:  All(ids[:]...),
		ids:   ids,
	}
}

// Build creates a [Query4] from this builder.
func (q *QueryBuilder4[A, B, C, D]) Build() Query4[A, B, C, D] {
	components := make([]*componentStorage, 4)
	for i := range 4 {
		components[i] = &q.world.storage.components[q.ids[i].id]
	}

	return Query4[A, B, C, D]{
		world:      q.world,
		mask:       q.mask,
		components: components,
		cursor: cursor{
			table:    -1,
			index:    0,
			maxIndex: -1,
		},
	}
}

// QueryBuilder5 builds a [Query5].
type QueryBuilder5[A any, B any, C any, D any, E any] struct {
	world *World
	mask  Mask
	ids   []ID
}

// NewQuery5 creates a new [QueryBuilder5].
//
// Use [QueryBuilder5.Build] to obtain a [Query5].
func NewQuery5[A any, B any, C any, D any, E any](world *World) *QueryBuilder5[A, B, C, D, E] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
	}

	return &QueryBuilder5[A, B, C, D, E]{
		world: world,
		mask:  All(ids[:]...),
		ids:   ids,
	}
}

// Build creates a [Query5] from this builder.
func (q *QueryBuilder5[A, B, C, D, E]) Build() Query5[A, B, C, D, E] {
	components := make([]*componentStorage, 5)
	for i := range 5 {
		components[i] = &q.world.storage.components[q.ids[i].id]
	}

	return Query5[A, B, C, D, E]{
		world:      q.world,
		mask:       q.mask,
		components: components,
		cursor: cursor{
			table:    -1,
			index:    0,
			maxIndex: -1,
		},
	}
}

// QueryBuilder6 builds a [Query6].
type QueryBuilder6[A any, B any, C any, D any, E any, F any] struct {
	world *World
	mask  Mask
	ids   []ID
}

// NewQuery6 creates a new [QueryBuilder6].
//
// Use [QueryBuilder6.Build] to obtain a [Query6].
func NewQuery6[A any, B any, C any, D any, E any, F any](world *World) *QueryBuilder6[A, B, C, D, E, F] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
		ComponentID[F](world),
	}

	return &QueryBuilder6[A, B, C, D, E, F]{
		world: world,
		mask:  All(ids[:]...),
		ids:   ids,
	}
}

// Build creates a [Query6] from this builder.
func (q *QueryBuilder6[A, B, C, D, E, F]) Build() Query6[A, B, C, D, E, F] {
	components := make([]*componentStorage, 6)
	for i := range 6 {
		components[i] = &q.world.storage.components[q.ids[i].id]
	}

	return Query6[A, B, C, D, E, F]{
		world:      q.world,
		mask:       q.mask,
		components: components,
		cursor: cursor{
			table:    -1,
			index:    0,
			maxIndex: -1,
		},
	}
}

// QueryBuilder7 builds a [Query7].
type QueryBuilder7[A any, B any, C any, D any, E any, F any, G any] struct {
	world *World
	mask  Mask
	ids   []ID
}

// NewQuery7 creates a new [QueryBuilder7].
//
// Use [QueryBuilder7.Build] to obtain a [Query7].
func NewQuery7[A any, B any, C any, D any, E any, F any, G any](world *World) *QueryBuilder7[A, B, C, D, E, F, G] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
		ComponentID[F](world),
		ComponentID[G](world),
	}

	return &QueryBuilder7[A, B, C, D, E, F, G]{
		world: world,
		mask:  All(ids[:]...),
		ids:   ids,
	}
}

// Build creates a [Query7] from this builder.
func (q *QueryBuilder7[A, B, C, D, E, F, G]) Build() Query7[A, B, C, D, E, F, G] {
	components := make([]*componentStorage, 7)
	for i := range 7 {
		components[i] = &q.world.storage.components[q.ids[i].id]
	}

	return Query7[A, B, C, D, E, F, G]{
		world:      q.world,
		mask:       q.mask,
		components: components,
		cursor: cursor{
			table:    -1,
			index:    0,
			maxIndex: -1,
		},
	}
}

// QueryBuilder8 builds a [Query8].
type QueryBuilder8[A any, B any, C any, D any, E any, F any, G any, H any] struct {
	world *World
	mask  Mask
	ids   []ID
}

// NewQuery8 creates a new [QueryBuilder8].
//
// Use [QueryBuilder8.Build] to obtain a [Query8].
func NewQuery8[A any, B any, C any, D any, E any, F any, G any, H any](world *World) *QueryBuilder8[A, B, C, D, E, F, G, H] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
		ComponentID[F](world),
		ComponentID[G](world),
		ComponentID[H](world),
	}

	return &QueryBuilder8[A, B, C, D, E, F, G, H]{
		world: world,
		mask:  All(ids[:]...),
		ids:   ids,
	}
}

// Build creates a [Query8] from this builder.
func (q *QueryBuilder8[A, B, C, D, E, F, G, H]) Build() Query8[A, B, C, D, E, F, G, H] {
	components := make([]*componentStorage, 8)
	for i := range 8 {
		components[i] = &q.world.storage.components[q.ids[i].id]
	}

	return Query8[A, B, C, D, E, F, G, H]{
		world:      q.world,
		mask:       q.mask,
		components: components,
		cursor: cursor{
			table:    -1,
			index:    0,
			maxIndex: -1,
		},
	}
}
