{{- define "template" -}}
package ecs

// Code generated by go generate; DO NOT EDIT.

{{range makeRange 1 12}}
{{- $n := . -}}
{{- $lower := lowerLetters . -}}
{{- $upper := upperLetters . -}}
{{- $generics := join "[" " any, " " any]" $upper -}}
{{- $genericsShort := join "[" ", " "]" $upper -}}
{{- $return := join "" ", " "" $lower -}}
{{- $returnTypes := join "(*" ", *" ")" $upper -}}
{{- $fn_args := join "*" ", *" "" $upper -}}
{{- $args := arguments $lower $upper "" "" -}}
{{- $args2 := arguments $lower $upper "p" "" -}}
{{- $mask := join "id" ", id" "" $upper -}}

// Map{{.}} is a mapper to access {{.}} components of an entity.
//
// Instances should be created during initialization and stored, e.g. in systems.
{{- if ne . 2 }}
//
// See [Map2] for a usage example.
{{- end}}
type Map{{.}}{{$generics}} struct {
	mask      bitMask
	ids       []ID
	relations []relationID
	world     *World
	{{- range $upper}}
	storage{{.}}  *componentStorage
	{{- end}}
}

// New creates a new [Map{{.}}]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
{{- if ne . 2 }}
//
// See [Map2.New] for an example.
{{- end}}
func (*Map{{.}}{{$genericsShort}}) New(world *World) *Map{{.}}{{$genericsShort}} {
    return NewMap{{.}}{{$genericsShort}}(world)
}

// NewMap{{.}} creates a new [Map{{.}}].
//
// See also [Map{{.}}.New] for a shortcut when constructing an already defined instance.
func NewMap{{.}}{{$generics}}(world *World) *Map{{.}}{{$genericsShort}} {
	ids := []ID{
		{{- range $upper}}
		ComponentID[{{.}}](world),
		{{- end}}
	}
	return &Map{{.}}{{$genericsShort}}{
		world:    world,
		ids:      ids,
		mask:     newMask(ids...),
		{{- range $i, $v := $upper}}
		storage{{$v}}: &world.storage.components[ids[{{$i}}].id],
		{{- end}}
	}
}

// NewEntity creates a new entity with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (m *Map{{.}}{{$genericsShort}}) NewEntity({{$args}}, rel ...Relation) Entity {
	return m.NewEntityFn(func({{$args2}}) {
		{{- range $lower}}
		*p{{.}} = *{{.}}
		{{- end}}
	}, rel...)
}

// NewEntityFn creates a new entity with the mapped component and runs a callback instead of using a component for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map{{.}}{{$genericsShort}}) NewEntityFn(fn func({{$fn_args}}), rel ...Relation) Entity {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	entity, mask := m.world.newEntity(m.ids, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			{{- range $upper}}
			(*{{.}})(m.storage{{.}}.columns[index.table].Get(row)),
			{{- end}}
		)
	}
	m.world.storage.observers.FireCreateEntityIfHas(entity, mask)
	if len(rel) > 0 {
		m.world.storage.observers.FireCreateEntityRelIfHas(entity, mask)
	}
	return entity
}

// NewBatch creates a batch of new entities with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (m *Map{{.}}{{$genericsShort}}) NewBatch(count int, {{$args}}, rel ...Relation) {
	m.NewBatchFn(count, func(_ Entity, {{$args2}}) {
		{{- range $lower}}
		*p{{.}} = *{{.}}
		{{- end}}
	}, rel...)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map{{.}}{{$genericsShort}}) NewBatchFn(count int, fn func(Entity, {{$fn_args}}), rel ...Relation) {
	m.world.checkLocked()
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)

	hasCreateObs := m.world.storage.observers.HasObservers(OnCreateEntity)
	hasRelObs := len(rel) > 0 && m.world.storage.observers.HasObservers(OnAddRelations)
	shouldLock := hasCreateObs || hasRelObs || fn != nil
	var lock uint8
	if shouldLock {
		lock = m.world.lock()
	}

	if fn != nil {
		table := &m.world.storage.tables[tableID]
		{{- range $upper}}
		column{{.}} := m.storage{{.}}.columns[tableID]
		{{- end}}
		for i := range count {
			index := uintptr(start + i)
			fn(
				table.GetEntity(index),
				{{- range $upper}}
				(*{{.}})(column{{.}}.Get(index)),
				{{- end}}
			)
		}
	}
	
	if hasCreateObs {
		table := &m.world.storage.tables[tableID]
		earlyOut := true
		for i := range count {
			index := uintptr(start + i)
			if !m.world.storage.observers.FireCreateEntity(table.GetEntity(index), &m.mask, earlyOut) {
				break
			}
			earlyOut = false
		}
	}
	if hasRelObs {
		table := &m.world.storage.tables[tableID]
		earlyOut := true
		for i := range count {
			index := uintptr(start + i)
			if !m.world.storage.observers.FireCreateEntityRel(table.GetEntity(index), &m.mask, earlyOut) {
				break
			}
			earlyOut = false
		}
	}
	
	if shouldLock {
		m.world.unlock(lock)
	}
}

// Get returns the mapped components for the given entity.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map{{.}}{{$genericsShort}}) Get(entity Entity) {{$returnTypes}} {
	if !m.world.storage.entityPool.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	index := &m.world.storage.entities[entity.id]
	return {{range $i, $v := $upper}}{{if $i}}, {{end}}get[{{$v}}](m.storage{{$v}}, index)
	{{- end}}
}

// GetUnchecked returns the mapped components for the given entity.
// In contrast to [Map{{.}}.Get], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map{{.}}{{$genericsShort}}) GetUnchecked(entity Entity) {{$returnTypes}} {
	index := &m.world.storage.entities[entity.id]
	return {{range $i, $v := $upper}}{{if $i}}, {{end}}get[{{$v}}](m.storage{{$v}}, index)
	{{- end}}
}

// HasAll return whether the given entity has all mapped components.
//
// Using [Map{{.}}.Get] and checking for nil pointer may be faster
// than calling [Map{{.}}.HasAll] and [Map{{.}}.Get] subsequently.
func (m *Map{{.}}{{$genericsShort}}) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	table := m.world.storage.entities[entity.id].table
	return {{range $i, $v := $upper}}{{if $i}} &&
		{{end}}m.storage{{$v}}.columns[table] != nil{{end}}
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map{{.}}{{$genericsShort}}) Add(entity Entity, {{$args}}, rel ...Relation) {
	m.AddFn(entity, func({{$args2}}) {
		{{- range $lower}}
		*p{{.}} = *{{.}}
		{{- end}}
	}, rel...)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map{{.}}{{$genericsShort}}) AddFn(entity Entity, fn func({{$fn_args}}), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	oldMask, newMask := m.world.add(entity, m.ids, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			{{- range $upper}}
			(*{{.}})(m.storage{{.}}.columns[index.table].Get(row)),
			{{- end}}
		)
	}
	m.world.storage.observers.FireAddIfHas(OnAddComponents, entity, oldMask, newMask)
	if len(rel) > 0 {
		m.world.storage.observers.FireAddIfHas(OnAddRelations, entity, oldMask, newMask)
	}
}

// Set the mapped components of the given entity to the given values.
// Requires the entity to already have all the mapped components.
//
// Triggers an OnSetComponents event, which is not the case when assigning by
// pointer dereference or assigning to fields. This can be used to notify observers
// about component updates.
//
// This is not a component operation, so it can be performed on a locked world.
func (m *Map{{.}}{{$genericsShort}}) Set(entity Entity, {{$args}}) {
	if !m.world.Alive(entity) {
		panic("can't set components of a dead entity")
	}
	{{- range $n}}
	m.world.storage.checkHasComponent(entity, m.ids[{{.}}])
	{{- end}}

	index := &m.world.storage.entities[entity.id]
	{{- range $i, $v := $upper}}
	set(m.storage{{$v}}, index, {{index $lower $i}})
	{{- end}}
	
	if m.world.storage.observers.HasObservers(OnSetComponents) {
		newMask := &m.world.storage.archetypes[m.world.storage.tables[index.table].archetype].mask
		m.world.storage.observers.FireSet(entity, &m.mask, newMask)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map{{.}}{{$genericsShort}}) AddBatch(batch Batch, {{$args}}, rel ...Relation) {
	m.AddBatchFn(batch, func(_ Entity, {{$args2}}) {
		{{- range $lower}}
		*p{{.}} = *{{.}}
		{{- end}}
	}, rel...)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map{{.}}{{$genericsShort}}) AddBatchFn(batch Batch, fn func(Entity, {{$fn_args}}), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)

	var process func(tableID tableID, start, len uint32)
	if fn != nil {
		process = func(tableID tableID, start, len uint32) {
			table := &m.world.storage.tables[tableID]
			{{- range $upper}}
			column{{.}} := m.storage{{.}}.columns[tableID]
			{{- end}}

			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					{{- range $upper}}
					(*{{.}})(column{{.}}.Get(index)),
					{{- end}}
				)
			}
		}
	}
	m.world.exchangeBatch(&batch, m.ids, nil, m.relations, process)
}

// Remove the mapped components from the given entity.
func (m *Map{{.}}{{$genericsShort}}) Remove(entity Entity) {
	m.world.remove(entity, m.ids)
}

// RemoveBatch removes the mapped components from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map{{.}}{{$genericsShort}}) RemoveBatch(batch Batch, fn func(entity Entity)) {
	removeBatch(m.world, &batch, m.ids, fn)
}

// GetRelation returns the relation target of an entity for the component at the given index.
func (m *Map{{.}}{{$genericsShort}}) GetRelation(entity Entity, index int) Entity {
	if !m.world.storage.entityPool.Alive(entity) {
		panic("can't get entity relation target for a dead entity")
	}
	return m.GetRelationUnchecked(entity, index)
}

// GetRelationUnchecked returns the relation target of an entity for the component at the given index.
// In contrast to [Map{{.}}.GetRelation], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map{{.}}{{$genericsShort}}) GetRelationUnchecked(entity Entity, index int) Entity {
	return m.world.storage.getRelation(entity, m.ids[index])
}

// SetRelations sets relation targets for the given entity.
func (m *Map{{.}}{{$genericsShort}}) SetRelations(entity Entity, rel ...Relation) {
	// alive check is done in World.setRelations
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	m.world.setRelations(entity, m.relations)
}

// SetRelationsBatch sets relation targets for all entities matching the given batch filter.
func (m *Map{{.}}{{$genericsShort}}) SetRelationsBatch(batch Batch, fn func(entity Entity), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	setRelationsBatch(m.world, &batch, fn, m.relations)
}

{{end -}}
{{end -}}
