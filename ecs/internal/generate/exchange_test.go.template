{{- define "template" -}}
package ecs

// Code generated by go generate; DO NOT EDIT.

import "testing"

{{range makeRange 1 8}}
{{- $n := . -}}
{{- $upper := upperLetters . -}}
{{- $lower := lowerLetters . -}}

{{- $generics := join "[Comp" ", Comp" "]" $upper -}}
{{- $args := arguments $lower $upper "" "Comp" -}}
{{- $mapArgs := join "&Comp" "{}, &Comp" "{}" $upper -}}
{{- $comps := join "" ", " "" $lower -}}

{{- $genericsRel := replace $generics "CompA" "ChildOf" -}}
{{- $mapArgsRel := replace $mapArgs "CompA" "ChildOf" -}}

func TestExchange{{.}}(t *testing.T) {
	w := NewWorld(16)

	posMap := NewMap2[Position, Velocity](&w)
	mapper := NewMap{{.}}{{$generics}}(&w)

	var ex *Exchange{{.}}{{$generics}}
	ex = ex.New(&w).Removes(C[Velocity](), C[Position]())

	e := posMap.NewEntity(&Position{}, &Velocity{})

	ex.Exchange(e, {{$mapArgs}})
	expectFalse(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))
	
	e = posMap.NewEntity(&Position{}, &Velocity{})
	ex.ExchangeFn(e, func({{$args}}){
		a.X = 100
	})
	expectFalse(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))
}

func TestExchange{{.}}Add(t *testing.T) {
	w := NewWorld(16)

	posMap := NewMap2[Position, Velocity](&w)
	mapper := NewMap{{.}}{{$generics}}(&w)
	ex := NewExchange{{.}}{{$generics}}(&w).Removes(C[Velocity](), C[Position]())

	e := posMap.NewEntity(&Position{}, &Velocity{})

	ex.Add(e, {{$mapArgs}})
	expectTrue(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))
	
	e = posMap.NewEntity(&Position{}, &Velocity{})
	
	ex.AddFn(e, func({{$args}}){
		a.X = 100
	})
	expectTrue(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))
}

func TestExchange{{.}}Relations(t *testing.T) {
	w := NewWorld(8)
	
	Observe(OnAddRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(&w)
	Observe(OnRemoveRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(&w)

	ex := NewExchange{{.}}{{$genericsRel}}(&w).Removes(C[Position]())
	mapper1 := NewMap1[ChildOf](&w)
	mapper2 := NewMap1[Position](&w)
	
	parent1 := w.NewEntity()
	
	e1 := w.NewEntity()
	ex.Add(e1, {{$mapArgsRel}}, RelIdx(0, parent1))
	expectEqual(t, parent1, mapper1.GetRelation(e1, 0))
	expectEqual(t, parent1, mapper1.GetRelationUnchecked(e1, 0))

	e2 := mapper2.NewEntity(&Position{})
	ex.Exchange(e2, {{$mapArgsRel}}, RelIdx(0, parent1))
	expectEqual(t, parent1, mapper1.GetRelation(e2, 0))
	expectEqual(t, parent1, mapper1.GetRelationUnchecked(e2, 0))
}

func TestExchange{{.}}Remove(t *testing.T) {
	w := NewWorld(16)

	posMap := NewMap2[Position, Velocity](&w)
	mapper := NewMap{{.}}{{$generics}}(&w)
	ex := NewExchange{{.}}{{$generics}}(&w).Removes(C[Velocity](), C[Position]())

	e := posMap.NewEntity(&Position{}, &Velocity{})

	ex.Remove(e)
	expectFalse(t, posMap.HasAll(e))
	expectFalse(t, mapper.HasAll(e))
}

func TestExchange{{.}}AddBatch(t *testing.T) {
	n := 12
	w := NewWorld(8)
	
	Observe(OnAddComponents).For(C[Heading]()).Do(func(e Entity) {}).Register(&w)
	Observe(OnRemoveComponents).For(C[Heading]()).Do(func(e Entity) {}).Register(&w)
	Observe(OnAddRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(&w)
	Observe(OnRemoveRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(&w)

	exchange := NewExchange{{.}}{{$generics}}(&w).Removes(C[CompA]())
	posMap := NewMap1[Position](&w)
	posVelMap := NewMap2[Position, Velocity](&w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position){
		pos.X = float64(cnt)
		cnt++
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity){
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](&w)
	exchange.AddBatch(filter.Batch(), {{$mapArgs}})

	filter2 := NewFilter1[CompA](&w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		pos := posMap.Get(query.Entity())
		expectGreater(t, pos.X, 0.0)
		cnt++
	}
	expectEqual(t, 2*n, cnt)

	exchange.RemoveBatch(filter2.Batch(), nil)
	
	query = filter2.Query()
	cnt = 0
	for query.Next() {
		cnt++
	}
	expectEqual(t, 0, cnt)
}

func TestExchange{{.}}AddBatchFn(t *testing.T) {
	n := 12
	w := NewWorld(8)

	exchange := NewExchange{{.}}{{$generics}}(&w).Removes(C[CompA]())
	posMap := NewMap1[Position](&w)
	posVelMap := NewMap2[Position, Velocity](&w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position){
		pos.X = float64(cnt)
		cnt++
		expectTrue(t, w.IsLocked())
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity){
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](&w)
	cnt = 0
	exchange.AddBatchFn(filter.Batch(), func(entity Entity, {{$args}}){
		a.X = float64(cnt)
		cnt++
		expectTrue(t, w.IsLocked())
	})

	filter2 := NewFilter1[CompA](&w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		a := query.Get()
		expectEqual(t, float64(cnt), a.X)
		pos := posMap.Get(query.Entity())
		expectGreater(t, pos.X, 0.0)
		cnt++
	}
	expectEqual(t, 2*n, cnt)
	
	cnt = 0
	exchange.RemoveBatch(filter2.Batch(), func(entity Entity){
		cnt++
	})
	expectEqual(t, 2*n, cnt)
	
	query = filter2.Query()
	cnt = 0
	for query.Next() {
		cnt++
	}
	expectEqual(t, 0, cnt)
}

func TestExchange{{.}}ExchangeBatch(t *testing.T) {
	n := 12
	w := NewWorld(8)

	exchange := NewExchange{{.}}{{$generics}}(&w).Removes(C[Position]())
	posMap := NewMap1[Position](&w)
	posVelMap := NewMap2[Position, Velocity](&w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position){
		pos.X = float64(cnt)
		cnt++
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity){
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](&w)
	exchange.ExchangeBatch(filter.Batch(), {{$mapArgs}})

	filter2 := NewFilter1[CompA](&w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		expectFalse(t, posMap.HasAll(query.Entity()))
		cnt++
	}
	expectEqual(t, 2*n, cnt)
}

func TestExchange{{.}}ExchangeBatchFn(t *testing.T) {
	n := 12
	w := NewWorld(8)

	exchange := NewExchange{{.}}{{$generics}}(&w).Removes(C[Position]())
	posMap := NewMap1[Position](&w)
	posVelMap := NewMap2[Position, Velocity](&w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position){
		pos.X = float64(cnt)
		cnt++
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity){
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](&w)
	cnt = 0
	exchange.ExchangeBatchFn(filter.Batch(), func(entity Entity, {{$args}}){
		a.X = float64(cnt)
		cnt++
		expectTrue(t, w.IsLocked())
	})

	filter2 := NewFilter1[CompA](&w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		a := query.Get()
		expectEqual(t, float64(cnt), a.X)
		expectFalse(t, posMap.HasAll(query.Entity()))
		cnt++
	}
	expectEqual(t, 2*n, cnt)
}

{{end -}}
{{end -}}
