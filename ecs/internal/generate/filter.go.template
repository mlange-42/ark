{{- define "template" -}}
package ecs

// Code generated by go generate; DO NOT EDIT.

{{range makeRange 0 8}}
{{- $upper := upperLetters . -}}
{{- $generics := "" -}}
{{- $genericsShort := "" -}}
{{- if .}}
{{- $generics = join "[" " any, " " any]" $upper -}}
{{- $genericsShort = join "[" ", " "]" $upper -}}
{{- end}}

// Filter{{.}} is a filter for {{.}} components.
// Used to create [Query{{.}}] iterators.
//
// Instances should be created during initialization and stored, e.g. in systems.
{{- if ne . 2 }}
//
// See [Filter2] for a usage example.
{{- end}}
type Filter{{.}}{{$generics}} struct {
	world         *World
	ids           []ID
	relations     []relationID
	components    []*componentStorage
	filter        filter
	generation    uint32
	rareComp      uint8
	numRelations  uint8
}

// New creates a new [Filter{{.}}]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
{{- if ne . 2 }}
//
// See [Filter2.New] for an example.
{{- end}}
func (*Filter{{.}}{{$genericsShort}}) New(world *World) *Filter{{.}}{{$genericsShort}} {
    return NewFilter{{.}}{{$genericsShort}}(world)
}

// NewFilter{{.}} creates a new [Filter{{.}}].
//
// Use [Filter{{.}}.Query] to obtain a [Query{{.}}].
//
// See also [Filter{{.}}.New] for a shortcut when constructing an already defined instance.
func NewFilter{{.}}{{$generics}}(world *World) *Filter{{.}}{{$genericsShort}} {
	ids := []ID{
		{{- range $i, $v := $upper}}
		ComponentID[{{$v}}](world),
		{{- end}}
	}
	components := make([]*componentStorage, {{.}})
	{{range $i, $v := $upper -}}
	components[{{$i}}] = &world.storage.components[ids[{{$i}}].id]
	{{end -}}

	return &Filter{{.}}{{$genericsShort}}{
		world:      world,
		ids:        ids,
		filter:     newFilter(ids...),
		components: components,
	}
}

// With specifies additional components to filter for.
// Can be called multiple times in chains, or once with multiple arguments.
func (f *Filter{{.}}{{$genericsShort}}) With(comps ...Comp) *Filter{{.}}{{$genericsShort}} {
	f.checkModify()
	for _, c := range comps {
		id := f.world.componentID(c.tp)
		f.ids = append(f.ids, id)
		f.filter.mask.Set(id.id)
	}
	return f
}

// Without specifies components to exclude.
// Can be called multiple times in chains, or once with multiple arguments.
func (f *Filter{{.}}{{$genericsShort}}) Without(comps ...Comp) *Filter{{.}}{{$genericsShort}} {
	f.checkModify()
	if len(comps) == 0 {
		return f
	}
	for _,c := range comps {
		id := f.world.componentID(c.tp)
		f.filter.without.Set(id.id)
		f.filter.hasWithout = true
	}
	return f
}

// Exclusive makes the filter exclusive in the sense that the component composition is matched exactly,
// and no other components are allowed. This includes components set via [Filter{{.}}.With].
// 
// Overwrites components set via [Filter{{.}}.Without].
func (f *Filter{{.}}{{$genericsShort}}) Exclusive() *Filter{{.}}{{$genericsShort}} {
	f.checkModify()
	f.filter = f.filter.Exclusive()
	return f
}

// Relations sets permanent entity relation targets for this filter.
// Relation targets set here are included in filter caching.
// Contrary, relation targets specified in [Filter{{.}}.Query] or [Filter{{.}}.Batch] are not cached.
//
// Relation components used here must be in the filter's parameters
// or added via [Filter{{.}}.With] beforehand.
//
// Can be called multiple times in chains, or once with multiple arguments.
func (f *Filter{{.}}{{$genericsShort}}) Relations(rel ...Relation) *Filter{{.}}{{$genericsShort}} {
	f.checkModify()
	f.relations = relationSlice(rel).ToRelations(f.world, &f.filter.mask, f.ids, f.relations[:f.numRelations], nil)
	f.numRelations = uint8(len(f.relations))
	return f
}

// Register this filter to the world's filter cache.
//
// Registering filters is optional.
// It avoids a potential slowdown that may be caused by a very high number of archetypes, like hundreds or thousands.
func (f *Filter{{.}}{{$genericsShort}}) Register() *Filter{{.}}{{$genericsShort}} {
	if f.filter.cache != maxCacheID {
		panic("filter is already registered, can't register")
	}
	f.world.storage.registerFilter(&f.filter, f.relations[:f.numRelations])
	return f
}

// Unregister this filter from the world's filter cache.
func (f *Filter{{.}}{{$genericsShort}}) Unregister() {
	if f.filter.cache == maxCacheID {
		panic("filter is not registered, can't unregister")
	}
	f.world.storage.unregisterFilter(&f.filter)
}

// Query creates a [Query{{.}}] from this filter.
// This must be used each time before iterating a query.
//
// Relation targets provided here are added to those specified with [Filter{{.}}.Relations].
// Relation components must be in the filter's parameters or added via [Filter{{.}}.With] beforehand.
func (f *Filter{{.}}{{$genericsShort}}) Query(rel ...Relation) Query{{.}}{{$genericsShort}} {
	pooled := len(rel) > 0
	var relations []relationID

	f.world.storage.mu.Lock()
	lock := f.world.storage.lock()
	if pooled {
		relations = f.world.storage.slices.relationsPool.Get()
	}
	if f.filter.cache == maxCacheID && f.generation != f.world.storage.registry.getGeneration() {
		f.rareComp = f.world.storage.registry.rareComponent(f.ids).id
		f.generation = f.world.storage.registry.getGeneration()
	}
	f.world.storage.mu.Unlock()

	relations = relationSlice(rel).ToRelations(f.world, &f.filter.mask, f.ids, f.relations[:f.numRelations], relations)
	
	var start uint8
	var cache *cacheEntry
	if f.filter.cache != maxCacheID {
		start = f.numRelations
		cache = f.world.storage.getRegisteredFilter(f.filter.cache)
	}

	return Query{{.}}{{$genericsShort}}{
		world:      f.world,
		filter:     &f.filter,
		relations:  relations[start:],
		cache:      cache,
		lock:       lock,
		components: f.components,
		cursor: cursor{
			archetype: -1,
			table:     -1,
			index:     0,
			maxIndex:  -1,
		},
		rareComp:   f.rareComp,
		{{if eq . 0 -}}
		hasRareComp: len(f.ids) > 0,
		{{- end}}
		isPooled:   pooled,
	}
}

// Batch creates a [Batch] from this filter.
//
// Relation targets provided here are added to those specified with [Filter{{.}}.Relations].
// Relation components must be in the filter's parameters or added via [Filter{{.}}.With] beforehand.
//
// ⚠️ The returned [Batch] filter should not be stored, but used immediately and re-generated
// each time a batch operation is called.
// Otherwise, changes to the origin filter or calls to [Filter{{.}}.Batch] or [Filter{{.}}.Query]
// with different relationship targets may modify stored instances.
func (f *Filter{{.}}{{$genericsShort}}) Batch(rel ...Relation) Batch {
	f.relations = relationSlice(rel).ToRelations(f.world, &f.filter.mask, f.ids, f.relations[:f.numRelations], nil)
	var start uint8
	if f.filter.cache != maxCacheID {
		start = f.numRelations
	}
	return Batch {
		filter:    &f.filter,
		relations: f.relations[start:],
	}
}

func (f *Filter{{.}}{{$genericsShort}}) checkModify() {
	if f.filter.cache != maxCacheID {
		panic("can't modify a cached filter")
	}
	if f.generation != 0 {
		panic("can't modify a filter that was already queried")
	}
}

{{end -}}
{{end -}}
