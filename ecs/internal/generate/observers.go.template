{{- define "template" -}}
package ecs

// Code generated by go generate; DO NOT EDIT.

{{range makeRange 1 4}}
{{- $upper := upperLetters . -}}
{{- $generics := join "[" " any, " " any]" $upper -}}
{{- $genericsShort := join "[" ", " "]" $upper -}}
{{- $fn_args := join "*" ", *" "" $upper -}}

// Observer{{.}} is a generic observer for {{.}} components.
//
// See [Observer] for details on events and observers.
type Observer{{.}}{{$generics}} struct {
	observer Observer
	callback func(Entity, {{$fn_args}})
}

// Observe{{.}} creates a new Observer{{.}}.
func Observe{{.}}{{$generics}}(evt EventType) *Observer{{.}}{{$genericsShort}} {
	return &Observer{{.}}{{$genericsShort}}{
		observer: Observer{
			event: evt,
			id:    maxObserverID,
		},
	}
}

// For adds further components that the observer observes, in addition to its generic parameters.
//
// Method calls can be chained, which has the same effect as calling with multiple arguments.
func (o *Observer{{.}}{{$genericsShort}}) For(comps ...Comp) *Observer{{.}}{{$genericsShort}} {
	o.observer.For(comps...)
	return o
}

// With adds components that entities must have to trigger the observer.
// If multiple components are provided, the entity must have all of them.
//
// Method calls can be chained, which has the same effect as calling with multiple arguments.
func (o *Observer{{.}}{{$genericsShort}}) With(comps ...Comp) *Observer{{.}}{{$genericsShort}} {
	o.observer.With(comps...)
	return o
}

// Without adds components that entities must not have to trigger the observer.
// If multiple components are provided, the entity must not have any of them.
//
// Method calls can be chained, which has the same effect as calling with multiple arguments.
func (o *Observer{{.}}{{$genericsShort}}) Without(comps ...Comp) *Observer{{.}}{{$genericsShort}} {
	o.observer.Without(comps...)
	return o
}

// Exclusive makes the observer exclusive in the sense that the components given by [Observer.With]
// are matched exactly, and no other components are allowed.
//
// Overwrites components set via [Observer.Without].
func (o *Observer{{.}}{{$genericsShort}}) Exclusive() *Observer{{.}}{{$genericsShort}} {
	o.observer.Exclusive()
	return o
}

// Do sets the observer's callback. Must be called exactly once before registration.
func (o *Observer{{.}}{{$genericsShort}}) Do(fn func(Entity, {{$fn_args}})) *Observer{{.}}{{$genericsShort}} {
	if o.callback != nil {
		panic("observer already has a callback")
	}
	o.callback = fn
	return o
}

// Register this observer. This is mandatory for the observer to take effect.
func (o *Observer{{.}}{{$genericsShort}}) Register(w *World) *Observer{{.}}{{$genericsShort}} {
	if o.observer.id != maxObserverID {
		panic("observer is already registered")
	}
	{{- range $i, $v := $upper}}
	storage{{$v}} := &w.storage.components[ComponentID[{{$v}}](w).id]
	{{- end}}

	if o.callback != nil {
		o.observer.callback = func(e Entity) {
			index := &w.storage.entities[e.id]
			row := uintptr(index.row)
			o.callback(
				e,
				{{- range $i, $v := $upper}}
				(*{{$v}})(storage{{$v}}.columns[index.table].Get(row)),
				{{- end}}
			)
		}
	}

	// TODO: optimize to use IDs.
	o.observer.For(
		{{- range $i, $v := $upper}}
		comp[{{$v}}](),
		{{- end}}
	)
	w.registerObserver(&o.observer)
	return o
}

// Unregister this observer.
func (o *Observer{{.}}{{$genericsShort}}) Unregister(w *World) *Observer{{.}}{{$genericsShort}} {
	w.unregisterObserver(&o.observer)
	return o
}

{{end -}}
{{end -}}
