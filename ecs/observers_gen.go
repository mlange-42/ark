package ecs

// Code generated by go generate; DO NOT EDIT.

// Observer1 is a generic observer for 1 components.
//
// See [Observer] for details on events and observers.
type Observer1[A any] struct {
	observer Observer
	callback func(Entity, *A)
	comps    []Comp
}

// Observe1 creates a new Observer1.
func Observe1[A any](evt EventType) *Observer1[A] {
	return &Observer1[A]{
		observer: Observer{
			event: evt,
			id:    maxObserverID,
		},
	}
}

// For adds further components that the observer observes, in addition to its generic parameters.
//
// Method calls can be chained, which has the same effect as calling with multiple arguments.
func (o *Observer1[A]) For(comps ...Comp) *Observer1[A] {
	if o.observer.id != maxObserverID {
		panic("can't modify a registered observer")
	}
	if len(comps) == 0 {
		return o
	}
	o.comps = append(o.comps, comps...)
	return o
}

// With adds components that entities must have to trigger the observer.
// If multiple components are provided, the entity must have all of them.
//
// Method calls can be chained, which has the same effect as calling with multiple arguments.
func (o *Observer1[A]) With(comps ...Comp) *Observer1[A] {
	o.observer.With(comps...)
	return o
}

// Without adds components that entities must not have to trigger the observer.
// If multiple components are provided, the entity must not have any of them.
//
// Method calls can be chained, which has the same effect as calling with multiple arguments.
func (o *Observer1[A]) Without(comps ...Comp) *Observer1[A] {
	o.observer.Without(comps...)
	return o
}

// Exclusive makes the observer exclusive in the sense that the components given by [Observer.With]
// are matched exactly, and no other components are allowed.
//
// Overwrites components set via [Observer.Without].
func (o *Observer1[A]) Exclusive() *Observer1[A] {
	o.observer.Exclusive()
	return o
}

// Do sets the observer's callback. Must be called exactly once before registration.
func (o *Observer1[A]) Do(fn func(Entity, *A)) *Observer1[A] {
	if o.callback != nil {
		panic("observer already has a callback")
	}
	o.callback = fn
	return o
}

// Register this observer. This is mandatory for the observer to take effect.
func (o *Observer1[A]) Register(w *World) *Observer1[A] {
	if o.observer.id != maxObserverID {
		panic("observer is already registered")
	}
	if o.callback == nil {
		panic("observer callback must be set via Do before registering")
	}

	storageA := &w.storage.components[ComponentID[A](w).id]
	o.observer.callback = func(e Entity) {
		index := &w.storage.entities[e.id]
		row := uintptr(index.row)
		o.callback(
			e,
			(*A)(storageA.columns[index.table].Get(row)),
		)
	}

	o.observer.comps = o.observer.comps[:0]
	o.observer.For(
		comp[A](),
	)
	o.observer.For(
		o.comps...,
	)

	w.registerObserver(&o.observer)
	return o
}

// Unregister this observer.
func (o *Observer1[A]) Unregister(w *World) *Observer1[A] {
	w.unregisterObserver(&o.observer)
	return o
}

// Observer2 is a generic observer for 2 components.
//
// See [Observer] for details on events and observers.
type Observer2[A any, B any] struct {
	observer Observer
	callback func(Entity, *A, *B)
	comps    []Comp
}

// Observe2 creates a new Observer2.
func Observe2[A any, B any](evt EventType) *Observer2[A, B] {
	return &Observer2[A, B]{
		observer: Observer{
			event: evt,
			id:    maxObserverID,
		},
	}
}

// For adds further components that the observer observes, in addition to its generic parameters.
//
// Method calls can be chained, which has the same effect as calling with multiple arguments.
func (o *Observer2[A, B]) For(comps ...Comp) *Observer2[A, B] {
	if o.observer.id != maxObserverID {
		panic("can't modify a registered observer")
	}
	if len(comps) == 0 {
		return o
	}
	o.comps = append(o.comps, comps...)
	return o
}

// With adds components that entities must have to trigger the observer.
// If multiple components are provided, the entity must have all of them.
//
// Method calls can be chained, which has the same effect as calling with multiple arguments.
func (o *Observer2[A, B]) With(comps ...Comp) *Observer2[A, B] {
	o.observer.With(comps...)
	return o
}

// Without adds components that entities must not have to trigger the observer.
// If multiple components are provided, the entity must not have any of them.
//
// Method calls can be chained, which has the same effect as calling with multiple arguments.
func (o *Observer2[A, B]) Without(comps ...Comp) *Observer2[A, B] {
	o.observer.Without(comps...)
	return o
}

// Exclusive makes the observer exclusive in the sense that the components given by [Observer.With]
// are matched exactly, and no other components are allowed.
//
// Overwrites components set via [Observer.Without].
func (o *Observer2[A, B]) Exclusive() *Observer2[A, B] {
	o.observer.Exclusive()
	return o
}

// Do sets the observer's callback. Must be called exactly once before registration.
func (o *Observer2[A, B]) Do(fn func(Entity, *A, *B)) *Observer2[A, B] {
	if o.callback != nil {
		panic("observer already has a callback")
	}
	o.callback = fn
	return o
}

// Register this observer. This is mandatory for the observer to take effect.
func (o *Observer2[A, B]) Register(w *World) *Observer2[A, B] {
	if o.observer.id != maxObserverID {
		panic("observer is already registered")
	}
	if o.callback == nil {
		panic("observer callback must be set via Do before registering")
	}

	storageA := &w.storage.components[ComponentID[A](w).id]
	storageB := &w.storage.components[ComponentID[B](w).id]
	o.observer.callback = func(e Entity) {
		index := &w.storage.entities[e.id]
		row := uintptr(index.row)
		o.callback(
			e,
			(*A)(storageA.columns[index.table].Get(row)),
			(*B)(storageB.columns[index.table].Get(row)),
		)
	}

	o.observer.comps = o.observer.comps[:0]
	o.observer.For(
		comp[A](),
		comp[B](),
	)
	o.observer.For(
		o.comps...,
	)

	w.registerObserver(&o.observer)
	return o
}

// Unregister this observer.
func (o *Observer2[A, B]) Unregister(w *World) *Observer2[A, B] {
	w.unregisterObserver(&o.observer)
	return o
}

// Observer3 is a generic observer for 3 components.
//
// See [Observer] for details on events and observers.
type Observer3[A any, B any, C any] struct {
	observer Observer
	callback func(Entity, *A, *B, *C)
	comps    []Comp
}

// Observe3 creates a new Observer3.
func Observe3[A any, B any, C any](evt EventType) *Observer3[A, B, C] {
	return &Observer3[A, B, C]{
		observer: Observer{
			event: evt,
			id:    maxObserverID,
		},
	}
}

// For adds further components that the observer observes, in addition to its generic parameters.
//
// Method calls can be chained, which has the same effect as calling with multiple arguments.
func (o *Observer3[A, B, C]) For(comps ...Comp) *Observer3[A, B, C] {
	if o.observer.id != maxObserverID {
		panic("can't modify a registered observer")
	}
	if len(comps) == 0 {
		return o
	}
	o.comps = append(o.comps, comps...)
	return o
}

// With adds components that entities must have to trigger the observer.
// If multiple components are provided, the entity must have all of them.
//
// Method calls can be chained, which has the same effect as calling with multiple arguments.
func (o *Observer3[A, B, C]) With(comps ...Comp) *Observer3[A, B, C] {
	o.observer.With(comps...)
	return o
}

// Without adds components that entities must not have to trigger the observer.
// If multiple components are provided, the entity must not have any of them.
//
// Method calls can be chained, which has the same effect as calling with multiple arguments.
func (o *Observer3[A, B, C]) Without(comps ...Comp) *Observer3[A, B, C] {
	o.observer.Without(comps...)
	return o
}

// Exclusive makes the observer exclusive in the sense that the components given by [Observer.With]
// are matched exactly, and no other components are allowed.
//
// Overwrites components set via [Observer.Without].
func (o *Observer3[A, B, C]) Exclusive() *Observer3[A, B, C] {
	o.observer.Exclusive()
	return o
}

// Do sets the observer's callback. Must be called exactly once before registration.
func (o *Observer3[A, B, C]) Do(fn func(Entity, *A, *B, *C)) *Observer3[A, B, C] {
	if o.callback != nil {
		panic("observer already has a callback")
	}
	o.callback = fn
	return o
}

// Register this observer. This is mandatory for the observer to take effect.
func (o *Observer3[A, B, C]) Register(w *World) *Observer3[A, B, C] {
	if o.observer.id != maxObserverID {
		panic("observer is already registered")
	}
	if o.callback == nil {
		panic("observer callback must be set via Do before registering")
	}

	storageA := &w.storage.components[ComponentID[A](w).id]
	storageB := &w.storage.components[ComponentID[B](w).id]
	storageC := &w.storage.components[ComponentID[C](w).id]
	o.observer.callback = func(e Entity) {
		index := &w.storage.entities[e.id]
		row := uintptr(index.row)
		o.callback(
			e,
			(*A)(storageA.columns[index.table].Get(row)),
			(*B)(storageB.columns[index.table].Get(row)),
			(*C)(storageC.columns[index.table].Get(row)),
		)
	}

	o.observer.comps = o.observer.comps[:0]
	o.observer.For(
		comp[A](),
		comp[B](),
		comp[C](),
	)
	o.observer.For(
		o.comps...,
	)

	w.registerObserver(&o.observer)
	return o
}

// Unregister this observer.
func (o *Observer3[A, B, C]) Unregister(w *World) *Observer3[A, B, C] {
	w.unregisterObserver(&o.observer)
	return o
}

// Observer4 is a generic observer for 4 components.
//
// See [Observer] for details on events and observers.
type Observer4[A any, B any, C any, D any] struct {
	observer Observer
	callback func(Entity, *A, *B, *C, *D)
	comps    []Comp
}

// Observe4 creates a new Observer4.
func Observe4[A any, B any, C any, D any](evt EventType) *Observer4[A, B, C, D] {
	return &Observer4[A, B, C, D]{
		observer: Observer{
			event: evt,
			id:    maxObserverID,
		},
	}
}

// For adds further components that the observer observes, in addition to its generic parameters.
//
// Method calls can be chained, which has the same effect as calling with multiple arguments.
func (o *Observer4[A, B, C, D]) For(comps ...Comp) *Observer4[A, B, C, D] {
	if o.observer.id != maxObserverID {
		panic("can't modify a registered observer")
	}
	if len(comps) == 0 {
		return o
	}
	o.comps = append(o.comps, comps...)
	return o
}

// With adds components that entities must have to trigger the observer.
// If multiple components are provided, the entity must have all of them.
//
// Method calls can be chained, which has the same effect as calling with multiple arguments.
func (o *Observer4[A, B, C, D]) With(comps ...Comp) *Observer4[A, B, C, D] {
	o.observer.With(comps...)
	return o
}

// Without adds components that entities must not have to trigger the observer.
// If multiple components are provided, the entity must not have any of them.
//
// Method calls can be chained, which has the same effect as calling with multiple arguments.
func (o *Observer4[A, B, C, D]) Without(comps ...Comp) *Observer4[A, B, C, D] {
	o.observer.Without(comps...)
	return o
}

// Exclusive makes the observer exclusive in the sense that the components given by [Observer.With]
// are matched exactly, and no other components are allowed.
//
// Overwrites components set via [Observer.Without].
func (o *Observer4[A, B, C, D]) Exclusive() *Observer4[A, B, C, D] {
	o.observer.Exclusive()
	return o
}

// Do sets the observer's callback. Must be called exactly once before registration.
func (o *Observer4[A, B, C, D]) Do(fn func(Entity, *A, *B, *C, *D)) *Observer4[A, B, C, D] {
	if o.callback != nil {
		panic("observer already has a callback")
	}
	o.callback = fn
	return o
}

// Register this observer. This is mandatory for the observer to take effect.
func (o *Observer4[A, B, C, D]) Register(w *World) *Observer4[A, B, C, D] {
	if o.observer.id != maxObserverID {
		panic("observer is already registered")
	}
	if o.callback == nil {
		panic("observer callback must be set via Do before registering")
	}

	storageA := &w.storage.components[ComponentID[A](w).id]
	storageB := &w.storage.components[ComponentID[B](w).id]
	storageC := &w.storage.components[ComponentID[C](w).id]
	storageD := &w.storage.components[ComponentID[D](w).id]
	o.observer.callback = func(e Entity) {
		index := &w.storage.entities[e.id]
		row := uintptr(index.row)
		o.callback(
			e,
			(*A)(storageA.columns[index.table].Get(row)),
			(*B)(storageB.columns[index.table].Get(row)),
			(*C)(storageC.columns[index.table].Get(row)),
			(*D)(storageD.columns[index.table].Get(row)),
		)
	}

	o.observer.comps = o.observer.comps[:0]
	o.observer.For(
		comp[A](),
		comp[B](),
		comp[C](),
		comp[D](),
	)
	o.observer.For(
		o.comps...,
	)

	w.registerObserver(&o.observer)
	return o
}

// Unregister this observer.
func (o *Observer4[A, B, C, D]) Unregister(w *World) *Observer4[A, B, C, D] {
	w.unregisterObserver(&o.observer)
	return o
}
