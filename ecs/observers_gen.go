package ecs

// Code generated by go generate; DO NOT EDIT.

// Observer1 is a generic observer for 1 components.
//
// See [Observer] for details on events and observers.
type Observer1[A any] struct {
	observer Observer
	callback func(Entity, *A)
}

// Observe1 creates a new Observer1.
//
// See also [Observer1.New] for a shortcut when constructing an already defined instance.
func Observe1[A any](evt EventType) *Observer1[A] {
	comps := make([]Comp, 0, 6)
	comps = append(comps, comp[A]())

	return &Observer1[A]{
		observer: Observer{
			event: evt,
			comps: comps,
			observerData: observerData{
				id: maxObserverID,
			},
		},
	}
}

// New creates a new [Observer1]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
func (_ *Observer1[A]) New(evt EventType) *Observer1[A] {
	return Observe1[A](evt)
}

// For adds further components that the observer observes, in addition to its generic parameters.
//
// Method calls can be chained, which has the same effect as calling with multiple arguments.
func (o *Observer1[A]) For(comps ...Comp) *Observer1[A] {
	o.observer.For(comps...)
	return o
}

// With adds components that entities must have to trigger the observer.
// If multiple components are provided, the entity must have all of them.
//
// Method calls can be chained, which has the same effect as calling with multiple arguments.
func (o *Observer1[A]) With(comps ...Comp) *Observer1[A] {
	o.observer.With(comps...)
	return o
}

// Without adds components that entities must not have to trigger the observer.
// If multiple components are provided, the entity must not have any of them.
//
// Method calls can be chained, which has the same effect as calling with multiple arguments.
func (o *Observer1[A]) Without(comps ...Comp) *Observer1[A] {
	o.observer.Without(comps...)
	return o
}

// Exclusive makes the observer exclusive in the sense that the components given by [Observer.With]
// are matched exactly, and no other components are allowed.
//
// Overwrites components set via [Observer.Without].
func (o *Observer1[A]) Exclusive() *Observer1[A] {
	o.observer.Exclusive()
	return o
}

// Do sets the observer's callback. Must be called exactly once before registration.
func (o *Observer1[A]) Do(fn func(Entity, *A)) *Observer1[A] {
	if o.callback != nil {
		panic("observer already has a callback")
	}
	o.callback = fn
	return o
}

// Register this observer. This is mandatory for the observer to take effect.
func (o *Observer1[A]) Register(w *World) *Observer1[A] {
	if o.callback == nil {
		panic("observer callback must be set via Do before registering")
	}

	storageA := &w.storage.components[ComponentID[A](w).id]
	o.observer.callback = func(e Entity) {
		index := &w.storage.entities[e.id]
		o.callback(
			e,
			get[A](storageA, index),
		)
	}

	w.registerObserver(&o.observer)
	return o
}

// Unregister this observer.
func (o *Observer1[A]) Unregister(w *World) *Observer1[A] {
	w.unregisterObserver(&o.observer)
	return o
}

// Observer2 is a generic observer for 2 components.
//
// See [Observer] for details on events and observers.
//
// See [Observer1] for an example.
type Observer2[A any, B any] struct {
	observer Observer
	callback func(Entity, *A, *B)
}

// Observe2 creates a new Observer2.
//
// See also [Observer2.New] for a shortcut when constructing an already defined instance.
func Observe2[A any, B any](evt EventType) *Observer2[A, B] {
	comps := make([]Comp, 0, 6)
	comps = append(comps, comp[A]())
	comps = append(comps, comp[B]())

	return &Observer2[A, B]{
		observer: Observer{
			event: evt,
			comps: comps,
			observerData: observerData{
				id: maxObserverID,
			},
		},
	}
}

// New creates a new [Observer2]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
//
// See [Observer1.New] for an example.
func (_ *Observer2[A, B]) New(evt EventType) *Observer2[A, B] {
	return Observe2[A, B](evt)
}

// For adds further components that the observer observes, in addition to its generic parameters.
//
// Method calls can be chained, which has the same effect as calling with multiple arguments.
//
// See [Observer1.For] for an example.
func (o *Observer2[A, B]) For(comps ...Comp) *Observer2[A, B] {
	o.observer.For(comps...)
	return o
}

// With adds components that entities must have to trigger the observer.
// If multiple components are provided, the entity must have all of them.
//
// Method calls can be chained, which has the same effect as calling with multiple arguments.
//
// See [Observer1.With] for an example.
func (o *Observer2[A, B]) With(comps ...Comp) *Observer2[A, B] {
	o.observer.With(comps...)
	return o
}

// Without adds components that entities must not have to trigger the observer.
// If multiple components are provided, the entity must not have any of them.
//
// Method calls can be chained, which has the same effect as calling with multiple arguments.
//
// See [Observer1.Without] for an example.
func (o *Observer2[A, B]) Without(comps ...Comp) *Observer2[A, B] {
	o.observer.Without(comps...)
	return o
}

// Exclusive makes the observer exclusive in the sense that the components given by [Observer.With]
// are matched exactly, and no other components are allowed.
//
// Overwrites components set via [Observer.Without].
//
// See [Observer1.Exclusive] for an example.
func (o *Observer2[A, B]) Exclusive() *Observer2[A, B] {
	o.observer.Exclusive()
	return o
}

// Do sets the observer's callback. Must be called exactly once before registration.
func (o *Observer2[A, B]) Do(fn func(Entity, *A, *B)) *Observer2[A, B] {
	if o.callback != nil {
		panic("observer already has a callback")
	}
	o.callback = fn
	return o
}

// Register this observer. This is mandatory for the observer to take effect.
func (o *Observer2[A, B]) Register(w *World) *Observer2[A, B] {
	if o.callback == nil {
		panic("observer callback must be set via Do before registering")
	}

	storageA := &w.storage.components[ComponentID[A](w).id]
	storageB := &w.storage.components[ComponentID[B](w).id]
	o.observer.callback = func(e Entity) {
		index := &w.storage.entities[e.id]
		o.callback(
			e,
			get[A](storageA, index),
			get[B](storageB, index),
		)
	}

	w.registerObserver(&o.observer)
	return o
}

// Unregister this observer.
func (o *Observer2[A, B]) Unregister(w *World) *Observer2[A, B] {
	w.unregisterObserver(&o.observer)
	return o
}

// Observer3 is a generic observer for 3 components.
//
// See [Observer] for details on events and observers.
//
// See [Observer1] for an example.
type Observer3[A any, B any, C any] struct {
	observer Observer
	callback func(Entity, *A, *B, *C)
}

// Observe3 creates a new Observer3.
//
// See also [Observer3.New] for a shortcut when constructing an already defined instance.
func Observe3[A any, B any, C any](evt EventType) *Observer3[A, B, C] {
	comps := make([]Comp, 0, 6)
	comps = append(comps, comp[A]())
	comps = append(comps, comp[B]())
	comps = append(comps, comp[C]())

	return &Observer3[A, B, C]{
		observer: Observer{
			event: evt,
			comps: comps,
			observerData: observerData{
				id: maxObserverID,
			},
		},
	}
}

// New creates a new [Observer3]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
//
// See [Observer1.New] for an example.
func (_ *Observer3[A, B, C]) New(evt EventType) *Observer3[A, B, C] {
	return Observe3[A, B, C](evt)
}

// For adds further components that the observer observes, in addition to its generic parameters.
//
// Method calls can be chained, which has the same effect as calling with multiple arguments.
//
// See [Observer1.For] for an example.
func (o *Observer3[A, B, C]) For(comps ...Comp) *Observer3[A, B, C] {
	o.observer.For(comps...)
	return o
}

// With adds components that entities must have to trigger the observer.
// If multiple components are provided, the entity must have all of them.
//
// Method calls can be chained, which has the same effect as calling with multiple arguments.
//
// See [Observer1.With] for an example.
func (o *Observer3[A, B, C]) With(comps ...Comp) *Observer3[A, B, C] {
	o.observer.With(comps...)
	return o
}

// Without adds components that entities must not have to trigger the observer.
// If multiple components are provided, the entity must not have any of them.
//
// Method calls can be chained, which has the same effect as calling with multiple arguments.
//
// See [Observer1.Without] for an example.
func (o *Observer3[A, B, C]) Without(comps ...Comp) *Observer3[A, B, C] {
	o.observer.Without(comps...)
	return o
}

// Exclusive makes the observer exclusive in the sense that the components given by [Observer.With]
// are matched exactly, and no other components are allowed.
//
// Overwrites components set via [Observer.Without].
//
// See [Observer1.Exclusive] for an example.
func (o *Observer3[A, B, C]) Exclusive() *Observer3[A, B, C] {
	o.observer.Exclusive()
	return o
}

// Do sets the observer's callback. Must be called exactly once before registration.
func (o *Observer3[A, B, C]) Do(fn func(Entity, *A, *B, *C)) *Observer3[A, B, C] {
	if o.callback != nil {
		panic("observer already has a callback")
	}
	o.callback = fn
	return o
}

// Register this observer. This is mandatory for the observer to take effect.
func (o *Observer3[A, B, C]) Register(w *World) *Observer3[A, B, C] {
	if o.callback == nil {
		panic("observer callback must be set via Do before registering")
	}

	storageA := &w.storage.components[ComponentID[A](w).id]
	storageB := &w.storage.components[ComponentID[B](w).id]
	storageC := &w.storage.components[ComponentID[C](w).id]
	o.observer.callback = func(e Entity) {
		index := &w.storage.entities[e.id]
		o.callback(
			e,
			get[A](storageA, index),
			get[B](storageB, index),
			get[C](storageC, index),
		)
	}

	w.registerObserver(&o.observer)
	return o
}

// Unregister this observer.
func (o *Observer3[A, B, C]) Unregister(w *World) *Observer3[A, B, C] {
	w.unregisterObserver(&o.observer)
	return o
}

// Observer4 is a generic observer for 4 components.
//
// See [Observer] for details on events and observers.
//
// See [Observer1] for an example.
type Observer4[A any, B any, C any, D any] struct {
	observer Observer
	callback func(Entity, *A, *B, *C, *D)
}

// Observe4 creates a new Observer4.
//
// See also [Observer4.New] for a shortcut when constructing an already defined instance.
func Observe4[A any, B any, C any, D any](evt EventType) *Observer4[A, B, C, D] {
	comps := make([]Comp, 0, 6)
	comps = append(comps, comp[A]())
	comps = append(comps, comp[B]())
	comps = append(comps, comp[C]())
	comps = append(comps, comp[D]())

	return &Observer4[A, B, C, D]{
		observer: Observer{
			event: evt,
			comps: comps,
			observerData: observerData{
				id: maxObserverID,
			},
		},
	}
}

// New creates a new [Observer4]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
//
// See [Observer1.New] for an example.
func (_ *Observer4[A, B, C, D]) New(evt EventType) *Observer4[A, B, C, D] {
	return Observe4[A, B, C, D](evt)
}

// For adds further components that the observer observes, in addition to its generic parameters.
//
// Method calls can be chained, which has the same effect as calling with multiple arguments.
//
// See [Observer1.For] for an example.
func (o *Observer4[A, B, C, D]) For(comps ...Comp) *Observer4[A, B, C, D] {
	o.observer.For(comps...)
	return o
}

// With adds components that entities must have to trigger the observer.
// If multiple components are provided, the entity must have all of them.
//
// Method calls can be chained, which has the same effect as calling with multiple arguments.
//
// See [Observer1.With] for an example.
func (o *Observer4[A, B, C, D]) With(comps ...Comp) *Observer4[A, B, C, D] {
	o.observer.With(comps...)
	return o
}

// Without adds components that entities must not have to trigger the observer.
// If multiple components are provided, the entity must not have any of them.
//
// Method calls can be chained, which has the same effect as calling with multiple arguments.
//
// See [Observer1.Without] for an example.
func (o *Observer4[A, B, C, D]) Without(comps ...Comp) *Observer4[A, B, C, D] {
	o.observer.Without(comps...)
	return o
}

// Exclusive makes the observer exclusive in the sense that the components given by [Observer.With]
// are matched exactly, and no other components are allowed.
//
// Overwrites components set via [Observer.Without].
//
// See [Observer1.Exclusive] for an example.
func (o *Observer4[A, B, C, D]) Exclusive() *Observer4[A, B, C, D] {
	o.observer.Exclusive()
	return o
}

// Do sets the observer's callback. Must be called exactly once before registration.
func (o *Observer4[A, B, C, D]) Do(fn func(Entity, *A, *B, *C, *D)) *Observer4[A, B, C, D] {
	if o.callback != nil {
		panic("observer already has a callback")
	}
	o.callback = fn
	return o
}

// Register this observer. This is mandatory for the observer to take effect.
func (o *Observer4[A, B, C, D]) Register(w *World) *Observer4[A, B, C, D] {
	if o.callback == nil {
		panic("observer callback must be set via Do before registering")
	}

	storageA := &w.storage.components[ComponentID[A](w).id]
	storageB := &w.storage.components[ComponentID[B](w).id]
	storageC := &w.storage.components[ComponentID[C](w).id]
	storageD := &w.storage.components[ComponentID[D](w).id]
	o.observer.callback = func(e Entity) {
		index := &w.storage.entities[e.id]
		o.callback(
			e,
			get[A](storageA, index),
			get[B](storageB, index),
			get[C](storageC, index),
			get[D](storageD, index),
		)
	}

	w.registerObserver(&o.observer)
	return o
}

// Unregister this observer.
func (o *Observer4[A, B, C, D]) Unregister(w *World) *Observer4[A, B, C, D] {
	w.unregisterObserver(&o.observer)
	return o
}
