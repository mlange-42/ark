package ecs

// Code generated by go generate; DO NOT EDIT.

import "testing"

func TestExchange1(t *testing.T) {
	w := NewWorld(16)

	posMap := NewMap2[Position, Velocity](w)
	mapper := NewMap1[CompA](w)

	var ex *Exchange1[CompA]
	ex = ex.New(w).Removes(C[Velocity](), C[Position]())

	e := posMap.NewEntity(&Position{}, &Velocity{})

	ex.Exchange(e, &CompA{})
	expectFalse(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))

	e = posMap.NewEntity(&Position{}, &Velocity{})
	ex.ExchangeFn(e, func(a *CompA) {
		a.X = 100
	})
	expectFalse(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))
}

func TestExchange1Add(t *testing.T) {
	w := NewWorld(16)

	posMap := NewMap2[Position, Velocity](w)
	mapper := NewMap1[CompA](w)
	ex := NewExchange1[CompA](w).Removes(C[Velocity](), C[Position]())

	e := posMap.NewEntity(&Position{}, &Velocity{})

	ex.Add(e, &CompA{})
	expectTrue(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))

	e = posMap.NewEntity(&Position{}, &Velocity{})

	ex.AddFn(e, func(a *CompA) {
		a.X = 100
	})
	expectTrue(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))
}

func TestExchange1Relations(t *testing.T) {
	w := NewWorld(8)

	Observe(OnAddRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(w)
	Observe(OnRemoveRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(w)

	ex := NewExchange1[ChildOf](w).Removes(C[Position]())
	mapper1 := NewMap1[ChildOf](w)
	mapper2 := NewMap1[Position](w)

	parent1 := w.NewEntity()

	e1 := w.NewEntity()
	ex.Add(e1, &ChildOf{}, RelIdx(0, parent1))
	expectEqual(t, parent1, mapper1.GetRelation(e1, 0))
	expectEqual(t, parent1, mapper1.GetRelationUnchecked(e1, 0))

	e2 := mapper2.NewEntity(&Position{})
	ex.Exchange(e2, &ChildOf{}, RelIdx(0, parent1))
	expectEqual(t, parent1, mapper1.GetRelation(e2, 0))
	expectEqual(t, parent1, mapper1.GetRelationUnchecked(e2, 0))
}

func TestExchange1Remove(t *testing.T) {
	w := NewWorld(16)

	posMap := NewMap2[Position, Velocity](w)
	mapper := NewMap1[CompA](w)
	ex := NewExchange1[CompA](w).Removes(C[Velocity](), C[Position]())

	e := posMap.NewEntity(&Position{}, &Velocity{})

	ex.Remove(e)
	expectFalse(t, posMap.HasAll(e))
	expectFalse(t, mapper.HasAll(e))
}

func TestExchange1AddBatch(t *testing.T) {
	n := 12
	w := NewWorld(8)

	Observe(OnAddComponents).For(C[Heading]()).Do(func(e Entity) {}).Register(w)
	Observe(OnRemoveComponents).For(C[Heading]()).Do(func(e Entity) {}).Register(w)
	Observe(OnAddRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(w)
	Observe(OnRemoveRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(w)

	exchange := NewExchange1[CompA](w).Removes(C[CompA]())
	posMap := NewMap1[Position](w)
	posVelMap := NewMap2[Position, Velocity](w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position) {
		pos.X = float64(cnt)
		cnt++
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity) {
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](w)
	exchange.AddBatch(filter.Batch(), &CompA{})

	filter2 := NewFilter1[CompA](w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		pos := posMap.Get(query.Entity())
		expectGreater(t, pos.X, 0.0)
		cnt++
	}
	expectEqual(t, 2*n, cnt)

	exchange.RemoveBatch(filter2.Batch(), nil)

	query = filter2.Query()
	cnt = 0
	for query.Next() {
		cnt++
	}
	expectEqual(t, 0, cnt)
}

func TestExchange1AddBatchFn(t *testing.T) {
	n := 12
	w := NewWorld(8)

	exchange := NewExchange1[CompA](w).Removes(C[CompA]())
	posMap := NewMap1[Position](w)
	posVelMap := NewMap2[Position, Velocity](w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position) {
		pos.X = float64(cnt)
		cnt++
		expectTrue(t, w.IsLocked())
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity) {
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](w)
	cnt = 0
	exchange.AddBatchFn(filter.Batch(), func(entity Entity, a *CompA) {
		a.X = float64(cnt)
		cnt++
		expectTrue(t, w.IsLocked())
	})

	filter2 := NewFilter1[CompA](w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		a := query.Get()
		expectEqual(t, float64(cnt), a.X)
		pos := posMap.Get(query.Entity())
		expectGreater(t, pos.X, 0.0)
		cnt++
	}
	expectEqual(t, 2*n, cnt)

	cnt = 0
	exchange.RemoveBatch(filter2.Batch(), func(entity Entity) {
		cnt++
	})
	expectEqual(t, 2*n, cnt)

	query = filter2.Query()
	cnt = 0
	for query.Next() {
		cnt++
	}
	expectEqual(t, 0, cnt)
}

func TestExchange1ExchangeBatch(t *testing.T) {
	n := 12
	w := NewWorld(8)

	exchange := NewExchange1[CompA](w).Removes(C[Position]())
	posMap := NewMap1[Position](w)
	posVelMap := NewMap2[Position, Velocity](w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position) {
		pos.X = float64(cnt)
		cnt++
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity) {
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](w)
	exchange.ExchangeBatch(filter.Batch(), &CompA{})

	filter2 := NewFilter1[CompA](w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		expectFalse(t, posMap.HasAll(query.Entity()))
		cnt++
	}
	expectEqual(t, 2*n, cnt)
}

func TestExchange1ExchangeBatchFn(t *testing.T) {
	n := 12
	w := NewWorld(8)

	exchange := NewExchange1[CompA](w).Removes(C[Position]())
	posMap := NewMap1[Position](w)
	posVelMap := NewMap2[Position, Velocity](w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position) {
		pos.X = float64(cnt)
		cnt++
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity) {
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](w)
	cnt = 0
	exchange.ExchangeBatchFn(filter.Batch(), func(entity Entity, a *CompA) {
		a.X = float64(cnt)
		cnt++
		expectTrue(t, w.IsLocked())
	})

	filter2 := NewFilter1[CompA](w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		a := query.Get()
		expectEqual(t, float64(cnt), a.X)
		expectFalse(t, posMap.HasAll(query.Entity()))
		cnt++
	}
	expectEqual(t, 2*n, cnt)
}

func TestExchange2(t *testing.T) {
	w := NewWorld(16)

	posMap := NewMap2[Position, Velocity](w)
	mapper := NewMap2[CompA, CompB](w)

	var ex *Exchange2[CompA, CompB]
	ex = ex.New(w).Removes(C[Velocity](), C[Position]())

	e := posMap.NewEntity(&Position{}, &Velocity{})

	ex.Exchange(e, &CompA{}, &CompB{})
	expectFalse(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))

	e = posMap.NewEntity(&Position{}, &Velocity{})
	ex.ExchangeFn(e, func(a *CompA, b *CompB) {
		a.X = 100
	})
	expectFalse(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))
}

func TestExchange2Add(t *testing.T) {
	w := NewWorld(16)

	posMap := NewMap2[Position, Velocity](w)
	mapper := NewMap2[CompA, CompB](w)
	ex := NewExchange2[CompA, CompB](w).Removes(C[Velocity](), C[Position]())

	e := posMap.NewEntity(&Position{}, &Velocity{})

	ex.Add(e, &CompA{}, &CompB{})
	expectTrue(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))

	e = posMap.NewEntity(&Position{}, &Velocity{})

	ex.AddFn(e, func(a *CompA, b *CompB) {
		a.X = 100
	})
	expectTrue(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))
}

func TestExchange2Relations(t *testing.T) {
	w := NewWorld(8)

	Observe(OnAddRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(w)
	Observe(OnRemoveRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(w)

	ex := NewExchange2[ChildOf, CompB](w).Removes(C[Position]())
	mapper1 := NewMap1[ChildOf](w)
	mapper2 := NewMap1[Position](w)

	parent1 := w.NewEntity()

	e1 := w.NewEntity()
	ex.Add(e1, &ChildOf{}, &CompB{}, RelIdx(0, parent1))
	expectEqual(t, parent1, mapper1.GetRelation(e1, 0))
	expectEqual(t, parent1, mapper1.GetRelationUnchecked(e1, 0))

	e2 := mapper2.NewEntity(&Position{})
	ex.Exchange(e2, &ChildOf{}, &CompB{}, RelIdx(0, parent1))
	expectEqual(t, parent1, mapper1.GetRelation(e2, 0))
	expectEqual(t, parent1, mapper1.GetRelationUnchecked(e2, 0))
}

func TestExchange2Remove(t *testing.T) {
	w := NewWorld(16)

	posMap := NewMap2[Position, Velocity](w)
	mapper := NewMap2[CompA, CompB](w)
	ex := NewExchange2[CompA, CompB](w).Removes(C[Velocity](), C[Position]())

	e := posMap.NewEntity(&Position{}, &Velocity{})

	ex.Remove(e)
	expectFalse(t, posMap.HasAll(e))
	expectFalse(t, mapper.HasAll(e))
}

func TestExchange2AddBatch(t *testing.T) {
	n := 12
	w := NewWorld(8)

	Observe(OnAddComponents).For(C[Heading]()).Do(func(e Entity) {}).Register(w)
	Observe(OnRemoveComponents).For(C[Heading]()).Do(func(e Entity) {}).Register(w)
	Observe(OnAddRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(w)
	Observe(OnRemoveRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(w)

	exchange := NewExchange2[CompA, CompB](w).Removes(C[CompA]())
	posMap := NewMap1[Position](w)
	posVelMap := NewMap2[Position, Velocity](w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position) {
		pos.X = float64(cnt)
		cnt++
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity) {
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](w)
	exchange.AddBatch(filter.Batch(), &CompA{}, &CompB{})

	filter2 := NewFilter1[CompA](w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		pos := posMap.Get(query.Entity())
		expectGreater(t, pos.X, 0.0)
		cnt++
	}
	expectEqual(t, 2*n, cnt)

	exchange.RemoveBatch(filter2.Batch(), nil)

	query = filter2.Query()
	cnt = 0
	for query.Next() {
		cnt++
	}
	expectEqual(t, 0, cnt)
}

func TestExchange2AddBatchFn(t *testing.T) {
	n := 12
	w := NewWorld(8)

	exchange := NewExchange2[CompA, CompB](w).Removes(C[CompA]())
	posMap := NewMap1[Position](w)
	posVelMap := NewMap2[Position, Velocity](w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position) {
		pos.X = float64(cnt)
		cnt++
		expectTrue(t, w.IsLocked())
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity) {
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](w)
	cnt = 0
	exchange.AddBatchFn(filter.Batch(), func(entity Entity, a *CompA, b *CompB) {
		a.X = float64(cnt)
		cnt++
		expectTrue(t, w.IsLocked())
	})

	filter2 := NewFilter1[CompA](w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		a := query.Get()
		expectEqual(t, float64(cnt), a.X)
		pos := posMap.Get(query.Entity())
		expectGreater(t, pos.X, 0.0)
		cnt++
	}
	expectEqual(t, 2*n, cnt)

	cnt = 0
	exchange.RemoveBatch(filter2.Batch(), func(entity Entity) {
		cnt++
	})
	expectEqual(t, 2*n, cnt)

	query = filter2.Query()
	cnt = 0
	for query.Next() {
		cnt++
	}
	expectEqual(t, 0, cnt)
}

func TestExchange2ExchangeBatch(t *testing.T) {
	n := 12
	w := NewWorld(8)

	exchange := NewExchange2[CompA, CompB](w).Removes(C[Position]())
	posMap := NewMap1[Position](w)
	posVelMap := NewMap2[Position, Velocity](w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position) {
		pos.X = float64(cnt)
		cnt++
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity) {
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](w)
	exchange.ExchangeBatch(filter.Batch(), &CompA{}, &CompB{})

	filter2 := NewFilter1[CompA](w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		expectFalse(t, posMap.HasAll(query.Entity()))
		cnt++
	}
	expectEqual(t, 2*n, cnt)
}

func TestExchange2ExchangeBatchFn(t *testing.T) {
	n := 12
	w := NewWorld(8)

	exchange := NewExchange2[CompA, CompB](w).Removes(C[Position]())
	posMap := NewMap1[Position](w)
	posVelMap := NewMap2[Position, Velocity](w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position) {
		pos.X = float64(cnt)
		cnt++
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity) {
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](w)
	cnt = 0
	exchange.ExchangeBatchFn(filter.Batch(), func(entity Entity, a *CompA, b *CompB) {
		a.X = float64(cnt)
		cnt++
		expectTrue(t, w.IsLocked())
	})

	filter2 := NewFilter1[CompA](w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		a := query.Get()
		expectEqual(t, float64(cnt), a.X)
		expectFalse(t, posMap.HasAll(query.Entity()))
		cnt++
	}
	expectEqual(t, 2*n, cnt)
}

func TestExchange3(t *testing.T) {
	w := NewWorld(16)

	posMap := NewMap2[Position, Velocity](w)
	mapper := NewMap3[CompA, CompB, CompC](w)

	var ex *Exchange3[CompA, CompB, CompC]
	ex = ex.New(w).Removes(C[Velocity](), C[Position]())

	e := posMap.NewEntity(&Position{}, &Velocity{})

	ex.Exchange(e, &CompA{}, &CompB{}, &CompC{})
	expectFalse(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))

	e = posMap.NewEntity(&Position{}, &Velocity{})
	ex.ExchangeFn(e, func(a *CompA, b *CompB, c *CompC) {
		a.X = 100
	})
	expectFalse(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))
}

func TestExchange3Add(t *testing.T) {
	w := NewWorld(16)

	posMap := NewMap2[Position, Velocity](w)
	mapper := NewMap3[CompA, CompB, CompC](w)
	ex := NewExchange3[CompA, CompB, CompC](w).Removes(C[Velocity](), C[Position]())

	e := posMap.NewEntity(&Position{}, &Velocity{})

	ex.Add(e, &CompA{}, &CompB{}, &CompC{})
	expectTrue(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))

	e = posMap.NewEntity(&Position{}, &Velocity{})

	ex.AddFn(e, func(a *CompA, b *CompB, c *CompC) {
		a.X = 100
	})
	expectTrue(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))
}

func TestExchange3Relations(t *testing.T) {
	w := NewWorld(8)

	Observe(OnAddRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(w)
	Observe(OnRemoveRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(w)

	ex := NewExchange3[ChildOf, CompB, CompC](w).Removes(C[Position]())
	mapper1 := NewMap1[ChildOf](w)
	mapper2 := NewMap1[Position](w)

	parent1 := w.NewEntity()

	e1 := w.NewEntity()
	ex.Add(e1, &ChildOf{}, &CompB{}, &CompC{}, RelIdx(0, parent1))
	expectEqual(t, parent1, mapper1.GetRelation(e1, 0))
	expectEqual(t, parent1, mapper1.GetRelationUnchecked(e1, 0))

	e2 := mapper2.NewEntity(&Position{})
	ex.Exchange(e2, &ChildOf{}, &CompB{}, &CompC{}, RelIdx(0, parent1))
	expectEqual(t, parent1, mapper1.GetRelation(e2, 0))
	expectEqual(t, parent1, mapper1.GetRelationUnchecked(e2, 0))
}

func TestExchange3Remove(t *testing.T) {
	w := NewWorld(16)

	posMap := NewMap2[Position, Velocity](w)
	mapper := NewMap3[CompA, CompB, CompC](w)
	ex := NewExchange3[CompA, CompB, CompC](w).Removes(C[Velocity](), C[Position]())

	e := posMap.NewEntity(&Position{}, &Velocity{})

	ex.Remove(e)
	expectFalse(t, posMap.HasAll(e))
	expectFalse(t, mapper.HasAll(e))
}

func TestExchange3AddBatch(t *testing.T) {
	n := 12
	w := NewWorld(8)

	Observe(OnAddComponents).For(C[Heading]()).Do(func(e Entity) {}).Register(w)
	Observe(OnRemoveComponents).For(C[Heading]()).Do(func(e Entity) {}).Register(w)
	Observe(OnAddRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(w)
	Observe(OnRemoveRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(w)

	exchange := NewExchange3[CompA, CompB, CompC](w).Removes(C[CompA]())
	posMap := NewMap1[Position](w)
	posVelMap := NewMap2[Position, Velocity](w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position) {
		pos.X = float64(cnt)
		cnt++
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity) {
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](w)
	exchange.AddBatch(filter.Batch(), &CompA{}, &CompB{}, &CompC{})

	filter2 := NewFilter1[CompA](w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		pos := posMap.Get(query.Entity())
		expectGreater(t, pos.X, 0.0)
		cnt++
	}
	expectEqual(t, 2*n, cnt)

	exchange.RemoveBatch(filter2.Batch(), nil)

	query = filter2.Query()
	cnt = 0
	for query.Next() {
		cnt++
	}
	expectEqual(t, 0, cnt)
}

func TestExchange3AddBatchFn(t *testing.T) {
	n := 12
	w := NewWorld(8)

	exchange := NewExchange3[CompA, CompB, CompC](w).Removes(C[CompA]())
	posMap := NewMap1[Position](w)
	posVelMap := NewMap2[Position, Velocity](w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position) {
		pos.X = float64(cnt)
		cnt++
		expectTrue(t, w.IsLocked())
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity) {
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](w)
	cnt = 0
	exchange.AddBatchFn(filter.Batch(), func(entity Entity, a *CompA, b *CompB, c *CompC) {
		a.X = float64(cnt)
		cnt++
		expectTrue(t, w.IsLocked())
	})

	filter2 := NewFilter1[CompA](w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		a := query.Get()
		expectEqual(t, float64(cnt), a.X)
		pos := posMap.Get(query.Entity())
		expectGreater(t, pos.X, 0.0)
		cnt++
	}
	expectEqual(t, 2*n, cnt)

	cnt = 0
	exchange.RemoveBatch(filter2.Batch(), func(entity Entity) {
		cnt++
	})
	expectEqual(t, 2*n, cnt)

	query = filter2.Query()
	cnt = 0
	for query.Next() {
		cnt++
	}
	expectEqual(t, 0, cnt)
}

func TestExchange3ExchangeBatch(t *testing.T) {
	n := 12
	w := NewWorld(8)

	exchange := NewExchange3[CompA, CompB, CompC](w).Removes(C[Position]())
	posMap := NewMap1[Position](w)
	posVelMap := NewMap2[Position, Velocity](w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position) {
		pos.X = float64(cnt)
		cnt++
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity) {
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](w)
	exchange.ExchangeBatch(filter.Batch(), &CompA{}, &CompB{}, &CompC{})

	filter2 := NewFilter1[CompA](w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		expectFalse(t, posMap.HasAll(query.Entity()))
		cnt++
	}
	expectEqual(t, 2*n, cnt)
}

func TestExchange3ExchangeBatchFn(t *testing.T) {
	n := 12
	w := NewWorld(8)

	exchange := NewExchange3[CompA, CompB, CompC](w).Removes(C[Position]())
	posMap := NewMap1[Position](w)
	posVelMap := NewMap2[Position, Velocity](w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position) {
		pos.X = float64(cnt)
		cnt++
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity) {
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](w)
	cnt = 0
	exchange.ExchangeBatchFn(filter.Batch(), func(entity Entity, a *CompA, b *CompB, c *CompC) {
		a.X = float64(cnt)
		cnt++
		expectTrue(t, w.IsLocked())
	})

	filter2 := NewFilter1[CompA](w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		a := query.Get()
		expectEqual(t, float64(cnt), a.X)
		expectFalse(t, posMap.HasAll(query.Entity()))
		cnt++
	}
	expectEqual(t, 2*n, cnt)
}

func TestExchange4(t *testing.T) {
	w := NewWorld(16)

	posMap := NewMap2[Position, Velocity](w)
	mapper := NewMap4[CompA, CompB, CompC, CompD](w)

	var ex *Exchange4[CompA, CompB, CompC, CompD]
	ex = ex.New(w).Removes(C[Velocity](), C[Position]())

	e := posMap.NewEntity(&Position{}, &Velocity{})

	ex.Exchange(e, &CompA{}, &CompB{}, &CompC{}, &CompD{})
	expectFalse(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))

	e = posMap.NewEntity(&Position{}, &Velocity{})
	ex.ExchangeFn(e, func(a *CompA, b *CompB, c *CompC, d *CompD) {
		a.X = 100
	})
	expectFalse(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))
}

func TestExchange4Add(t *testing.T) {
	w := NewWorld(16)

	posMap := NewMap2[Position, Velocity](w)
	mapper := NewMap4[CompA, CompB, CompC, CompD](w)
	ex := NewExchange4[CompA, CompB, CompC, CompD](w).Removes(C[Velocity](), C[Position]())

	e := posMap.NewEntity(&Position{}, &Velocity{})

	ex.Add(e, &CompA{}, &CompB{}, &CompC{}, &CompD{})
	expectTrue(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))

	e = posMap.NewEntity(&Position{}, &Velocity{})

	ex.AddFn(e, func(a *CompA, b *CompB, c *CompC, d *CompD) {
		a.X = 100
	})
	expectTrue(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))
}

func TestExchange4Relations(t *testing.T) {
	w := NewWorld(8)

	Observe(OnAddRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(w)
	Observe(OnRemoveRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(w)

	ex := NewExchange4[ChildOf, CompB, CompC, CompD](w).Removes(C[Position]())
	mapper1 := NewMap1[ChildOf](w)
	mapper2 := NewMap1[Position](w)

	parent1 := w.NewEntity()

	e1 := w.NewEntity()
	ex.Add(e1, &ChildOf{}, &CompB{}, &CompC{}, &CompD{}, RelIdx(0, parent1))
	expectEqual(t, parent1, mapper1.GetRelation(e1, 0))
	expectEqual(t, parent1, mapper1.GetRelationUnchecked(e1, 0))

	e2 := mapper2.NewEntity(&Position{})
	ex.Exchange(e2, &ChildOf{}, &CompB{}, &CompC{}, &CompD{}, RelIdx(0, parent1))
	expectEqual(t, parent1, mapper1.GetRelation(e2, 0))
	expectEqual(t, parent1, mapper1.GetRelationUnchecked(e2, 0))
}

func TestExchange4Remove(t *testing.T) {
	w := NewWorld(16)

	posMap := NewMap2[Position, Velocity](w)
	mapper := NewMap4[CompA, CompB, CompC, CompD](w)
	ex := NewExchange4[CompA, CompB, CompC, CompD](w).Removes(C[Velocity](), C[Position]())

	e := posMap.NewEntity(&Position{}, &Velocity{})

	ex.Remove(e)
	expectFalse(t, posMap.HasAll(e))
	expectFalse(t, mapper.HasAll(e))
}

func TestExchange4AddBatch(t *testing.T) {
	n := 12
	w := NewWorld(8)

	Observe(OnAddComponents).For(C[Heading]()).Do(func(e Entity) {}).Register(w)
	Observe(OnRemoveComponents).For(C[Heading]()).Do(func(e Entity) {}).Register(w)
	Observe(OnAddRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(w)
	Observe(OnRemoveRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(w)

	exchange := NewExchange4[CompA, CompB, CompC, CompD](w).Removes(C[CompA]())
	posMap := NewMap1[Position](w)
	posVelMap := NewMap2[Position, Velocity](w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position) {
		pos.X = float64(cnt)
		cnt++
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity) {
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](w)
	exchange.AddBatch(filter.Batch(), &CompA{}, &CompB{}, &CompC{}, &CompD{})

	filter2 := NewFilter1[CompA](w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		pos := posMap.Get(query.Entity())
		expectGreater(t, pos.X, 0.0)
		cnt++
	}
	expectEqual(t, 2*n, cnt)

	exchange.RemoveBatch(filter2.Batch(), nil)

	query = filter2.Query()
	cnt = 0
	for query.Next() {
		cnt++
	}
	expectEqual(t, 0, cnt)
}

func TestExchange4AddBatchFn(t *testing.T) {
	n := 12
	w := NewWorld(8)

	exchange := NewExchange4[CompA, CompB, CompC, CompD](w).Removes(C[CompA]())
	posMap := NewMap1[Position](w)
	posVelMap := NewMap2[Position, Velocity](w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position) {
		pos.X = float64(cnt)
		cnt++
		expectTrue(t, w.IsLocked())
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity) {
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](w)
	cnt = 0
	exchange.AddBatchFn(filter.Batch(), func(entity Entity, a *CompA, b *CompB, c *CompC, d *CompD) {
		a.X = float64(cnt)
		cnt++
		expectTrue(t, w.IsLocked())
	})

	filter2 := NewFilter1[CompA](w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		a := query.Get()
		expectEqual(t, float64(cnt), a.X)
		pos := posMap.Get(query.Entity())
		expectGreater(t, pos.X, 0.0)
		cnt++
	}
	expectEqual(t, 2*n, cnt)

	cnt = 0
	exchange.RemoveBatch(filter2.Batch(), func(entity Entity) {
		cnt++
	})
	expectEqual(t, 2*n, cnt)

	query = filter2.Query()
	cnt = 0
	for query.Next() {
		cnt++
	}
	expectEqual(t, 0, cnt)
}

func TestExchange4ExchangeBatch(t *testing.T) {
	n := 12
	w := NewWorld(8)

	exchange := NewExchange4[CompA, CompB, CompC, CompD](w).Removes(C[Position]())
	posMap := NewMap1[Position](w)
	posVelMap := NewMap2[Position, Velocity](w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position) {
		pos.X = float64(cnt)
		cnt++
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity) {
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](w)
	exchange.ExchangeBatch(filter.Batch(), &CompA{}, &CompB{}, &CompC{}, &CompD{})

	filter2 := NewFilter1[CompA](w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		expectFalse(t, posMap.HasAll(query.Entity()))
		cnt++
	}
	expectEqual(t, 2*n, cnt)
}

func TestExchange4ExchangeBatchFn(t *testing.T) {
	n := 12
	w := NewWorld(8)

	exchange := NewExchange4[CompA, CompB, CompC, CompD](w).Removes(C[Position]())
	posMap := NewMap1[Position](w)
	posVelMap := NewMap2[Position, Velocity](w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position) {
		pos.X = float64(cnt)
		cnt++
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity) {
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](w)
	cnt = 0
	exchange.ExchangeBatchFn(filter.Batch(), func(entity Entity, a *CompA, b *CompB, c *CompC, d *CompD) {
		a.X = float64(cnt)
		cnt++
		expectTrue(t, w.IsLocked())
	})

	filter2 := NewFilter1[CompA](w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		a := query.Get()
		expectEqual(t, float64(cnt), a.X)
		expectFalse(t, posMap.HasAll(query.Entity()))
		cnt++
	}
	expectEqual(t, 2*n, cnt)
}

func TestExchange5(t *testing.T) {
	w := NewWorld(16)

	posMap := NewMap2[Position, Velocity](w)
	mapper := NewMap5[CompA, CompB, CompC, CompD, CompE](w)

	var ex *Exchange5[CompA, CompB, CompC, CompD, CompE]
	ex = ex.New(w).Removes(C[Velocity](), C[Position]())

	e := posMap.NewEntity(&Position{}, &Velocity{})

	ex.Exchange(e, &CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{})
	expectFalse(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))

	e = posMap.NewEntity(&Position{}, &Velocity{})
	ex.ExchangeFn(e, func(a *CompA, b *CompB, c *CompC, d *CompD, e *CompE) {
		a.X = 100
	})
	expectFalse(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))
}

func TestExchange5Add(t *testing.T) {
	w := NewWorld(16)

	posMap := NewMap2[Position, Velocity](w)
	mapper := NewMap5[CompA, CompB, CompC, CompD, CompE](w)
	ex := NewExchange5[CompA, CompB, CompC, CompD, CompE](w).Removes(C[Velocity](), C[Position]())

	e := posMap.NewEntity(&Position{}, &Velocity{})

	ex.Add(e, &CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{})
	expectTrue(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))

	e = posMap.NewEntity(&Position{}, &Velocity{})

	ex.AddFn(e, func(a *CompA, b *CompB, c *CompC, d *CompD, e *CompE) {
		a.X = 100
	})
	expectTrue(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))
}

func TestExchange5Relations(t *testing.T) {
	w := NewWorld(8)

	Observe(OnAddRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(w)
	Observe(OnRemoveRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(w)

	ex := NewExchange5[ChildOf, CompB, CompC, CompD, CompE](w).Removes(C[Position]())
	mapper1 := NewMap1[ChildOf](w)
	mapper2 := NewMap1[Position](w)

	parent1 := w.NewEntity()

	e1 := w.NewEntity()
	ex.Add(e1, &ChildOf{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, RelIdx(0, parent1))
	expectEqual(t, parent1, mapper1.GetRelation(e1, 0))
	expectEqual(t, parent1, mapper1.GetRelationUnchecked(e1, 0))

	e2 := mapper2.NewEntity(&Position{})
	ex.Exchange(e2, &ChildOf{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, RelIdx(0, parent1))
	expectEqual(t, parent1, mapper1.GetRelation(e2, 0))
	expectEqual(t, parent1, mapper1.GetRelationUnchecked(e2, 0))
}

func TestExchange5Remove(t *testing.T) {
	w := NewWorld(16)

	posMap := NewMap2[Position, Velocity](w)
	mapper := NewMap5[CompA, CompB, CompC, CompD, CompE](w)
	ex := NewExchange5[CompA, CompB, CompC, CompD, CompE](w).Removes(C[Velocity](), C[Position]())

	e := posMap.NewEntity(&Position{}, &Velocity{})

	ex.Remove(e)
	expectFalse(t, posMap.HasAll(e))
	expectFalse(t, mapper.HasAll(e))
}

func TestExchange5AddBatch(t *testing.T) {
	n := 12
	w := NewWorld(8)

	Observe(OnAddComponents).For(C[Heading]()).Do(func(e Entity) {}).Register(w)
	Observe(OnRemoveComponents).For(C[Heading]()).Do(func(e Entity) {}).Register(w)
	Observe(OnAddRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(w)
	Observe(OnRemoveRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(w)

	exchange := NewExchange5[CompA, CompB, CompC, CompD, CompE](w).Removes(C[CompA]())
	posMap := NewMap1[Position](w)
	posVelMap := NewMap2[Position, Velocity](w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position) {
		pos.X = float64(cnt)
		cnt++
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity) {
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](w)
	exchange.AddBatch(filter.Batch(), &CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{})

	filter2 := NewFilter1[CompA](w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		pos := posMap.Get(query.Entity())
		expectGreater(t, pos.X, 0.0)
		cnt++
	}
	expectEqual(t, 2*n, cnt)

	exchange.RemoveBatch(filter2.Batch(), nil)

	query = filter2.Query()
	cnt = 0
	for query.Next() {
		cnt++
	}
	expectEqual(t, 0, cnt)
}

func TestExchange5AddBatchFn(t *testing.T) {
	n := 12
	w := NewWorld(8)

	exchange := NewExchange5[CompA, CompB, CompC, CompD, CompE](w).Removes(C[CompA]())
	posMap := NewMap1[Position](w)
	posVelMap := NewMap2[Position, Velocity](w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position) {
		pos.X = float64(cnt)
		cnt++
		expectTrue(t, w.IsLocked())
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity) {
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](w)
	cnt = 0
	exchange.AddBatchFn(filter.Batch(), func(entity Entity, a *CompA, b *CompB, c *CompC, d *CompD, e *CompE) {
		a.X = float64(cnt)
		cnt++
		expectTrue(t, w.IsLocked())
	})

	filter2 := NewFilter1[CompA](w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		a := query.Get()
		expectEqual(t, float64(cnt), a.X)
		pos := posMap.Get(query.Entity())
		expectGreater(t, pos.X, 0.0)
		cnt++
	}
	expectEqual(t, 2*n, cnt)

	cnt = 0
	exchange.RemoveBatch(filter2.Batch(), func(entity Entity) {
		cnt++
	})
	expectEqual(t, 2*n, cnt)

	query = filter2.Query()
	cnt = 0
	for query.Next() {
		cnt++
	}
	expectEqual(t, 0, cnt)
}

func TestExchange5ExchangeBatch(t *testing.T) {
	n := 12
	w := NewWorld(8)

	exchange := NewExchange5[CompA, CompB, CompC, CompD, CompE](w).Removes(C[Position]())
	posMap := NewMap1[Position](w)
	posVelMap := NewMap2[Position, Velocity](w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position) {
		pos.X = float64(cnt)
		cnt++
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity) {
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](w)
	exchange.ExchangeBatch(filter.Batch(), &CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{})

	filter2 := NewFilter1[CompA](w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		expectFalse(t, posMap.HasAll(query.Entity()))
		cnt++
	}
	expectEqual(t, 2*n, cnt)
}

func TestExchange5ExchangeBatchFn(t *testing.T) {
	n := 12
	w := NewWorld(8)

	exchange := NewExchange5[CompA, CompB, CompC, CompD, CompE](w).Removes(C[Position]())
	posMap := NewMap1[Position](w)
	posVelMap := NewMap2[Position, Velocity](w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position) {
		pos.X = float64(cnt)
		cnt++
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity) {
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](w)
	cnt = 0
	exchange.ExchangeBatchFn(filter.Batch(), func(entity Entity, a *CompA, b *CompB, c *CompC, d *CompD, e *CompE) {
		a.X = float64(cnt)
		cnt++
		expectTrue(t, w.IsLocked())
	})

	filter2 := NewFilter1[CompA](w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		a := query.Get()
		expectEqual(t, float64(cnt), a.X)
		expectFalse(t, posMap.HasAll(query.Entity()))
		cnt++
	}
	expectEqual(t, 2*n, cnt)
}

func TestExchange6(t *testing.T) {
	w := NewWorld(16)

	posMap := NewMap2[Position, Velocity](w)
	mapper := NewMap6[CompA, CompB, CompC, CompD, CompE, CompF](w)

	var ex *Exchange6[CompA, CompB, CompC, CompD, CompE, CompF]
	ex = ex.New(w).Removes(C[Velocity](), C[Position]())

	e := posMap.NewEntity(&Position{}, &Velocity{})

	ex.Exchange(e, &CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{})
	expectFalse(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))

	e = posMap.NewEntity(&Position{}, &Velocity{})
	ex.ExchangeFn(e, func(a *CompA, b *CompB, c *CompC, d *CompD, e *CompE, f *CompF) {
		a.X = 100
	})
	expectFalse(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))
}

func TestExchange6Add(t *testing.T) {
	w := NewWorld(16)

	posMap := NewMap2[Position, Velocity](w)
	mapper := NewMap6[CompA, CompB, CompC, CompD, CompE, CompF](w)
	ex := NewExchange6[CompA, CompB, CompC, CompD, CompE, CompF](w).Removes(C[Velocity](), C[Position]())

	e := posMap.NewEntity(&Position{}, &Velocity{})

	ex.Add(e, &CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{})
	expectTrue(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))

	e = posMap.NewEntity(&Position{}, &Velocity{})

	ex.AddFn(e, func(a *CompA, b *CompB, c *CompC, d *CompD, e *CompE, f *CompF) {
		a.X = 100
	})
	expectTrue(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))
}

func TestExchange6Relations(t *testing.T) {
	w := NewWorld(8)

	Observe(OnAddRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(w)
	Observe(OnRemoveRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(w)

	ex := NewExchange6[ChildOf, CompB, CompC, CompD, CompE, CompF](w).Removes(C[Position]())
	mapper1 := NewMap1[ChildOf](w)
	mapper2 := NewMap1[Position](w)

	parent1 := w.NewEntity()

	e1 := w.NewEntity()
	ex.Add(e1, &ChildOf{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{}, RelIdx(0, parent1))
	expectEqual(t, parent1, mapper1.GetRelation(e1, 0))
	expectEqual(t, parent1, mapper1.GetRelationUnchecked(e1, 0))

	e2 := mapper2.NewEntity(&Position{})
	ex.Exchange(e2, &ChildOf{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{}, RelIdx(0, parent1))
	expectEqual(t, parent1, mapper1.GetRelation(e2, 0))
	expectEqual(t, parent1, mapper1.GetRelationUnchecked(e2, 0))
}

func TestExchange6Remove(t *testing.T) {
	w := NewWorld(16)

	posMap := NewMap2[Position, Velocity](w)
	mapper := NewMap6[CompA, CompB, CompC, CompD, CompE, CompF](w)
	ex := NewExchange6[CompA, CompB, CompC, CompD, CompE, CompF](w).Removes(C[Velocity](), C[Position]())

	e := posMap.NewEntity(&Position{}, &Velocity{})

	ex.Remove(e)
	expectFalse(t, posMap.HasAll(e))
	expectFalse(t, mapper.HasAll(e))
}

func TestExchange6AddBatch(t *testing.T) {
	n := 12
	w := NewWorld(8)

	Observe(OnAddComponents).For(C[Heading]()).Do(func(e Entity) {}).Register(w)
	Observe(OnRemoveComponents).For(C[Heading]()).Do(func(e Entity) {}).Register(w)
	Observe(OnAddRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(w)
	Observe(OnRemoveRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(w)

	exchange := NewExchange6[CompA, CompB, CompC, CompD, CompE, CompF](w).Removes(C[CompA]())
	posMap := NewMap1[Position](w)
	posVelMap := NewMap2[Position, Velocity](w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position) {
		pos.X = float64(cnt)
		cnt++
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity) {
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](w)
	exchange.AddBatch(filter.Batch(), &CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{})

	filter2 := NewFilter1[CompA](w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		pos := posMap.Get(query.Entity())
		expectGreater(t, pos.X, 0.0)
		cnt++
	}
	expectEqual(t, 2*n, cnt)

	exchange.RemoveBatch(filter2.Batch(), nil)

	query = filter2.Query()
	cnt = 0
	for query.Next() {
		cnt++
	}
	expectEqual(t, 0, cnt)
}

func TestExchange6AddBatchFn(t *testing.T) {
	n := 12
	w := NewWorld(8)

	exchange := NewExchange6[CompA, CompB, CompC, CompD, CompE, CompF](w).Removes(C[CompA]())
	posMap := NewMap1[Position](w)
	posVelMap := NewMap2[Position, Velocity](w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position) {
		pos.X = float64(cnt)
		cnt++
		expectTrue(t, w.IsLocked())
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity) {
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](w)
	cnt = 0
	exchange.AddBatchFn(filter.Batch(), func(entity Entity, a *CompA, b *CompB, c *CompC, d *CompD, e *CompE, f *CompF) {
		a.X = float64(cnt)
		cnt++
		expectTrue(t, w.IsLocked())
	})

	filter2 := NewFilter1[CompA](w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		a := query.Get()
		expectEqual(t, float64(cnt), a.X)
		pos := posMap.Get(query.Entity())
		expectGreater(t, pos.X, 0.0)
		cnt++
	}
	expectEqual(t, 2*n, cnt)

	cnt = 0
	exchange.RemoveBatch(filter2.Batch(), func(entity Entity) {
		cnt++
	})
	expectEqual(t, 2*n, cnt)

	query = filter2.Query()
	cnt = 0
	for query.Next() {
		cnt++
	}
	expectEqual(t, 0, cnt)
}

func TestExchange6ExchangeBatch(t *testing.T) {
	n := 12
	w := NewWorld(8)

	exchange := NewExchange6[CompA, CompB, CompC, CompD, CompE, CompF](w).Removes(C[Position]())
	posMap := NewMap1[Position](w)
	posVelMap := NewMap2[Position, Velocity](w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position) {
		pos.X = float64(cnt)
		cnt++
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity) {
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](w)
	exchange.ExchangeBatch(filter.Batch(), &CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{})

	filter2 := NewFilter1[CompA](w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		expectFalse(t, posMap.HasAll(query.Entity()))
		cnt++
	}
	expectEqual(t, 2*n, cnt)
}

func TestExchange6ExchangeBatchFn(t *testing.T) {
	n := 12
	w := NewWorld(8)

	exchange := NewExchange6[CompA, CompB, CompC, CompD, CompE, CompF](w).Removes(C[Position]())
	posMap := NewMap1[Position](w)
	posVelMap := NewMap2[Position, Velocity](w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position) {
		pos.X = float64(cnt)
		cnt++
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity) {
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](w)
	cnt = 0
	exchange.ExchangeBatchFn(filter.Batch(), func(entity Entity, a *CompA, b *CompB, c *CompC, d *CompD, e *CompE, f *CompF) {
		a.X = float64(cnt)
		cnt++
		expectTrue(t, w.IsLocked())
	})

	filter2 := NewFilter1[CompA](w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		a := query.Get()
		expectEqual(t, float64(cnt), a.X)
		expectFalse(t, posMap.HasAll(query.Entity()))
		cnt++
	}
	expectEqual(t, 2*n, cnt)
}

func TestExchange7(t *testing.T) {
	w := NewWorld(16)

	posMap := NewMap2[Position, Velocity](w)
	mapper := NewMap7[CompA, CompB, CompC, CompD, CompE, CompF, CompG](w)

	var ex *Exchange7[CompA, CompB, CompC, CompD, CompE, CompF, CompG]
	ex = ex.New(w).Removes(C[Velocity](), C[Position]())

	e := posMap.NewEntity(&Position{}, &Velocity{})

	ex.Exchange(e, &CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{}, &CompG{})
	expectFalse(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))

	e = posMap.NewEntity(&Position{}, &Velocity{})
	ex.ExchangeFn(e, func(a *CompA, b *CompB, c *CompC, d *CompD, e *CompE, f *CompF, g *CompG) {
		a.X = 100
	})
	expectFalse(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))
}

func TestExchange7Add(t *testing.T) {
	w := NewWorld(16)

	posMap := NewMap2[Position, Velocity](w)
	mapper := NewMap7[CompA, CompB, CompC, CompD, CompE, CompF, CompG](w)
	ex := NewExchange7[CompA, CompB, CompC, CompD, CompE, CompF, CompG](w).Removes(C[Velocity](), C[Position]())

	e := posMap.NewEntity(&Position{}, &Velocity{})

	ex.Add(e, &CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{}, &CompG{})
	expectTrue(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))

	e = posMap.NewEntity(&Position{}, &Velocity{})

	ex.AddFn(e, func(a *CompA, b *CompB, c *CompC, d *CompD, e *CompE, f *CompF, g *CompG) {
		a.X = 100
	})
	expectTrue(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))
}

func TestExchange7Relations(t *testing.T) {
	w := NewWorld(8)

	Observe(OnAddRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(w)
	Observe(OnRemoveRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(w)

	ex := NewExchange7[ChildOf, CompB, CompC, CompD, CompE, CompF, CompG](w).Removes(C[Position]())
	mapper1 := NewMap1[ChildOf](w)
	mapper2 := NewMap1[Position](w)

	parent1 := w.NewEntity()

	e1 := w.NewEntity()
	ex.Add(e1, &ChildOf{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{}, &CompG{}, RelIdx(0, parent1))
	expectEqual(t, parent1, mapper1.GetRelation(e1, 0))
	expectEqual(t, parent1, mapper1.GetRelationUnchecked(e1, 0))

	e2 := mapper2.NewEntity(&Position{})
	ex.Exchange(e2, &ChildOf{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{}, &CompG{}, RelIdx(0, parent1))
	expectEqual(t, parent1, mapper1.GetRelation(e2, 0))
	expectEqual(t, parent1, mapper1.GetRelationUnchecked(e2, 0))
}

func TestExchange7Remove(t *testing.T) {
	w := NewWorld(16)

	posMap := NewMap2[Position, Velocity](w)
	mapper := NewMap7[CompA, CompB, CompC, CompD, CompE, CompF, CompG](w)
	ex := NewExchange7[CompA, CompB, CompC, CompD, CompE, CompF, CompG](w).Removes(C[Velocity](), C[Position]())

	e := posMap.NewEntity(&Position{}, &Velocity{})

	ex.Remove(e)
	expectFalse(t, posMap.HasAll(e))
	expectFalse(t, mapper.HasAll(e))
}

func TestExchange7AddBatch(t *testing.T) {
	n := 12
	w := NewWorld(8)

	Observe(OnAddComponents).For(C[Heading]()).Do(func(e Entity) {}).Register(w)
	Observe(OnRemoveComponents).For(C[Heading]()).Do(func(e Entity) {}).Register(w)
	Observe(OnAddRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(w)
	Observe(OnRemoveRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(w)

	exchange := NewExchange7[CompA, CompB, CompC, CompD, CompE, CompF, CompG](w).Removes(C[CompA]())
	posMap := NewMap1[Position](w)
	posVelMap := NewMap2[Position, Velocity](w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position) {
		pos.X = float64(cnt)
		cnt++
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity) {
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](w)
	exchange.AddBatch(filter.Batch(), &CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{}, &CompG{})

	filter2 := NewFilter1[CompA](w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		pos := posMap.Get(query.Entity())
		expectGreater(t, pos.X, 0.0)
		cnt++
	}
	expectEqual(t, 2*n, cnt)

	exchange.RemoveBatch(filter2.Batch(), nil)

	query = filter2.Query()
	cnt = 0
	for query.Next() {
		cnt++
	}
	expectEqual(t, 0, cnt)
}

func TestExchange7AddBatchFn(t *testing.T) {
	n := 12
	w := NewWorld(8)

	exchange := NewExchange7[CompA, CompB, CompC, CompD, CompE, CompF, CompG](w).Removes(C[CompA]())
	posMap := NewMap1[Position](w)
	posVelMap := NewMap2[Position, Velocity](w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position) {
		pos.X = float64(cnt)
		cnt++
		expectTrue(t, w.IsLocked())
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity) {
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](w)
	cnt = 0
	exchange.AddBatchFn(filter.Batch(), func(entity Entity, a *CompA, b *CompB, c *CompC, d *CompD, e *CompE, f *CompF, g *CompG) {
		a.X = float64(cnt)
		cnt++
		expectTrue(t, w.IsLocked())
	})

	filter2 := NewFilter1[CompA](w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		a := query.Get()
		expectEqual(t, float64(cnt), a.X)
		pos := posMap.Get(query.Entity())
		expectGreater(t, pos.X, 0.0)
		cnt++
	}
	expectEqual(t, 2*n, cnt)

	cnt = 0
	exchange.RemoveBatch(filter2.Batch(), func(entity Entity) {
		cnt++
	})
	expectEqual(t, 2*n, cnt)

	query = filter2.Query()
	cnt = 0
	for query.Next() {
		cnt++
	}
	expectEqual(t, 0, cnt)
}

func TestExchange7ExchangeBatch(t *testing.T) {
	n := 12
	w := NewWorld(8)

	exchange := NewExchange7[CompA, CompB, CompC, CompD, CompE, CompF, CompG](w).Removes(C[Position]())
	posMap := NewMap1[Position](w)
	posVelMap := NewMap2[Position, Velocity](w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position) {
		pos.X = float64(cnt)
		cnt++
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity) {
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](w)
	exchange.ExchangeBatch(filter.Batch(), &CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{}, &CompG{})

	filter2 := NewFilter1[CompA](w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		expectFalse(t, posMap.HasAll(query.Entity()))
		cnt++
	}
	expectEqual(t, 2*n, cnt)
}

func TestExchange7ExchangeBatchFn(t *testing.T) {
	n := 12
	w := NewWorld(8)

	exchange := NewExchange7[CompA, CompB, CompC, CompD, CompE, CompF, CompG](w).Removes(C[Position]())
	posMap := NewMap1[Position](w)
	posVelMap := NewMap2[Position, Velocity](w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position) {
		pos.X = float64(cnt)
		cnt++
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity) {
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](w)
	cnt = 0
	exchange.ExchangeBatchFn(filter.Batch(), func(entity Entity, a *CompA, b *CompB, c *CompC, d *CompD, e *CompE, f *CompF, g *CompG) {
		a.X = float64(cnt)
		cnt++
		expectTrue(t, w.IsLocked())
	})

	filter2 := NewFilter1[CompA](w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		a := query.Get()
		expectEqual(t, float64(cnt), a.X)
		expectFalse(t, posMap.HasAll(query.Entity()))
		cnt++
	}
	expectEqual(t, 2*n, cnt)
}

func TestExchange8(t *testing.T) {
	w := NewWorld(16)

	posMap := NewMap2[Position, Velocity](w)
	mapper := NewMap8[CompA, CompB, CompC, CompD, CompE, CompF, CompG, CompH](w)

	var ex *Exchange8[CompA, CompB, CompC, CompD, CompE, CompF, CompG, CompH]
	ex = ex.New(w).Removes(C[Velocity](), C[Position]())

	e := posMap.NewEntity(&Position{}, &Velocity{})

	ex.Exchange(e, &CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{}, &CompG{}, &CompH{})
	expectFalse(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))

	e = posMap.NewEntity(&Position{}, &Velocity{})
	ex.ExchangeFn(e, func(a *CompA, b *CompB, c *CompC, d *CompD, e *CompE, f *CompF, g *CompG, h *CompH) {
		a.X = 100
	})
	expectFalse(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))
}

func TestExchange8Add(t *testing.T) {
	w := NewWorld(16)

	posMap := NewMap2[Position, Velocity](w)
	mapper := NewMap8[CompA, CompB, CompC, CompD, CompE, CompF, CompG, CompH](w)
	ex := NewExchange8[CompA, CompB, CompC, CompD, CompE, CompF, CompG, CompH](w).Removes(C[Velocity](), C[Position]())

	e := posMap.NewEntity(&Position{}, &Velocity{})

	ex.Add(e, &CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{}, &CompG{}, &CompH{})
	expectTrue(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))

	e = posMap.NewEntity(&Position{}, &Velocity{})

	ex.AddFn(e, func(a *CompA, b *CompB, c *CompC, d *CompD, e *CompE, f *CompF, g *CompG, h *CompH) {
		a.X = 100
	})
	expectTrue(t, posMap.HasAll(e))
	expectTrue(t, mapper.HasAll(e))
}

func TestExchange8Relations(t *testing.T) {
	w := NewWorld(8)

	Observe(OnAddRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(w)
	Observe(OnRemoveRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(w)

	ex := NewExchange8[ChildOf, CompB, CompC, CompD, CompE, CompF, CompG, CompH](w).Removes(C[Position]())
	mapper1 := NewMap1[ChildOf](w)
	mapper2 := NewMap1[Position](w)

	parent1 := w.NewEntity()

	e1 := w.NewEntity()
	ex.Add(e1, &ChildOf{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{}, &CompG{}, &CompH{}, RelIdx(0, parent1))
	expectEqual(t, parent1, mapper1.GetRelation(e1, 0))
	expectEqual(t, parent1, mapper1.GetRelationUnchecked(e1, 0))

	e2 := mapper2.NewEntity(&Position{})
	ex.Exchange(e2, &ChildOf{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{}, &CompG{}, &CompH{}, RelIdx(0, parent1))
	expectEqual(t, parent1, mapper1.GetRelation(e2, 0))
	expectEqual(t, parent1, mapper1.GetRelationUnchecked(e2, 0))
}

func TestExchange8Remove(t *testing.T) {
	w := NewWorld(16)

	posMap := NewMap2[Position, Velocity](w)
	mapper := NewMap8[CompA, CompB, CompC, CompD, CompE, CompF, CompG, CompH](w)
	ex := NewExchange8[CompA, CompB, CompC, CompD, CompE, CompF, CompG, CompH](w).Removes(C[Velocity](), C[Position]())

	e := posMap.NewEntity(&Position{}, &Velocity{})

	ex.Remove(e)
	expectFalse(t, posMap.HasAll(e))
	expectFalse(t, mapper.HasAll(e))
}

func TestExchange8AddBatch(t *testing.T) {
	n := 12
	w := NewWorld(8)

	Observe(OnAddComponents).For(C[Heading]()).Do(func(e Entity) {}).Register(w)
	Observe(OnRemoveComponents).For(C[Heading]()).Do(func(e Entity) {}).Register(w)
	Observe(OnAddRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(w)
	Observe(OnRemoveRelations).For(C[ChildOf2]()).Do(func(_ Entity) {}).Register(w)

	exchange := NewExchange8[CompA, CompB, CompC, CompD, CompE, CompF, CompG, CompH](w).Removes(C[CompA]())
	posMap := NewMap1[Position](w)
	posVelMap := NewMap2[Position, Velocity](w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position) {
		pos.X = float64(cnt)
		cnt++
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity) {
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](w)
	exchange.AddBatch(filter.Batch(), &CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{}, &CompG{}, &CompH{})

	filter2 := NewFilter1[CompA](w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		pos := posMap.Get(query.Entity())
		expectGreater(t, pos.X, 0.0)
		cnt++
	}
	expectEqual(t, 2*n, cnt)

	exchange.RemoveBatch(filter2.Batch(), nil)

	query = filter2.Query()
	cnt = 0
	for query.Next() {
		cnt++
	}
	expectEqual(t, 0, cnt)
}

func TestExchange8AddBatchFn(t *testing.T) {
	n := 12
	w := NewWorld(8)

	exchange := NewExchange8[CompA, CompB, CompC, CompD, CompE, CompF, CompG, CompH](w).Removes(C[CompA]())
	posMap := NewMap1[Position](w)
	posVelMap := NewMap2[Position, Velocity](w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position) {
		pos.X = float64(cnt)
		cnt++
		expectTrue(t, w.IsLocked())
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity) {
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](w)
	cnt = 0
	exchange.AddBatchFn(filter.Batch(), func(entity Entity, a *CompA, b *CompB, c *CompC, d *CompD, e *CompE, f *CompF, g *CompG, h *CompH) {
		a.X = float64(cnt)
		cnt++
		expectTrue(t, w.IsLocked())
	})

	filter2 := NewFilter1[CompA](w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		a := query.Get()
		expectEqual(t, float64(cnt), a.X)
		pos := posMap.Get(query.Entity())
		expectGreater(t, pos.X, 0.0)
		cnt++
	}
	expectEqual(t, 2*n, cnt)

	cnt = 0
	exchange.RemoveBatch(filter2.Batch(), func(entity Entity) {
		cnt++
	})
	expectEqual(t, 2*n, cnt)

	query = filter2.Query()
	cnt = 0
	for query.Next() {
		cnt++
	}
	expectEqual(t, 0, cnt)
}

func TestExchange8ExchangeBatch(t *testing.T) {
	n := 12
	w := NewWorld(8)

	exchange := NewExchange8[CompA, CompB, CompC, CompD, CompE, CompF, CompG, CompH](w).Removes(C[Position]())
	posMap := NewMap1[Position](w)
	posVelMap := NewMap2[Position, Velocity](w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position) {
		pos.X = float64(cnt)
		cnt++
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity) {
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](w)
	exchange.ExchangeBatch(filter.Batch(), &CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{}, &CompG{}, &CompH{})

	filter2 := NewFilter1[CompA](w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		expectFalse(t, posMap.HasAll(query.Entity()))
		cnt++
	}
	expectEqual(t, 2*n, cnt)
}

func TestExchange8ExchangeBatchFn(t *testing.T) {
	n := 12
	w := NewWorld(8)

	exchange := NewExchange8[CompA, CompB, CompC, CompD, CompE, CompF, CompG, CompH](w).Removes(C[Position]())
	posMap := NewMap1[Position](w)
	posVelMap := NewMap2[Position, Velocity](w)

	cnt := 1
	posMap.NewBatchFn(n, func(entity Entity, pos *Position) {
		pos.X = float64(cnt)
		cnt++
	})
	posVelMap.NewBatchFn(n, func(entity Entity, pos *Position, _ *Velocity) {
		pos.X = float64(cnt)
		cnt++
	})
	expectEqual(t, 2*n+1, cnt)

	filter := NewFilter1[Position](w)
	cnt = 0
	exchange.ExchangeBatchFn(filter.Batch(), func(entity Entity, a *CompA, b *CompB, c *CompC, d *CompD, e *CompE, f *CompF, g *CompG, h *CompH) {
		a.X = float64(cnt)
		cnt++
		expectTrue(t, w.IsLocked())
	})

	filter2 := NewFilter1[CompA](w)
	query := filter2.Query()
	cnt = 0
	for query.Next() {
		a := query.Get()
		expectEqual(t, float64(cnt), a.X)
		expectFalse(t, posMap.HasAll(query.Entity()))
		cnt++
	}
	expectEqual(t, 2*n, cnt)
}
