package ecs

// Code generated by go generate; DO NOT EDIT.

import "unsafe"

// Exchange1 allows to exchange components of entities.
// It adds the given components. Use [Exchange1.Removes]
// to set components to be removed.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Exchange2] for a usage example.
type Exchange1[A any] struct {
	world     *World
	ids       []ID
	remove    []ID
	relations []RelationID
}

// NewExchange1 creates an [Exchange1].
func NewExchange1[A any](world *World) *Exchange1[A] {
	ids := []ID{
		ComponentID[A](world),
	}
	return &Exchange1[A]{
		world: world,
		ids:   ids,
	}
}

// Removes sets the components that this [Exchange1] removes.
// Can be called multiple times in chains, or once with multiple arguments.
func (ex *Exchange1[A]) Removes(components ...Comp) *Exchange1[A] {
	for _, c := range components {
		ex.remove = append(ex.remove, ex.world.componentID(c.tp))
	}
	return ex
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange1[A]) Add(entity Entity, a *A, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchange(entity, ex.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
	}, ex.relations)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange1[A]) AddFn(entity Entity, fn func(a *A), rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchange(entity, ex.ids, nil, nil, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
}

// Remove the components previously specified with [Exchange1.Removes] from the given entity.
func (ex *Exchange1[A]) Remove(entity Entity) {
	ex.world.exchange(entity, nil, ex.remove, nil, nil)
}

// Exchange performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange1.Removes].
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange1[A]) Exchange(entity Entity, a *A, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchange(entity, ex.ids, ex.remove, []unsafe.Pointer{
		unsafe.Pointer(a),
	}, ex.relations)
}

// ExchangeFn performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange1.Removes].
// It runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange1[A]) ExchangeFn(entity Entity, fn func(a *A), rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchange(entity, ex.ids, ex.remove, nil, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange1[A]) AddBatch(batch *Batch, a *A, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchangeBatch(batch, ex.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
	}, ex.relations, nil)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange1[A]) AddBatchFn(batch *Batch, fn func(entity Entity, a *A), rel ...Relation) {
	ex.exchangeBatchFn(batch, fn, false, rel...)
}

// RemoveBatch removes the components previously specified with [Exchange1.Removes]
// from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (ex *Exchange1[A]) RemoveBatch(batch *Batch, fn func(entity Entity)) {
	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &ex.world.storage.tables[tableID]

			lock := ex.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(table.GetEntity(index))
			}
			ex.world.unlock(lock)
		}
	}
	ex.world.exchangeBatch(batch, nil, ex.remove, nil, nil, process)
}

// ExchangeBatch performs the exchange on all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange1[A]) ExchangeBatch(batch *Batch, a *A, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchangeBatch(batch, ex.ids, ex.remove, []unsafe.Pointer{
		unsafe.Pointer(a),
	}, ex.relations, nil)
}

// ExchangeBatchFn performs the exchange on all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange1[A]) ExchangeBatchFn(batch *Batch, fn func(entity Entity, a *A), rel ...Relation) {
	ex.exchangeBatchFn(batch, fn, true, rel...)
}

func (ex *Exchange1[A]) exchangeBatchFn(batch *Batch, fn func(entity Entity, a *A), remove bool, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &ex.world.storage.tables[tableID]
			columnA := table.GetColumn(ex.ids[0])

			lock := ex.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
				)
			}
			ex.world.unlock(lock)
		}
	}
	if remove {
		ex.world.exchangeBatch(batch, ex.ids, ex.remove, nil, ex.relations, process)
	} else {
		ex.world.exchangeBatch(batch, ex.ids, nil, nil, ex.relations, process)
	}
}

func (ex *Exchange1[A]) runCallback(entity Entity, fn func(a *A)) {
	index := &ex.world.storage.entities[entity.id]
	table := &ex.world.storage.tables[index.table]
	row := uintptr(index.row)
	fn(
		(*A)(table.GetColumn(ex.ids[0]).Get(row)),
	)
}

// Exchange2 allows to exchange components of entities.
// It adds the given components. Use [Exchange2.Removes]
// to set components to be removed.
//
// Instances should be created during initialization and stored, e.g. in systems.
type Exchange2[A any, B any] struct {
	world     *World
	ids       []ID
	remove    []ID
	relations []RelationID
}

// NewExchange2 creates an [Exchange2].
func NewExchange2[A any, B any](world *World) *Exchange2[A, B] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
	}
	return &Exchange2[A, B]{
		world: world,
		ids:   ids,
	}
}

// Removes sets the components that this [Exchange2] removes.
// Can be called multiple times in chains, or once with multiple arguments.
func (ex *Exchange2[A, B]) Removes(components ...Comp) *Exchange2[A, B] {
	for _, c := range components {
		ex.remove = append(ex.remove, ex.world.componentID(c.tp))
	}
	return ex
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange2[A, B]) Add(entity Entity, a *A, b *B, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchange(entity, ex.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
	}, ex.relations)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange2[A, B]) AddFn(entity Entity, fn func(a *A, b *B), rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchange(entity, ex.ids, nil, nil, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
}

// Remove the components previously specified with [Exchange2.Removes] from the given entity.
func (ex *Exchange2[A, B]) Remove(entity Entity) {
	ex.world.exchange(entity, nil, ex.remove, nil, nil)
}

// Exchange performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange2.Removes].
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange2[A, B]) Exchange(entity Entity, a *A, b *B, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchange(entity, ex.ids, ex.remove, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
	}, ex.relations)
}

// ExchangeFn performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange2.Removes].
// It runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange2[A, B]) ExchangeFn(entity Entity, fn func(a *A, b *B), rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchange(entity, ex.ids, ex.remove, nil, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange2[A, B]) AddBatch(batch *Batch, a *A, b *B, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchangeBatch(batch, ex.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
	}, ex.relations, nil)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange2[A, B]) AddBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B), rel ...Relation) {
	ex.exchangeBatchFn(batch, fn, false, rel...)
}

// RemoveBatch removes the components previously specified with [Exchange2.Removes]
// from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (ex *Exchange2[A, B]) RemoveBatch(batch *Batch, fn func(entity Entity)) {
	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &ex.world.storage.tables[tableID]

			lock := ex.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(table.GetEntity(index))
			}
			ex.world.unlock(lock)
		}
	}
	ex.world.exchangeBatch(batch, nil, ex.remove, nil, nil, process)
}

// ExchangeBatch performs the exchange on all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange2[A, B]) ExchangeBatch(batch *Batch, a *A, b *B, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchangeBatch(batch, ex.ids, ex.remove, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
	}, ex.relations, nil)
}

// ExchangeBatchFn performs the exchange on all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange2[A, B]) ExchangeBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B), rel ...Relation) {
	ex.exchangeBatchFn(batch, fn, true, rel...)
}

func (ex *Exchange2[A, B]) exchangeBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B), remove bool, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &ex.world.storage.tables[tableID]
			columnA := table.GetColumn(ex.ids[0])
			columnB := table.GetColumn(ex.ids[1])

			lock := ex.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
				)
			}
			ex.world.unlock(lock)
		}
	}
	if remove {
		ex.world.exchangeBatch(batch, ex.ids, ex.remove, nil, ex.relations, process)
	} else {
		ex.world.exchangeBatch(batch, ex.ids, nil, nil, ex.relations, process)
	}
}

func (ex *Exchange2[A, B]) runCallback(entity Entity, fn func(a *A, b *B)) {
	index := &ex.world.storage.entities[entity.id]
	table := &ex.world.storage.tables[index.table]
	row := uintptr(index.row)
	fn(
		(*A)(table.GetColumn(ex.ids[0]).Get(row)),
		(*B)(table.GetColumn(ex.ids[1]).Get(row)),
	)
}

// Exchange3 allows to exchange components of entities.
// It adds the given components. Use [Exchange3.Removes]
// to set components to be removed.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Exchange2] for a usage example.
type Exchange3[A any, B any, C any] struct {
	world     *World
	ids       []ID
	remove    []ID
	relations []RelationID
}

// NewExchange3 creates an [Exchange3].
func NewExchange3[A any, B any, C any](world *World) *Exchange3[A, B, C] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
	}
	return &Exchange3[A, B, C]{
		world: world,
		ids:   ids,
	}
}

// Removes sets the components that this [Exchange3] removes.
// Can be called multiple times in chains, or once with multiple arguments.
func (ex *Exchange3[A, B, C]) Removes(components ...Comp) *Exchange3[A, B, C] {
	for _, c := range components {
		ex.remove = append(ex.remove, ex.world.componentID(c.tp))
	}
	return ex
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange3[A, B, C]) Add(entity Entity, a *A, b *B, c *C, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchange(entity, ex.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
	}, ex.relations)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange3[A, B, C]) AddFn(entity Entity, fn func(a *A, b *B, c *C), rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchange(entity, ex.ids, nil, nil, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
}

// Remove the components previously specified with [Exchange3.Removes] from the given entity.
func (ex *Exchange3[A, B, C]) Remove(entity Entity) {
	ex.world.exchange(entity, nil, ex.remove, nil, nil)
}

// Exchange performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange3.Removes].
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange3[A, B, C]) Exchange(entity Entity, a *A, b *B, c *C, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchange(entity, ex.ids, ex.remove, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
	}, ex.relations)
}

// ExchangeFn performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange3.Removes].
// It runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange3[A, B, C]) ExchangeFn(entity Entity, fn func(a *A, b *B, c *C), rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchange(entity, ex.ids, ex.remove, nil, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange3[A, B, C]) AddBatch(batch *Batch, a *A, b *B, c *C, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchangeBatch(batch, ex.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
	}, ex.relations, nil)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange3[A, B, C]) AddBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C), rel ...Relation) {
	ex.exchangeBatchFn(batch, fn, false, rel...)
}

// RemoveBatch removes the components previously specified with [Exchange3.Removes]
// from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (ex *Exchange3[A, B, C]) RemoveBatch(batch *Batch, fn func(entity Entity)) {
	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &ex.world.storage.tables[tableID]

			lock := ex.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(table.GetEntity(index))
			}
			ex.world.unlock(lock)
		}
	}
	ex.world.exchangeBatch(batch, nil, ex.remove, nil, nil, process)
}

// ExchangeBatch performs the exchange on all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange3[A, B, C]) ExchangeBatch(batch *Batch, a *A, b *B, c *C, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchangeBatch(batch, ex.ids, ex.remove, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
	}, ex.relations, nil)
}

// ExchangeBatchFn performs the exchange on all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange3[A, B, C]) ExchangeBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C), rel ...Relation) {
	ex.exchangeBatchFn(batch, fn, true, rel...)
}

func (ex *Exchange3[A, B, C]) exchangeBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C), remove bool, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &ex.world.storage.tables[tableID]
			columnA := table.GetColumn(ex.ids[0])
			columnB := table.GetColumn(ex.ids[1])
			columnC := table.GetColumn(ex.ids[2])

			lock := ex.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
				)
			}
			ex.world.unlock(lock)
		}
	}
	if remove {
		ex.world.exchangeBatch(batch, ex.ids, ex.remove, nil, ex.relations, process)
	} else {
		ex.world.exchangeBatch(batch, ex.ids, nil, nil, ex.relations, process)
	}
}

func (ex *Exchange3[A, B, C]) runCallback(entity Entity, fn func(a *A, b *B, c *C)) {
	index := &ex.world.storage.entities[entity.id]
	table := &ex.world.storage.tables[index.table]
	row := uintptr(index.row)
	fn(
		(*A)(table.GetColumn(ex.ids[0]).Get(row)),
		(*B)(table.GetColumn(ex.ids[1]).Get(row)),
		(*C)(table.GetColumn(ex.ids[2]).Get(row)),
	)
}

// Exchange4 allows to exchange components of entities.
// It adds the given components. Use [Exchange4.Removes]
// to set components to be removed.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Exchange2] for a usage example.
type Exchange4[A any, B any, C any, D any] struct {
	world     *World
	ids       []ID
	remove    []ID
	relations []RelationID
}

// NewExchange4 creates an [Exchange4].
func NewExchange4[A any, B any, C any, D any](world *World) *Exchange4[A, B, C, D] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
	}
	return &Exchange4[A, B, C, D]{
		world: world,
		ids:   ids,
	}
}

// Removes sets the components that this [Exchange4] removes.
// Can be called multiple times in chains, or once with multiple arguments.
func (ex *Exchange4[A, B, C, D]) Removes(components ...Comp) *Exchange4[A, B, C, D] {
	for _, c := range components {
		ex.remove = append(ex.remove, ex.world.componentID(c.tp))
	}
	return ex
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange4[A, B, C, D]) Add(entity Entity, a *A, b *B, c *C, d *D, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchange(entity, ex.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
	}, ex.relations)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange4[A, B, C, D]) AddFn(entity Entity, fn func(a *A, b *B, c *C, d *D), rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchange(entity, ex.ids, nil, nil, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
}

// Remove the components previously specified with [Exchange4.Removes] from the given entity.
func (ex *Exchange4[A, B, C, D]) Remove(entity Entity) {
	ex.world.exchange(entity, nil, ex.remove, nil, nil)
}

// Exchange performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange4.Removes].
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange4[A, B, C, D]) Exchange(entity Entity, a *A, b *B, c *C, d *D, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchange(entity, ex.ids, ex.remove, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
	}, ex.relations)
}

// ExchangeFn performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange4.Removes].
// It runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange4[A, B, C, D]) ExchangeFn(entity Entity, fn func(a *A, b *B, c *C, d *D), rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchange(entity, ex.ids, ex.remove, nil, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange4[A, B, C, D]) AddBatch(batch *Batch, a *A, b *B, c *C, d *D, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchangeBatch(batch, ex.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
	}, ex.relations, nil)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange4[A, B, C, D]) AddBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C, d *D), rel ...Relation) {
	ex.exchangeBatchFn(batch, fn, false, rel...)
}

// RemoveBatch removes the components previously specified with [Exchange4.Removes]
// from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (ex *Exchange4[A, B, C, D]) RemoveBatch(batch *Batch, fn func(entity Entity)) {
	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &ex.world.storage.tables[tableID]

			lock := ex.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(table.GetEntity(index))
			}
			ex.world.unlock(lock)
		}
	}
	ex.world.exchangeBatch(batch, nil, ex.remove, nil, nil, process)
}

// ExchangeBatch performs the exchange on all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange4[A, B, C, D]) ExchangeBatch(batch *Batch, a *A, b *B, c *C, d *D, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchangeBatch(batch, ex.ids, ex.remove, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
	}, ex.relations, nil)
}

// ExchangeBatchFn performs the exchange on all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange4[A, B, C, D]) ExchangeBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C, d *D), rel ...Relation) {
	ex.exchangeBatchFn(batch, fn, true, rel...)
}

func (ex *Exchange4[A, B, C, D]) exchangeBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C, d *D), remove bool, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &ex.world.storage.tables[tableID]
			columnA := table.GetColumn(ex.ids[0])
			columnB := table.GetColumn(ex.ids[1])
			columnC := table.GetColumn(ex.ids[2])
			columnD := table.GetColumn(ex.ids[3])

			lock := ex.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
					(*D)(columnD.Get(index)),
				)
			}
			ex.world.unlock(lock)
		}
	}
	if remove {
		ex.world.exchangeBatch(batch, ex.ids, ex.remove, nil, ex.relations, process)
	} else {
		ex.world.exchangeBatch(batch, ex.ids, nil, nil, ex.relations, process)
	}
}

func (ex *Exchange4[A, B, C, D]) runCallback(entity Entity, fn func(a *A, b *B, c *C, d *D)) {
	index := &ex.world.storage.entities[entity.id]
	table := &ex.world.storage.tables[index.table]
	row := uintptr(index.row)
	fn(
		(*A)(table.GetColumn(ex.ids[0]).Get(row)),
		(*B)(table.GetColumn(ex.ids[1]).Get(row)),
		(*C)(table.GetColumn(ex.ids[2]).Get(row)),
		(*D)(table.GetColumn(ex.ids[3]).Get(row)),
	)
}

// Exchange5 allows to exchange components of entities.
// It adds the given components. Use [Exchange5.Removes]
// to set components to be removed.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Exchange2] for a usage example.
type Exchange5[A any, B any, C any, D any, E any] struct {
	world     *World
	ids       []ID
	remove    []ID
	relations []RelationID
}

// NewExchange5 creates an [Exchange5].
func NewExchange5[A any, B any, C any, D any, E any](world *World) *Exchange5[A, B, C, D, E] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
	}
	return &Exchange5[A, B, C, D, E]{
		world: world,
		ids:   ids,
	}
}

// Removes sets the components that this [Exchange5] removes.
// Can be called multiple times in chains, or once with multiple arguments.
func (ex *Exchange5[A, B, C, D, E]) Removes(components ...Comp) *Exchange5[A, B, C, D, E] {
	for _, c := range components {
		ex.remove = append(ex.remove, ex.world.componentID(c.tp))
	}
	return ex
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange5[A, B, C, D, E]) Add(entity Entity, a *A, b *B, c *C, d *D, e *E, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchange(entity, ex.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
	}, ex.relations)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange5[A, B, C, D, E]) AddFn(entity Entity, fn func(a *A, b *B, c *C, d *D, e *E), rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchange(entity, ex.ids, nil, nil, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
}

// Remove the components previously specified with [Exchange5.Removes] from the given entity.
func (ex *Exchange5[A, B, C, D, E]) Remove(entity Entity) {
	ex.world.exchange(entity, nil, ex.remove, nil, nil)
}

// Exchange performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange5.Removes].
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange5[A, B, C, D, E]) Exchange(entity Entity, a *A, b *B, c *C, d *D, e *E, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchange(entity, ex.ids, ex.remove, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
	}, ex.relations)
}

// ExchangeFn performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange5.Removes].
// It runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange5[A, B, C, D, E]) ExchangeFn(entity Entity, fn func(a *A, b *B, c *C, d *D, e *E), rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchange(entity, ex.ids, ex.remove, nil, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange5[A, B, C, D, E]) AddBatch(batch *Batch, a *A, b *B, c *C, d *D, e *E, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchangeBatch(batch, ex.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
	}, ex.relations, nil)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange5[A, B, C, D, E]) AddBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E), rel ...Relation) {
	ex.exchangeBatchFn(batch, fn, false, rel...)
}

// RemoveBatch removes the components previously specified with [Exchange5.Removes]
// from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (ex *Exchange5[A, B, C, D, E]) RemoveBatch(batch *Batch, fn func(entity Entity)) {
	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &ex.world.storage.tables[tableID]

			lock := ex.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(table.GetEntity(index))
			}
			ex.world.unlock(lock)
		}
	}
	ex.world.exchangeBatch(batch, nil, ex.remove, nil, nil, process)
}

// ExchangeBatch performs the exchange on all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange5[A, B, C, D, E]) ExchangeBatch(batch *Batch, a *A, b *B, c *C, d *D, e *E, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchangeBatch(batch, ex.ids, ex.remove, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
	}, ex.relations, nil)
}

// ExchangeBatchFn performs the exchange on all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange5[A, B, C, D, E]) ExchangeBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E), rel ...Relation) {
	ex.exchangeBatchFn(batch, fn, true, rel...)
}

func (ex *Exchange5[A, B, C, D, E]) exchangeBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E), remove bool, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &ex.world.storage.tables[tableID]
			columnA := table.GetColumn(ex.ids[0])
			columnB := table.GetColumn(ex.ids[1])
			columnC := table.GetColumn(ex.ids[2])
			columnD := table.GetColumn(ex.ids[3])
			columnE := table.GetColumn(ex.ids[4])

			lock := ex.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
					(*D)(columnD.Get(index)),
					(*E)(columnE.Get(index)),
				)
			}
			ex.world.unlock(lock)
		}
	}
	if remove {
		ex.world.exchangeBatch(batch, ex.ids, ex.remove, nil, ex.relations, process)
	} else {
		ex.world.exchangeBatch(batch, ex.ids, nil, nil, ex.relations, process)
	}
}

func (ex *Exchange5[A, B, C, D, E]) runCallback(entity Entity, fn func(a *A, b *B, c *C, d *D, e *E)) {
	index := &ex.world.storage.entities[entity.id]
	table := &ex.world.storage.tables[index.table]
	row := uintptr(index.row)
	fn(
		(*A)(table.GetColumn(ex.ids[0]).Get(row)),
		(*B)(table.GetColumn(ex.ids[1]).Get(row)),
		(*C)(table.GetColumn(ex.ids[2]).Get(row)),
		(*D)(table.GetColumn(ex.ids[3]).Get(row)),
		(*E)(table.GetColumn(ex.ids[4]).Get(row)),
	)
}

// Exchange6 allows to exchange components of entities.
// It adds the given components. Use [Exchange6.Removes]
// to set components to be removed.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Exchange2] for a usage example.
type Exchange6[A any, B any, C any, D any, E any, F any] struct {
	world     *World
	ids       []ID
	remove    []ID
	relations []RelationID
}

// NewExchange6 creates an [Exchange6].
func NewExchange6[A any, B any, C any, D any, E any, F any](world *World) *Exchange6[A, B, C, D, E, F] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
		ComponentID[F](world),
	}
	return &Exchange6[A, B, C, D, E, F]{
		world: world,
		ids:   ids,
	}
}

// Removes sets the components that this [Exchange6] removes.
// Can be called multiple times in chains, or once with multiple arguments.
func (ex *Exchange6[A, B, C, D, E, F]) Removes(components ...Comp) *Exchange6[A, B, C, D, E, F] {
	for _, c := range components {
		ex.remove = append(ex.remove, ex.world.componentID(c.tp))
	}
	return ex
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange6[A, B, C, D, E, F]) Add(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchange(entity, ex.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
	}, ex.relations)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange6[A, B, C, D, E, F]) AddFn(entity Entity, fn func(a *A, b *B, c *C, d *D, e *E, f *F), rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchange(entity, ex.ids, nil, nil, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
}

// Remove the components previously specified with [Exchange6.Removes] from the given entity.
func (ex *Exchange6[A, B, C, D, E, F]) Remove(entity Entity) {
	ex.world.exchange(entity, nil, ex.remove, nil, nil)
}

// Exchange performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange6.Removes].
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange6[A, B, C, D, E, F]) Exchange(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchange(entity, ex.ids, ex.remove, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
	}, ex.relations)
}

// ExchangeFn performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange6.Removes].
// It runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange6[A, B, C, D, E, F]) ExchangeFn(entity Entity, fn func(a *A, b *B, c *C, d *D, e *E, f *F), rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchange(entity, ex.ids, ex.remove, nil, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange6[A, B, C, D, E, F]) AddBatch(batch *Batch, a *A, b *B, c *C, d *D, e *E, f *F, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchangeBatch(batch, ex.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
	}, ex.relations, nil)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange6[A, B, C, D, E, F]) AddBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F), rel ...Relation) {
	ex.exchangeBatchFn(batch, fn, false, rel...)
}

// RemoveBatch removes the components previously specified with [Exchange6.Removes]
// from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (ex *Exchange6[A, B, C, D, E, F]) RemoveBatch(batch *Batch, fn func(entity Entity)) {
	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &ex.world.storage.tables[tableID]

			lock := ex.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(table.GetEntity(index))
			}
			ex.world.unlock(lock)
		}
	}
	ex.world.exchangeBatch(batch, nil, ex.remove, nil, nil, process)
}

// ExchangeBatch performs the exchange on all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange6[A, B, C, D, E, F]) ExchangeBatch(batch *Batch, a *A, b *B, c *C, d *D, e *E, f *F, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchangeBatch(batch, ex.ids, ex.remove, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
	}, ex.relations, nil)
}

// ExchangeBatchFn performs the exchange on all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange6[A, B, C, D, E, F]) ExchangeBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F), rel ...Relation) {
	ex.exchangeBatchFn(batch, fn, true, rel...)
}

func (ex *Exchange6[A, B, C, D, E, F]) exchangeBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F), remove bool, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &ex.world.storage.tables[tableID]
			columnA := table.GetColumn(ex.ids[0])
			columnB := table.GetColumn(ex.ids[1])
			columnC := table.GetColumn(ex.ids[2])
			columnD := table.GetColumn(ex.ids[3])
			columnE := table.GetColumn(ex.ids[4])
			columnF := table.GetColumn(ex.ids[5])

			lock := ex.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
					(*D)(columnD.Get(index)),
					(*E)(columnE.Get(index)),
					(*F)(columnF.Get(index)),
				)
			}
			ex.world.unlock(lock)
		}
	}
	if remove {
		ex.world.exchangeBatch(batch, ex.ids, ex.remove, nil, ex.relations, process)
	} else {
		ex.world.exchangeBatch(batch, ex.ids, nil, nil, ex.relations, process)
	}
}

func (ex *Exchange6[A, B, C, D, E, F]) runCallback(entity Entity, fn func(a *A, b *B, c *C, d *D, e *E, f *F)) {
	index := &ex.world.storage.entities[entity.id]
	table := &ex.world.storage.tables[index.table]
	row := uintptr(index.row)
	fn(
		(*A)(table.GetColumn(ex.ids[0]).Get(row)),
		(*B)(table.GetColumn(ex.ids[1]).Get(row)),
		(*C)(table.GetColumn(ex.ids[2]).Get(row)),
		(*D)(table.GetColumn(ex.ids[3]).Get(row)),
		(*E)(table.GetColumn(ex.ids[4]).Get(row)),
		(*F)(table.GetColumn(ex.ids[5]).Get(row)),
	)
}

// Exchange7 allows to exchange components of entities.
// It adds the given components. Use [Exchange7.Removes]
// to set components to be removed.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Exchange2] for a usage example.
type Exchange7[A any, B any, C any, D any, E any, F any, G any] struct {
	world     *World
	ids       []ID
	remove    []ID
	relations []RelationID
}

// NewExchange7 creates an [Exchange7].
func NewExchange7[A any, B any, C any, D any, E any, F any, G any](world *World) *Exchange7[A, B, C, D, E, F, G] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
		ComponentID[F](world),
		ComponentID[G](world),
	}
	return &Exchange7[A, B, C, D, E, F, G]{
		world: world,
		ids:   ids,
	}
}

// Removes sets the components that this [Exchange7] removes.
// Can be called multiple times in chains, or once with multiple arguments.
func (ex *Exchange7[A, B, C, D, E, F, G]) Removes(components ...Comp) *Exchange7[A, B, C, D, E, F, G] {
	for _, c := range components {
		ex.remove = append(ex.remove, ex.world.componentID(c.tp))
	}
	return ex
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange7[A, B, C, D, E, F, G]) Add(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchange(entity, ex.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
	}, ex.relations)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange7[A, B, C, D, E, F, G]) AddFn(entity Entity, fn func(a *A, b *B, c *C, d *D, e *E, f *F, g *G), rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchange(entity, ex.ids, nil, nil, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
}

// Remove the components previously specified with [Exchange7.Removes] from the given entity.
func (ex *Exchange7[A, B, C, D, E, F, G]) Remove(entity Entity) {
	ex.world.exchange(entity, nil, ex.remove, nil, nil)
}

// Exchange performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange7.Removes].
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange7[A, B, C, D, E, F, G]) Exchange(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchange(entity, ex.ids, ex.remove, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
	}, ex.relations)
}

// ExchangeFn performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange7.Removes].
// It runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange7[A, B, C, D, E, F, G]) ExchangeFn(entity Entity, fn func(a *A, b *B, c *C, d *D, e *E, f *F, g *G), rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchange(entity, ex.ids, ex.remove, nil, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange7[A, B, C, D, E, F, G]) AddBatch(batch *Batch, a *A, b *B, c *C, d *D, e *E, f *F, g *G, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchangeBatch(batch, ex.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
	}, ex.relations, nil)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange7[A, B, C, D, E, F, G]) AddBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G), rel ...Relation) {
	ex.exchangeBatchFn(batch, fn, false, rel...)
}

// RemoveBatch removes the components previously specified with [Exchange7.Removes]
// from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (ex *Exchange7[A, B, C, D, E, F, G]) RemoveBatch(batch *Batch, fn func(entity Entity)) {
	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &ex.world.storage.tables[tableID]

			lock := ex.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(table.GetEntity(index))
			}
			ex.world.unlock(lock)
		}
	}
	ex.world.exchangeBatch(batch, nil, ex.remove, nil, nil, process)
}

// ExchangeBatch performs the exchange on all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange7[A, B, C, D, E, F, G]) ExchangeBatch(batch *Batch, a *A, b *B, c *C, d *D, e *E, f *F, g *G, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchangeBatch(batch, ex.ids, ex.remove, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
	}, ex.relations, nil)
}

// ExchangeBatchFn performs the exchange on all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange7[A, B, C, D, E, F, G]) ExchangeBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G), rel ...Relation) {
	ex.exchangeBatchFn(batch, fn, true, rel...)
}

func (ex *Exchange7[A, B, C, D, E, F, G]) exchangeBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G), remove bool, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &ex.world.storage.tables[tableID]
			columnA := table.GetColumn(ex.ids[0])
			columnB := table.GetColumn(ex.ids[1])
			columnC := table.GetColumn(ex.ids[2])
			columnD := table.GetColumn(ex.ids[3])
			columnE := table.GetColumn(ex.ids[4])
			columnF := table.GetColumn(ex.ids[5])
			columnG := table.GetColumn(ex.ids[6])

			lock := ex.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
					(*D)(columnD.Get(index)),
					(*E)(columnE.Get(index)),
					(*F)(columnF.Get(index)),
					(*G)(columnG.Get(index)),
				)
			}
			ex.world.unlock(lock)
		}
	}
	if remove {
		ex.world.exchangeBatch(batch, ex.ids, ex.remove, nil, ex.relations, process)
	} else {
		ex.world.exchangeBatch(batch, ex.ids, nil, nil, ex.relations, process)
	}
}

func (ex *Exchange7[A, B, C, D, E, F, G]) runCallback(entity Entity, fn func(a *A, b *B, c *C, d *D, e *E, f *F, g *G)) {
	index := &ex.world.storage.entities[entity.id]
	table := &ex.world.storage.tables[index.table]
	row := uintptr(index.row)
	fn(
		(*A)(table.GetColumn(ex.ids[0]).Get(row)),
		(*B)(table.GetColumn(ex.ids[1]).Get(row)),
		(*C)(table.GetColumn(ex.ids[2]).Get(row)),
		(*D)(table.GetColumn(ex.ids[3]).Get(row)),
		(*E)(table.GetColumn(ex.ids[4]).Get(row)),
		(*F)(table.GetColumn(ex.ids[5]).Get(row)),
		(*G)(table.GetColumn(ex.ids[6]).Get(row)),
	)
}

// Exchange8 allows to exchange components of entities.
// It adds the given components. Use [Exchange8.Removes]
// to set components to be removed.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Exchange2] for a usage example.
type Exchange8[A any, B any, C any, D any, E any, F any, G any, H any] struct {
	world     *World
	ids       []ID
	remove    []ID
	relations []RelationID
}

// NewExchange8 creates an [Exchange8].
func NewExchange8[A any, B any, C any, D any, E any, F any, G any, H any](world *World) *Exchange8[A, B, C, D, E, F, G, H] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
		ComponentID[F](world),
		ComponentID[G](world),
		ComponentID[H](world),
	}
	return &Exchange8[A, B, C, D, E, F, G, H]{
		world: world,
		ids:   ids,
	}
}

// Removes sets the components that this [Exchange8] removes.
// Can be called multiple times in chains, or once with multiple arguments.
func (ex *Exchange8[A, B, C, D, E, F, G, H]) Removes(components ...Comp) *Exchange8[A, B, C, D, E, F, G, H] {
	for _, c := range components {
		ex.remove = append(ex.remove, ex.world.componentID(c.tp))
	}
	return ex
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange8[A, B, C, D, E, F, G, H]) Add(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchange(entity, ex.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
		unsafe.Pointer(h),
	}, ex.relations)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange8[A, B, C, D, E, F, G, H]) AddFn(entity Entity, fn func(a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H), rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchange(entity, ex.ids, nil, nil, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
}

// Remove the components previously specified with [Exchange8.Removes] from the given entity.
func (ex *Exchange8[A, B, C, D, E, F, G, H]) Remove(entity Entity) {
	ex.world.exchange(entity, nil, ex.remove, nil, nil)
}

// Exchange performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange8.Removes].
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange8[A, B, C, D, E, F, G, H]) Exchange(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchange(entity, ex.ids, ex.remove, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
		unsafe.Pointer(h),
	}, ex.relations)
}

// ExchangeFn performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange8.Removes].
// It runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange8[A, B, C, D, E, F, G, H]) ExchangeFn(entity Entity, fn func(a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H), rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchange(entity, ex.ids, ex.remove, nil, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange8[A, B, C, D, E, F, G, H]) AddBatch(batch *Batch, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchangeBatch(batch, ex.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
		unsafe.Pointer(h),
	}, ex.relations, nil)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange8[A, B, C, D, E, F, G, H]) AddBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H), rel ...Relation) {
	ex.exchangeBatchFn(batch, fn, false, rel...)
}

// RemoveBatch removes the components previously specified with [Exchange8.Removes]
// from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (ex *Exchange8[A, B, C, D, E, F, G, H]) RemoveBatch(batch *Batch, fn func(entity Entity)) {
	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &ex.world.storage.tables[tableID]

			lock := ex.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(table.GetEntity(index))
			}
			ex.world.unlock(lock)
		}
	}
	ex.world.exchangeBatch(batch, nil, ex.remove, nil, nil, process)
}

// ExchangeBatch performs the exchange on all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (ex *Exchange8[A, B, C, D, E, F, G, H]) ExchangeBatch(batch *Batch, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)
	ex.world.exchangeBatch(batch, ex.ids, ex.remove, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
		unsafe.Pointer(h),
	}, ex.relations, nil)
}

// ExchangeBatchFn performs the exchange on all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange8[A, B, C, D, E, F, G, H]) ExchangeBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H), rel ...Relation) {
	ex.exchangeBatchFn(batch, fn, true, rel...)
}

func (ex *Exchange8[A, B, C, D, E, F, G, H]) exchangeBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H), remove bool, rel ...Relation) {
	ex.relations = relations(rel).toRelations(ex.world, ex.ids, nil, ex.relations)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &ex.world.storage.tables[tableID]
			columnA := table.GetColumn(ex.ids[0])
			columnB := table.GetColumn(ex.ids[1])
			columnC := table.GetColumn(ex.ids[2])
			columnD := table.GetColumn(ex.ids[3])
			columnE := table.GetColumn(ex.ids[4])
			columnF := table.GetColumn(ex.ids[5])
			columnG := table.GetColumn(ex.ids[6])
			columnH := table.GetColumn(ex.ids[7])

			lock := ex.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
					(*D)(columnD.Get(index)),
					(*E)(columnE.Get(index)),
					(*F)(columnF.Get(index)),
					(*G)(columnG.Get(index)),
					(*H)(columnH.Get(index)),
				)
			}
			ex.world.unlock(lock)
		}
	}
	if remove {
		ex.world.exchangeBatch(batch, ex.ids, ex.remove, nil, ex.relations, process)
	} else {
		ex.world.exchangeBatch(batch, ex.ids, nil, nil, ex.relations, process)
	}
}

func (ex *Exchange8[A, B, C, D, E, F, G, H]) runCallback(entity Entity, fn func(a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H)) {
	index := &ex.world.storage.entities[entity.id]
	table := &ex.world.storage.tables[index.table]
	row := uintptr(index.row)
	fn(
		(*A)(table.GetColumn(ex.ids[0]).Get(row)),
		(*B)(table.GetColumn(ex.ids[1]).Get(row)),
		(*C)(table.GetColumn(ex.ids[2]).Get(row)),
		(*D)(table.GetColumn(ex.ids[3]).Get(row)),
		(*E)(table.GetColumn(ex.ids[4]).Get(row)),
		(*F)(table.GetColumn(ex.ids[5]).Get(row)),
		(*G)(table.GetColumn(ex.ids[6]).Get(row)),
		(*H)(table.GetColumn(ex.ids[7]).Get(row)),
	)
}
