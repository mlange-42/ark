package ecs

// Code generated by go generate; DO NOT EDIT.

// Exchange1 allows to exchange components of entities.
// It adds the given components. Use [Exchange1.Removes]
// to set components to be removed.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Exchange2] for a usage example.
type Exchange1[A any] struct {
	world     *World
	ids       []ID
	remove    []ID
	relations []relationID
	mask      bitMask
}

// New creates a new [Exchange1]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
//
// See [Exchange2.New] for an example.
func (*Exchange1[A]) New(world *World) *Exchange1[A] {
	return NewExchange1[A](world)
}

// NewExchange1 creates an [Exchange1].
//
// See also [Exchange1.New] for a shortcut when constructing an already defined instance.
func NewExchange1[A any](world *World) *Exchange1[A] {
	ids := []ID{
		ComponentID[A](world),
	}
	return &Exchange1[A]{
		world: world,
		ids:   ids,
		mask:  newMask(ids...),
	}
}

// Removes sets the components that this [Exchange1] removes.
// Can be called multiple times in chains, or once with multiple arguments.
func (ex *Exchange1[A]) Removes(components ...Comp) *Exchange1[A] {
	for _, c := range components {
		ex.remove = append(ex.remove, ex.world.componentID(c.tp))
	}
	return ex
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (ex *Exchange1[A]) Add(entity Entity, a *A, rel ...Relation) {
	ex.AddFn(entity, func(pa *A) {
		*pa = *a
	}, rel...)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange1[A]) AddFn(entity Entity, fn func(*A), rel ...Relation) {
	ex.relations = relationSlice(rel).ToRelations(ex.world, &ex.mask, ex.ids, ex.relations[:0], false)
	oldMask, newMask := ex.world.add(entity, ex.ids, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
	ex.world.storage.observers.FireAddIfHas(OnAddComponents, entity, oldMask, newMask)
	if len(rel) > 0 {
		ex.world.storage.observers.FireAddIfHas(OnAddRelations, entity, oldMask, newMask)
	}
}

// Remove the components previously specified with [Exchange1.Removes] from the given entity.
func (ex *Exchange1[A]) Remove(entity Entity) {
	ex.world.remove(entity, ex.remove)
}

// Exchange performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange1.Removes].
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (ex *Exchange1[A]) Exchange(entity Entity, a *A, rel ...Relation) {
	ex.ExchangeFn(entity, func(pa *A) {
		*pa = *a
	}, rel...)

}

// ExchangeFn performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange1.Removes].
// It runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange1[A]) ExchangeFn(entity Entity, fn func(*A), rel ...Relation) {
	ex.relations = relationSlice(rel).ToRelations(ex.world, &ex.mask, ex.ids, ex.relations[:0], false)
	oldMask, newMask := ex.world.exchange(entity, ex.ids, ex.remove, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
	ex.world.storage.observers.FireAddIfHas(OnAddComponents, entity, oldMask, newMask)
	if len(rel) > 0 {
		ex.world.storage.observers.FireAddIfHas(OnAddRelations, entity, oldMask, newMask)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (ex *Exchange1[A]) AddBatch(batch Batch, a *A, rel ...Relation) {
	ex.AddBatchFn(batch, func(_ Entity, pa *A) {
		*pa = *a
	}, rel...)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange1[A]) AddBatchFn(batch Batch, fn func(Entity, *A), rel ...Relation) {
	ex.exchangeBatchFn(&batch, fn, false, rel...)
}

// RemoveBatch removes the components previously specified with [Exchange1.Removes]
// from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (ex *Exchange1[A]) RemoveBatch(batch Batch, fn func(entity Entity)) {
	removeBatch(ex.world, &batch, ex.remove, fn)
}

// ExchangeBatch performs the exchange on all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (ex *Exchange1[A]) ExchangeBatch(batch Batch, a *A, rel ...Relation) {
	ex.ExchangeBatchFn(batch, func(_ Entity, pa *A) {
		*pa = *a
	}, rel...)
}

// ExchangeBatchFn performs the exchange on all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange1[A]) ExchangeBatchFn(batch Batch, fn func(Entity, *A), rel ...Relation) {
	ex.exchangeBatchFn(&batch, fn, true, rel...)
}

func (ex *Exchange1[A]) exchangeBatchFn(batch *Batch, fn func(Entity, *A), remove bool, rel ...Relation) {
	ex.relations = relationSlice(rel).ToRelations(ex.world, &ex.mask, ex.ids, ex.relations[:0], false)

	var process func(tableID tableID, start, len uint32)
	if fn != nil {
		process = func(tableID tableID, start, len uint32) {
			table := &ex.world.storage.tables[tableID]
			columnA := table.Column(ex.ids[0])

			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
				)
			}
		}
	}
	if remove {
		ex.world.exchangeBatch(batch, ex.ids, ex.remove, ex.relations, process)
	} else {
		ex.world.exchangeBatch(batch, ex.ids, nil, ex.relations, process)
	}
}

func (ex *Exchange1[A]) runCallback(entity Entity, fn func(a *A)) {
	index := &ex.world.storage.entities[entity.id]
	table := &ex.world.storage.tables[index.table]
	row := uintptr(index.row)
	fn(
		(*A)(table.Column(ex.ids[0]).Get(row)),
	)
}

// Exchange2 allows to exchange components of entities.
// It adds the given components. Use [Exchange2.Removes]
// to set components to be removed.
//
// Instances should be created during initialization and stored, e.g. in systems.
type Exchange2[A any, B any] struct {
	world     *World
	ids       []ID
	remove    []ID
	relations []relationID
	mask      bitMask
}

// New creates a new [Exchange2]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
func (*Exchange2[A, B]) New(world *World) *Exchange2[A, B] {
	return NewExchange2[A, B](world)
}

// NewExchange2 creates an [Exchange2].
//
// See also [Exchange2.New] for a shortcut when constructing an already defined instance.
func NewExchange2[A any, B any](world *World) *Exchange2[A, B] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
	}
	return &Exchange2[A, B]{
		world: world,
		ids:   ids,
		mask:  newMask(ids...),
	}
}

// Removes sets the components that this [Exchange2] removes.
// Can be called multiple times in chains, or once with multiple arguments.
func (ex *Exchange2[A, B]) Removes(components ...Comp) *Exchange2[A, B] {
	for _, c := range components {
		ex.remove = append(ex.remove, ex.world.componentID(c.tp))
	}
	return ex
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (ex *Exchange2[A, B]) Add(entity Entity, a *A, b *B, rel ...Relation) {
	ex.AddFn(entity, func(pa *A, pb *B) {
		*pa = *a
		*pb = *b
	}, rel...)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange2[A, B]) AddFn(entity Entity, fn func(*A, *B), rel ...Relation) {
	ex.relations = relationSlice(rel).ToRelations(ex.world, &ex.mask, ex.ids, ex.relations[:0], false)
	oldMask, newMask := ex.world.add(entity, ex.ids, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
	ex.world.storage.observers.FireAddIfHas(OnAddComponents, entity, oldMask, newMask)
	if len(rel) > 0 {
		ex.world.storage.observers.FireAddIfHas(OnAddRelations, entity, oldMask, newMask)
	}
}

// Remove the components previously specified with [Exchange2.Removes] from the given entity.
func (ex *Exchange2[A, B]) Remove(entity Entity) {
	ex.world.remove(entity, ex.remove)
}

// Exchange performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange2.Removes].
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (ex *Exchange2[A, B]) Exchange(entity Entity, a *A, b *B, rel ...Relation) {
	ex.ExchangeFn(entity, func(pa *A, pb *B) {
		*pa = *a
		*pb = *b
	}, rel...)

}

// ExchangeFn performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange2.Removes].
// It runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange2[A, B]) ExchangeFn(entity Entity, fn func(*A, *B), rel ...Relation) {
	ex.relations = relationSlice(rel).ToRelations(ex.world, &ex.mask, ex.ids, ex.relations[:0], false)
	oldMask, newMask := ex.world.exchange(entity, ex.ids, ex.remove, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
	ex.world.storage.observers.FireAddIfHas(OnAddComponents, entity, oldMask, newMask)
	if len(rel) > 0 {
		ex.world.storage.observers.FireAddIfHas(OnAddRelations, entity, oldMask, newMask)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (ex *Exchange2[A, B]) AddBatch(batch Batch, a *A, b *B, rel ...Relation) {
	ex.AddBatchFn(batch, func(_ Entity, pa *A, pb *B) {
		*pa = *a
		*pb = *b
	}, rel...)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange2[A, B]) AddBatchFn(batch Batch, fn func(Entity, *A, *B), rel ...Relation) {
	ex.exchangeBatchFn(&batch, fn, false, rel...)
}

// RemoveBatch removes the components previously specified with [Exchange2.Removes]
// from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (ex *Exchange2[A, B]) RemoveBatch(batch Batch, fn func(entity Entity)) {
	removeBatch(ex.world, &batch, ex.remove, fn)
}

// ExchangeBatch performs the exchange on all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (ex *Exchange2[A, B]) ExchangeBatch(batch Batch, a *A, b *B, rel ...Relation) {
	ex.ExchangeBatchFn(batch, func(_ Entity, pa *A, pb *B) {
		*pa = *a
		*pb = *b
	}, rel...)
}

// ExchangeBatchFn performs the exchange on all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange2[A, B]) ExchangeBatchFn(batch Batch, fn func(Entity, *A, *B), rel ...Relation) {
	ex.exchangeBatchFn(&batch, fn, true, rel...)
}

func (ex *Exchange2[A, B]) exchangeBatchFn(batch *Batch, fn func(Entity, *A, *B), remove bool, rel ...Relation) {
	ex.relations = relationSlice(rel).ToRelations(ex.world, &ex.mask, ex.ids, ex.relations[:0], false)

	var process func(tableID tableID, start, len uint32)
	if fn != nil {
		process = func(tableID tableID, start, len uint32) {
			table := &ex.world.storage.tables[tableID]
			columnA := table.Column(ex.ids[0])
			columnB := table.Column(ex.ids[1])

			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
				)
			}
		}
	}
	if remove {
		ex.world.exchangeBatch(batch, ex.ids, ex.remove, ex.relations, process)
	} else {
		ex.world.exchangeBatch(batch, ex.ids, nil, ex.relations, process)
	}
}

func (ex *Exchange2[A, B]) runCallback(entity Entity, fn func(a *A, b *B)) {
	index := &ex.world.storage.entities[entity.id]
	table := &ex.world.storage.tables[index.table]
	row := uintptr(index.row)
	fn(
		(*A)(table.Column(ex.ids[0]).Get(row)),
		(*B)(table.Column(ex.ids[1]).Get(row)),
	)
}

// Exchange3 allows to exchange components of entities.
// It adds the given components. Use [Exchange3.Removes]
// to set components to be removed.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Exchange2] for a usage example.
type Exchange3[A any, B any, C any] struct {
	world     *World
	ids       []ID
	remove    []ID
	relations []relationID
	mask      bitMask
}

// New creates a new [Exchange3]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
//
// See [Exchange2.New] for an example.
func (*Exchange3[A, B, C]) New(world *World) *Exchange3[A, B, C] {
	return NewExchange3[A, B, C](world)
}

// NewExchange3 creates an [Exchange3].
//
// See also [Exchange3.New] for a shortcut when constructing an already defined instance.
func NewExchange3[A any, B any, C any](world *World) *Exchange3[A, B, C] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
	}
	return &Exchange3[A, B, C]{
		world: world,
		ids:   ids,
		mask:  newMask(ids...),
	}
}

// Removes sets the components that this [Exchange3] removes.
// Can be called multiple times in chains, or once with multiple arguments.
func (ex *Exchange3[A, B, C]) Removes(components ...Comp) *Exchange3[A, B, C] {
	for _, c := range components {
		ex.remove = append(ex.remove, ex.world.componentID(c.tp))
	}
	return ex
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (ex *Exchange3[A, B, C]) Add(entity Entity, a *A, b *B, c *C, rel ...Relation) {
	ex.AddFn(entity, func(pa *A, pb *B, pc *C) {
		*pa = *a
		*pb = *b
		*pc = *c
	}, rel...)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange3[A, B, C]) AddFn(entity Entity, fn func(*A, *B, *C), rel ...Relation) {
	ex.relations = relationSlice(rel).ToRelations(ex.world, &ex.mask, ex.ids, ex.relations[:0], false)
	oldMask, newMask := ex.world.add(entity, ex.ids, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
	ex.world.storage.observers.FireAddIfHas(OnAddComponents, entity, oldMask, newMask)
	if len(rel) > 0 {
		ex.world.storage.observers.FireAddIfHas(OnAddRelations, entity, oldMask, newMask)
	}
}

// Remove the components previously specified with [Exchange3.Removes] from the given entity.
func (ex *Exchange3[A, B, C]) Remove(entity Entity) {
	ex.world.remove(entity, ex.remove)
}

// Exchange performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange3.Removes].
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (ex *Exchange3[A, B, C]) Exchange(entity Entity, a *A, b *B, c *C, rel ...Relation) {
	ex.ExchangeFn(entity, func(pa *A, pb *B, pc *C) {
		*pa = *a
		*pb = *b
		*pc = *c
	}, rel...)

}

// ExchangeFn performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange3.Removes].
// It runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange3[A, B, C]) ExchangeFn(entity Entity, fn func(*A, *B, *C), rel ...Relation) {
	ex.relations = relationSlice(rel).ToRelations(ex.world, &ex.mask, ex.ids, ex.relations[:0], false)
	oldMask, newMask := ex.world.exchange(entity, ex.ids, ex.remove, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
	ex.world.storage.observers.FireAddIfHas(OnAddComponents, entity, oldMask, newMask)
	if len(rel) > 0 {
		ex.world.storage.observers.FireAddIfHas(OnAddRelations, entity, oldMask, newMask)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (ex *Exchange3[A, B, C]) AddBatch(batch Batch, a *A, b *B, c *C, rel ...Relation) {
	ex.AddBatchFn(batch, func(_ Entity, pa *A, pb *B, pc *C) {
		*pa = *a
		*pb = *b
		*pc = *c
	}, rel...)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange3[A, B, C]) AddBatchFn(batch Batch, fn func(Entity, *A, *B, *C), rel ...Relation) {
	ex.exchangeBatchFn(&batch, fn, false, rel...)
}

// RemoveBatch removes the components previously specified with [Exchange3.Removes]
// from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (ex *Exchange3[A, B, C]) RemoveBatch(batch Batch, fn func(entity Entity)) {
	removeBatch(ex.world, &batch, ex.remove, fn)
}

// ExchangeBatch performs the exchange on all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (ex *Exchange3[A, B, C]) ExchangeBatch(batch Batch, a *A, b *B, c *C, rel ...Relation) {
	ex.ExchangeBatchFn(batch, func(_ Entity, pa *A, pb *B, pc *C) {
		*pa = *a
		*pb = *b
		*pc = *c
	}, rel...)
}

// ExchangeBatchFn performs the exchange on all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange3[A, B, C]) ExchangeBatchFn(batch Batch, fn func(Entity, *A, *B, *C), rel ...Relation) {
	ex.exchangeBatchFn(&batch, fn, true, rel...)
}

func (ex *Exchange3[A, B, C]) exchangeBatchFn(batch *Batch, fn func(Entity, *A, *B, *C), remove bool, rel ...Relation) {
	ex.relations = relationSlice(rel).ToRelations(ex.world, &ex.mask, ex.ids, ex.relations[:0], false)

	var process func(tableID tableID, start, len uint32)
	if fn != nil {
		process = func(tableID tableID, start, len uint32) {
			table := &ex.world.storage.tables[tableID]
			columnA := table.Column(ex.ids[0])
			columnB := table.Column(ex.ids[1])
			columnC := table.Column(ex.ids[2])

			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
				)
			}
		}
	}
	if remove {
		ex.world.exchangeBatch(batch, ex.ids, ex.remove, ex.relations, process)
	} else {
		ex.world.exchangeBatch(batch, ex.ids, nil, ex.relations, process)
	}
}

func (ex *Exchange3[A, B, C]) runCallback(entity Entity, fn func(a *A, b *B, c *C)) {
	index := &ex.world.storage.entities[entity.id]
	table := &ex.world.storage.tables[index.table]
	row := uintptr(index.row)
	fn(
		(*A)(table.Column(ex.ids[0]).Get(row)),
		(*B)(table.Column(ex.ids[1]).Get(row)),
		(*C)(table.Column(ex.ids[2]).Get(row)),
	)
}

// Exchange4 allows to exchange components of entities.
// It adds the given components. Use [Exchange4.Removes]
// to set components to be removed.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Exchange2] for a usage example.
type Exchange4[A any, B any, C any, D any] struct {
	world     *World
	ids       []ID
	remove    []ID
	relations []relationID
	mask      bitMask
}

// New creates a new [Exchange4]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
//
// See [Exchange2.New] for an example.
func (*Exchange4[A, B, C, D]) New(world *World) *Exchange4[A, B, C, D] {
	return NewExchange4[A, B, C, D](world)
}

// NewExchange4 creates an [Exchange4].
//
// See also [Exchange4.New] for a shortcut when constructing an already defined instance.
func NewExchange4[A any, B any, C any, D any](world *World) *Exchange4[A, B, C, D] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
	}
	return &Exchange4[A, B, C, D]{
		world: world,
		ids:   ids,
		mask:  newMask(ids...),
	}
}

// Removes sets the components that this [Exchange4] removes.
// Can be called multiple times in chains, or once with multiple arguments.
func (ex *Exchange4[A, B, C, D]) Removes(components ...Comp) *Exchange4[A, B, C, D] {
	for _, c := range components {
		ex.remove = append(ex.remove, ex.world.componentID(c.tp))
	}
	return ex
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (ex *Exchange4[A, B, C, D]) Add(entity Entity, a *A, b *B, c *C, d *D, rel ...Relation) {
	ex.AddFn(entity, func(pa *A, pb *B, pc *C, pd *D) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
	}, rel...)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange4[A, B, C, D]) AddFn(entity Entity, fn func(*A, *B, *C, *D), rel ...Relation) {
	ex.relations = relationSlice(rel).ToRelations(ex.world, &ex.mask, ex.ids, ex.relations[:0], false)
	oldMask, newMask := ex.world.add(entity, ex.ids, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
	ex.world.storage.observers.FireAddIfHas(OnAddComponents, entity, oldMask, newMask)
	if len(rel) > 0 {
		ex.world.storage.observers.FireAddIfHas(OnAddRelations, entity, oldMask, newMask)
	}
}

// Remove the components previously specified with [Exchange4.Removes] from the given entity.
func (ex *Exchange4[A, B, C, D]) Remove(entity Entity) {
	ex.world.remove(entity, ex.remove)
}

// Exchange performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange4.Removes].
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (ex *Exchange4[A, B, C, D]) Exchange(entity Entity, a *A, b *B, c *C, d *D, rel ...Relation) {
	ex.ExchangeFn(entity, func(pa *A, pb *B, pc *C, pd *D) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
	}, rel...)

}

// ExchangeFn performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange4.Removes].
// It runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange4[A, B, C, D]) ExchangeFn(entity Entity, fn func(*A, *B, *C, *D), rel ...Relation) {
	ex.relations = relationSlice(rel).ToRelations(ex.world, &ex.mask, ex.ids, ex.relations[:0], false)
	oldMask, newMask := ex.world.exchange(entity, ex.ids, ex.remove, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
	ex.world.storage.observers.FireAddIfHas(OnAddComponents, entity, oldMask, newMask)
	if len(rel) > 0 {
		ex.world.storage.observers.FireAddIfHas(OnAddRelations, entity, oldMask, newMask)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (ex *Exchange4[A, B, C, D]) AddBatch(batch Batch, a *A, b *B, c *C, d *D, rel ...Relation) {
	ex.AddBatchFn(batch, func(_ Entity, pa *A, pb *B, pc *C, pd *D) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
	}, rel...)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange4[A, B, C, D]) AddBatchFn(batch Batch, fn func(Entity, *A, *B, *C, *D), rel ...Relation) {
	ex.exchangeBatchFn(&batch, fn, false, rel...)
}

// RemoveBatch removes the components previously specified with [Exchange4.Removes]
// from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (ex *Exchange4[A, B, C, D]) RemoveBatch(batch Batch, fn func(entity Entity)) {
	removeBatch(ex.world, &batch, ex.remove, fn)
}

// ExchangeBatch performs the exchange on all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (ex *Exchange4[A, B, C, D]) ExchangeBatch(batch Batch, a *A, b *B, c *C, d *D, rel ...Relation) {
	ex.ExchangeBatchFn(batch, func(_ Entity, pa *A, pb *B, pc *C, pd *D) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
	}, rel...)
}

// ExchangeBatchFn performs the exchange on all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange4[A, B, C, D]) ExchangeBatchFn(batch Batch, fn func(Entity, *A, *B, *C, *D), rel ...Relation) {
	ex.exchangeBatchFn(&batch, fn, true, rel...)
}

func (ex *Exchange4[A, B, C, D]) exchangeBatchFn(batch *Batch, fn func(Entity, *A, *B, *C, *D), remove bool, rel ...Relation) {
	ex.relations = relationSlice(rel).ToRelations(ex.world, &ex.mask, ex.ids, ex.relations[:0], false)

	var process func(tableID tableID, start, len uint32)
	if fn != nil {
		process = func(tableID tableID, start, len uint32) {
			table := &ex.world.storage.tables[tableID]
			columnA := table.Column(ex.ids[0])
			columnB := table.Column(ex.ids[1])
			columnC := table.Column(ex.ids[2])
			columnD := table.Column(ex.ids[3])

			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
					(*D)(columnD.Get(index)),
				)
			}
		}
	}
	if remove {
		ex.world.exchangeBatch(batch, ex.ids, ex.remove, ex.relations, process)
	} else {
		ex.world.exchangeBatch(batch, ex.ids, nil, ex.relations, process)
	}
}

func (ex *Exchange4[A, B, C, D]) runCallback(entity Entity, fn func(a *A, b *B, c *C, d *D)) {
	index := &ex.world.storage.entities[entity.id]
	table := &ex.world.storage.tables[index.table]
	row := uintptr(index.row)
	fn(
		(*A)(table.Column(ex.ids[0]).Get(row)),
		(*B)(table.Column(ex.ids[1]).Get(row)),
		(*C)(table.Column(ex.ids[2]).Get(row)),
		(*D)(table.Column(ex.ids[3]).Get(row)),
	)
}

// Exchange5 allows to exchange components of entities.
// It adds the given components. Use [Exchange5.Removes]
// to set components to be removed.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Exchange2] for a usage example.
type Exchange5[A any, B any, C any, D any, E any] struct {
	world     *World
	ids       []ID
	remove    []ID
	relations []relationID
	mask      bitMask
}

// New creates a new [Exchange5]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
//
// See [Exchange2.New] for an example.
func (*Exchange5[A, B, C, D, E]) New(world *World) *Exchange5[A, B, C, D, E] {
	return NewExchange5[A, B, C, D, E](world)
}

// NewExchange5 creates an [Exchange5].
//
// See also [Exchange5.New] for a shortcut when constructing an already defined instance.
func NewExchange5[A any, B any, C any, D any, E any](world *World) *Exchange5[A, B, C, D, E] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
	}
	return &Exchange5[A, B, C, D, E]{
		world: world,
		ids:   ids,
		mask:  newMask(ids...),
	}
}

// Removes sets the components that this [Exchange5] removes.
// Can be called multiple times in chains, or once with multiple arguments.
func (ex *Exchange5[A, B, C, D, E]) Removes(components ...Comp) *Exchange5[A, B, C, D, E] {
	for _, c := range components {
		ex.remove = append(ex.remove, ex.world.componentID(c.tp))
	}
	return ex
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (ex *Exchange5[A, B, C, D, E]) Add(entity Entity, a *A, b *B, c *C, d *D, e *E, rel ...Relation) {
	ex.AddFn(entity, func(pa *A, pb *B, pc *C, pd *D, pe *E) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
	}, rel...)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange5[A, B, C, D, E]) AddFn(entity Entity, fn func(*A, *B, *C, *D, *E), rel ...Relation) {
	ex.relations = relationSlice(rel).ToRelations(ex.world, &ex.mask, ex.ids, ex.relations[:0], false)
	oldMask, newMask := ex.world.add(entity, ex.ids, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
	ex.world.storage.observers.FireAddIfHas(OnAddComponents, entity, oldMask, newMask)
	if len(rel) > 0 {
		ex.world.storage.observers.FireAddIfHas(OnAddRelations, entity, oldMask, newMask)
	}
}

// Remove the components previously specified with [Exchange5.Removes] from the given entity.
func (ex *Exchange5[A, B, C, D, E]) Remove(entity Entity) {
	ex.world.remove(entity, ex.remove)
}

// Exchange performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange5.Removes].
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (ex *Exchange5[A, B, C, D, E]) Exchange(entity Entity, a *A, b *B, c *C, d *D, e *E, rel ...Relation) {
	ex.ExchangeFn(entity, func(pa *A, pb *B, pc *C, pd *D, pe *E) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
	}, rel...)

}

// ExchangeFn performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange5.Removes].
// It runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange5[A, B, C, D, E]) ExchangeFn(entity Entity, fn func(*A, *B, *C, *D, *E), rel ...Relation) {
	ex.relations = relationSlice(rel).ToRelations(ex.world, &ex.mask, ex.ids, ex.relations[:0], false)
	oldMask, newMask := ex.world.exchange(entity, ex.ids, ex.remove, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
	ex.world.storage.observers.FireAddIfHas(OnAddComponents, entity, oldMask, newMask)
	if len(rel) > 0 {
		ex.world.storage.observers.FireAddIfHas(OnAddRelations, entity, oldMask, newMask)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (ex *Exchange5[A, B, C, D, E]) AddBatch(batch Batch, a *A, b *B, c *C, d *D, e *E, rel ...Relation) {
	ex.AddBatchFn(batch, func(_ Entity, pa *A, pb *B, pc *C, pd *D, pe *E) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
	}, rel...)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange5[A, B, C, D, E]) AddBatchFn(batch Batch, fn func(Entity, *A, *B, *C, *D, *E), rel ...Relation) {
	ex.exchangeBatchFn(&batch, fn, false, rel...)
}

// RemoveBatch removes the components previously specified with [Exchange5.Removes]
// from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (ex *Exchange5[A, B, C, D, E]) RemoveBatch(batch Batch, fn func(entity Entity)) {
	removeBatch(ex.world, &batch, ex.remove, fn)
}

// ExchangeBatch performs the exchange on all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (ex *Exchange5[A, B, C, D, E]) ExchangeBatch(batch Batch, a *A, b *B, c *C, d *D, e *E, rel ...Relation) {
	ex.ExchangeBatchFn(batch, func(_ Entity, pa *A, pb *B, pc *C, pd *D, pe *E) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
	}, rel...)
}

// ExchangeBatchFn performs the exchange on all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange5[A, B, C, D, E]) ExchangeBatchFn(batch Batch, fn func(Entity, *A, *B, *C, *D, *E), rel ...Relation) {
	ex.exchangeBatchFn(&batch, fn, true, rel...)
}

func (ex *Exchange5[A, B, C, D, E]) exchangeBatchFn(batch *Batch, fn func(Entity, *A, *B, *C, *D, *E), remove bool, rel ...Relation) {
	ex.relations = relationSlice(rel).ToRelations(ex.world, &ex.mask, ex.ids, ex.relations[:0], false)

	var process func(tableID tableID, start, len uint32)
	if fn != nil {
		process = func(tableID tableID, start, len uint32) {
			table := &ex.world.storage.tables[tableID]
			columnA := table.Column(ex.ids[0])
			columnB := table.Column(ex.ids[1])
			columnC := table.Column(ex.ids[2])
			columnD := table.Column(ex.ids[3])
			columnE := table.Column(ex.ids[4])

			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
					(*D)(columnD.Get(index)),
					(*E)(columnE.Get(index)),
				)
			}
		}
	}
	if remove {
		ex.world.exchangeBatch(batch, ex.ids, ex.remove, ex.relations, process)
	} else {
		ex.world.exchangeBatch(batch, ex.ids, nil, ex.relations, process)
	}
}

func (ex *Exchange5[A, B, C, D, E]) runCallback(entity Entity, fn func(a *A, b *B, c *C, d *D, e *E)) {
	index := &ex.world.storage.entities[entity.id]
	table := &ex.world.storage.tables[index.table]
	row := uintptr(index.row)
	fn(
		(*A)(table.Column(ex.ids[0]).Get(row)),
		(*B)(table.Column(ex.ids[1]).Get(row)),
		(*C)(table.Column(ex.ids[2]).Get(row)),
		(*D)(table.Column(ex.ids[3]).Get(row)),
		(*E)(table.Column(ex.ids[4]).Get(row)),
	)
}

// Exchange6 allows to exchange components of entities.
// It adds the given components. Use [Exchange6.Removes]
// to set components to be removed.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Exchange2] for a usage example.
type Exchange6[A any, B any, C any, D any, E any, F any] struct {
	world     *World
	ids       []ID
	remove    []ID
	relations []relationID
	mask      bitMask
}

// New creates a new [Exchange6]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
//
// See [Exchange2.New] for an example.
func (*Exchange6[A, B, C, D, E, F]) New(world *World) *Exchange6[A, B, C, D, E, F] {
	return NewExchange6[A, B, C, D, E, F](world)
}

// NewExchange6 creates an [Exchange6].
//
// See also [Exchange6.New] for a shortcut when constructing an already defined instance.
func NewExchange6[A any, B any, C any, D any, E any, F any](world *World) *Exchange6[A, B, C, D, E, F] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
		ComponentID[F](world),
	}
	return &Exchange6[A, B, C, D, E, F]{
		world: world,
		ids:   ids,
		mask:  newMask(ids...),
	}
}

// Removes sets the components that this [Exchange6] removes.
// Can be called multiple times in chains, or once with multiple arguments.
func (ex *Exchange6[A, B, C, D, E, F]) Removes(components ...Comp) *Exchange6[A, B, C, D, E, F] {
	for _, c := range components {
		ex.remove = append(ex.remove, ex.world.componentID(c.tp))
	}
	return ex
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (ex *Exchange6[A, B, C, D, E, F]) Add(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, rel ...Relation) {
	ex.AddFn(entity, func(pa *A, pb *B, pc *C, pd *D, pe *E, pf *F) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
	}, rel...)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange6[A, B, C, D, E, F]) AddFn(entity Entity, fn func(*A, *B, *C, *D, *E, *F), rel ...Relation) {
	ex.relations = relationSlice(rel).ToRelations(ex.world, &ex.mask, ex.ids, ex.relations[:0], false)
	oldMask, newMask := ex.world.add(entity, ex.ids, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
	ex.world.storage.observers.FireAddIfHas(OnAddComponents, entity, oldMask, newMask)
	if len(rel) > 0 {
		ex.world.storage.observers.FireAddIfHas(OnAddRelations, entity, oldMask, newMask)
	}
}

// Remove the components previously specified with [Exchange6.Removes] from the given entity.
func (ex *Exchange6[A, B, C, D, E, F]) Remove(entity Entity) {
	ex.world.remove(entity, ex.remove)
}

// Exchange performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange6.Removes].
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (ex *Exchange6[A, B, C, D, E, F]) Exchange(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, rel ...Relation) {
	ex.ExchangeFn(entity, func(pa *A, pb *B, pc *C, pd *D, pe *E, pf *F) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
	}, rel...)

}

// ExchangeFn performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange6.Removes].
// It runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange6[A, B, C, D, E, F]) ExchangeFn(entity Entity, fn func(*A, *B, *C, *D, *E, *F), rel ...Relation) {
	ex.relations = relationSlice(rel).ToRelations(ex.world, &ex.mask, ex.ids, ex.relations[:0], false)
	oldMask, newMask := ex.world.exchange(entity, ex.ids, ex.remove, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
	ex.world.storage.observers.FireAddIfHas(OnAddComponents, entity, oldMask, newMask)
	if len(rel) > 0 {
		ex.world.storage.observers.FireAddIfHas(OnAddRelations, entity, oldMask, newMask)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (ex *Exchange6[A, B, C, D, E, F]) AddBatch(batch Batch, a *A, b *B, c *C, d *D, e *E, f *F, rel ...Relation) {
	ex.AddBatchFn(batch, func(_ Entity, pa *A, pb *B, pc *C, pd *D, pe *E, pf *F) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
	}, rel...)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange6[A, B, C, D, E, F]) AddBatchFn(batch Batch, fn func(Entity, *A, *B, *C, *D, *E, *F), rel ...Relation) {
	ex.exchangeBatchFn(&batch, fn, false, rel...)
}

// RemoveBatch removes the components previously specified with [Exchange6.Removes]
// from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (ex *Exchange6[A, B, C, D, E, F]) RemoveBatch(batch Batch, fn func(entity Entity)) {
	removeBatch(ex.world, &batch, ex.remove, fn)
}

// ExchangeBatch performs the exchange on all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (ex *Exchange6[A, B, C, D, E, F]) ExchangeBatch(batch Batch, a *A, b *B, c *C, d *D, e *E, f *F, rel ...Relation) {
	ex.ExchangeBatchFn(batch, func(_ Entity, pa *A, pb *B, pc *C, pd *D, pe *E, pf *F) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
	}, rel...)
}

// ExchangeBatchFn performs the exchange on all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange6[A, B, C, D, E, F]) ExchangeBatchFn(batch Batch, fn func(Entity, *A, *B, *C, *D, *E, *F), rel ...Relation) {
	ex.exchangeBatchFn(&batch, fn, true, rel...)
}

func (ex *Exchange6[A, B, C, D, E, F]) exchangeBatchFn(batch *Batch, fn func(Entity, *A, *B, *C, *D, *E, *F), remove bool, rel ...Relation) {
	ex.relations = relationSlice(rel).ToRelations(ex.world, &ex.mask, ex.ids, ex.relations[:0], false)

	var process func(tableID tableID, start, len uint32)
	if fn != nil {
		process = func(tableID tableID, start, len uint32) {
			table := &ex.world.storage.tables[tableID]
			columnA := table.Column(ex.ids[0])
			columnB := table.Column(ex.ids[1])
			columnC := table.Column(ex.ids[2])
			columnD := table.Column(ex.ids[3])
			columnE := table.Column(ex.ids[4])
			columnF := table.Column(ex.ids[5])

			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
					(*D)(columnD.Get(index)),
					(*E)(columnE.Get(index)),
					(*F)(columnF.Get(index)),
				)
			}
		}
	}
	if remove {
		ex.world.exchangeBatch(batch, ex.ids, ex.remove, ex.relations, process)
	} else {
		ex.world.exchangeBatch(batch, ex.ids, nil, ex.relations, process)
	}
}

func (ex *Exchange6[A, B, C, D, E, F]) runCallback(entity Entity, fn func(a *A, b *B, c *C, d *D, e *E, f *F)) {
	index := &ex.world.storage.entities[entity.id]
	table := &ex.world.storage.tables[index.table]
	row := uintptr(index.row)
	fn(
		(*A)(table.Column(ex.ids[0]).Get(row)),
		(*B)(table.Column(ex.ids[1]).Get(row)),
		(*C)(table.Column(ex.ids[2]).Get(row)),
		(*D)(table.Column(ex.ids[3]).Get(row)),
		(*E)(table.Column(ex.ids[4]).Get(row)),
		(*F)(table.Column(ex.ids[5]).Get(row)),
	)
}

// Exchange7 allows to exchange components of entities.
// It adds the given components. Use [Exchange7.Removes]
// to set components to be removed.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Exchange2] for a usage example.
type Exchange7[A any, B any, C any, D any, E any, F any, G any] struct {
	world     *World
	ids       []ID
	remove    []ID
	relations []relationID
	mask      bitMask
}

// New creates a new [Exchange7]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
//
// See [Exchange2.New] for an example.
func (*Exchange7[A, B, C, D, E, F, G]) New(world *World) *Exchange7[A, B, C, D, E, F, G] {
	return NewExchange7[A, B, C, D, E, F, G](world)
}

// NewExchange7 creates an [Exchange7].
//
// See also [Exchange7.New] for a shortcut when constructing an already defined instance.
func NewExchange7[A any, B any, C any, D any, E any, F any, G any](world *World) *Exchange7[A, B, C, D, E, F, G] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
		ComponentID[F](world),
		ComponentID[G](world),
	}
	return &Exchange7[A, B, C, D, E, F, G]{
		world: world,
		ids:   ids,
		mask:  newMask(ids...),
	}
}

// Removes sets the components that this [Exchange7] removes.
// Can be called multiple times in chains, or once with multiple arguments.
func (ex *Exchange7[A, B, C, D, E, F, G]) Removes(components ...Comp) *Exchange7[A, B, C, D, E, F, G] {
	for _, c := range components {
		ex.remove = append(ex.remove, ex.world.componentID(c.tp))
	}
	return ex
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (ex *Exchange7[A, B, C, D, E, F, G]) Add(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, rel ...Relation) {
	ex.AddFn(entity, func(pa *A, pb *B, pc *C, pd *D, pe *E, pf *F, pg *G) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
		*pg = *g
	}, rel...)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange7[A, B, C, D, E, F, G]) AddFn(entity Entity, fn func(*A, *B, *C, *D, *E, *F, *G), rel ...Relation) {
	ex.relations = relationSlice(rel).ToRelations(ex.world, &ex.mask, ex.ids, ex.relations[:0], false)
	oldMask, newMask := ex.world.add(entity, ex.ids, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
	ex.world.storage.observers.FireAddIfHas(OnAddComponents, entity, oldMask, newMask)
	if len(rel) > 0 {
		ex.world.storage.observers.FireAddIfHas(OnAddRelations, entity, oldMask, newMask)
	}
}

// Remove the components previously specified with [Exchange7.Removes] from the given entity.
func (ex *Exchange7[A, B, C, D, E, F, G]) Remove(entity Entity) {
	ex.world.remove(entity, ex.remove)
}

// Exchange performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange7.Removes].
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (ex *Exchange7[A, B, C, D, E, F, G]) Exchange(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, rel ...Relation) {
	ex.ExchangeFn(entity, func(pa *A, pb *B, pc *C, pd *D, pe *E, pf *F, pg *G) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
		*pg = *g
	}, rel...)

}

// ExchangeFn performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange7.Removes].
// It runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange7[A, B, C, D, E, F, G]) ExchangeFn(entity Entity, fn func(*A, *B, *C, *D, *E, *F, *G), rel ...Relation) {
	ex.relations = relationSlice(rel).ToRelations(ex.world, &ex.mask, ex.ids, ex.relations[:0], false)
	oldMask, newMask := ex.world.exchange(entity, ex.ids, ex.remove, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
	ex.world.storage.observers.FireAddIfHas(OnAddComponents, entity, oldMask, newMask)
	if len(rel) > 0 {
		ex.world.storage.observers.FireAddIfHas(OnAddRelations, entity, oldMask, newMask)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (ex *Exchange7[A, B, C, D, E, F, G]) AddBatch(batch Batch, a *A, b *B, c *C, d *D, e *E, f *F, g *G, rel ...Relation) {
	ex.AddBatchFn(batch, func(_ Entity, pa *A, pb *B, pc *C, pd *D, pe *E, pf *F, pg *G) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
		*pg = *g
	}, rel...)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange7[A, B, C, D, E, F, G]) AddBatchFn(batch Batch, fn func(Entity, *A, *B, *C, *D, *E, *F, *G), rel ...Relation) {
	ex.exchangeBatchFn(&batch, fn, false, rel...)
}

// RemoveBatch removes the components previously specified with [Exchange7.Removes]
// from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (ex *Exchange7[A, B, C, D, E, F, G]) RemoveBatch(batch Batch, fn func(entity Entity)) {
	removeBatch(ex.world, &batch, ex.remove, fn)
}

// ExchangeBatch performs the exchange on all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (ex *Exchange7[A, B, C, D, E, F, G]) ExchangeBatch(batch Batch, a *A, b *B, c *C, d *D, e *E, f *F, g *G, rel ...Relation) {
	ex.ExchangeBatchFn(batch, func(_ Entity, pa *A, pb *B, pc *C, pd *D, pe *E, pf *F, pg *G) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
		*pg = *g
	}, rel...)
}

// ExchangeBatchFn performs the exchange on all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange7[A, B, C, D, E, F, G]) ExchangeBatchFn(batch Batch, fn func(Entity, *A, *B, *C, *D, *E, *F, *G), rel ...Relation) {
	ex.exchangeBatchFn(&batch, fn, true, rel...)
}

func (ex *Exchange7[A, B, C, D, E, F, G]) exchangeBatchFn(batch *Batch, fn func(Entity, *A, *B, *C, *D, *E, *F, *G), remove bool, rel ...Relation) {
	ex.relations = relationSlice(rel).ToRelations(ex.world, &ex.mask, ex.ids, ex.relations[:0], false)

	var process func(tableID tableID, start, len uint32)
	if fn != nil {
		process = func(tableID tableID, start, len uint32) {
			table := &ex.world.storage.tables[tableID]
			columnA := table.Column(ex.ids[0])
			columnB := table.Column(ex.ids[1])
			columnC := table.Column(ex.ids[2])
			columnD := table.Column(ex.ids[3])
			columnE := table.Column(ex.ids[4])
			columnF := table.Column(ex.ids[5])
			columnG := table.Column(ex.ids[6])

			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
					(*D)(columnD.Get(index)),
					(*E)(columnE.Get(index)),
					(*F)(columnF.Get(index)),
					(*G)(columnG.Get(index)),
				)
			}
		}
	}
	if remove {
		ex.world.exchangeBatch(batch, ex.ids, ex.remove, ex.relations, process)
	} else {
		ex.world.exchangeBatch(batch, ex.ids, nil, ex.relations, process)
	}
}

func (ex *Exchange7[A, B, C, D, E, F, G]) runCallback(entity Entity, fn func(a *A, b *B, c *C, d *D, e *E, f *F, g *G)) {
	index := &ex.world.storage.entities[entity.id]
	table := &ex.world.storage.tables[index.table]
	row := uintptr(index.row)
	fn(
		(*A)(table.Column(ex.ids[0]).Get(row)),
		(*B)(table.Column(ex.ids[1]).Get(row)),
		(*C)(table.Column(ex.ids[2]).Get(row)),
		(*D)(table.Column(ex.ids[3]).Get(row)),
		(*E)(table.Column(ex.ids[4]).Get(row)),
		(*F)(table.Column(ex.ids[5]).Get(row)),
		(*G)(table.Column(ex.ids[6]).Get(row)),
	)
}

// Exchange8 allows to exchange components of entities.
// It adds the given components. Use [Exchange8.Removes]
// to set components to be removed.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Exchange2] for a usage example.
type Exchange8[A any, B any, C any, D any, E any, F any, G any, H any] struct {
	world     *World
	ids       []ID
	remove    []ID
	relations []relationID
	mask      bitMask
}

// New creates a new [Exchange8]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
//
// See [Exchange2.New] for an example.
func (*Exchange8[A, B, C, D, E, F, G, H]) New(world *World) *Exchange8[A, B, C, D, E, F, G, H] {
	return NewExchange8[A, B, C, D, E, F, G, H](world)
}

// NewExchange8 creates an [Exchange8].
//
// See also [Exchange8.New] for a shortcut when constructing an already defined instance.
func NewExchange8[A any, B any, C any, D any, E any, F any, G any, H any](world *World) *Exchange8[A, B, C, D, E, F, G, H] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
		ComponentID[F](world),
		ComponentID[G](world),
		ComponentID[H](world),
	}
	return &Exchange8[A, B, C, D, E, F, G, H]{
		world: world,
		ids:   ids,
		mask:  newMask(ids...),
	}
}

// Removes sets the components that this [Exchange8] removes.
// Can be called multiple times in chains, or once with multiple arguments.
func (ex *Exchange8[A, B, C, D, E, F, G, H]) Removes(components ...Comp) *Exchange8[A, B, C, D, E, F, G, H] {
	for _, c := range components {
		ex.remove = append(ex.remove, ex.world.componentID(c.tp))
	}
	return ex
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (ex *Exchange8[A, B, C, D, E, F, G, H]) Add(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, rel ...Relation) {
	ex.AddFn(entity, func(pa *A, pb *B, pc *C, pd *D, pe *E, pf *F, pg *G, ph *H) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
		*pg = *g
		*ph = *h
	}, rel...)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange8[A, B, C, D, E, F, G, H]) AddFn(entity Entity, fn func(*A, *B, *C, *D, *E, *F, *G, *H), rel ...Relation) {
	ex.relations = relationSlice(rel).ToRelations(ex.world, &ex.mask, ex.ids, ex.relations[:0], false)
	oldMask, newMask := ex.world.add(entity, ex.ids, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
	ex.world.storage.observers.FireAddIfHas(OnAddComponents, entity, oldMask, newMask)
	if len(rel) > 0 {
		ex.world.storage.observers.FireAddIfHas(OnAddRelations, entity, oldMask, newMask)
	}
}

// Remove the components previously specified with [Exchange8.Removes] from the given entity.
func (ex *Exchange8[A, B, C, D, E, F, G, H]) Remove(entity Entity) {
	ex.world.remove(entity, ex.remove)
}

// Exchange performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange8.Removes].
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (ex *Exchange8[A, B, C, D, E, F, G, H]) Exchange(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, rel ...Relation) {
	ex.ExchangeFn(entity, func(pa *A, pb *B, pc *C, pd *D, pe *E, pf *F, pg *G, ph *H) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
		*pg = *g
		*ph = *h
	}, rel...)

}

// ExchangeFn performs the exchange on the given entity, adding the provided components
// and removing those previously specified with [Exchange8.Removes].
// It runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange8[A, B, C, D, E, F, G, H]) ExchangeFn(entity Entity, fn func(*A, *B, *C, *D, *E, *F, *G, *H), rel ...Relation) {
	ex.relations = relationSlice(rel).ToRelations(ex.world, &ex.mask, ex.ids, ex.relations[:0], false)
	oldMask, newMask := ex.world.exchange(entity, ex.ids, ex.remove, ex.relations)
	if fn != nil {
		ex.runCallback(entity, fn)
	}
	ex.world.storage.observers.FireAddIfHas(OnAddComponents, entity, oldMask, newMask)
	if len(rel) > 0 {
		ex.world.storage.observers.FireAddIfHas(OnAddRelations, entity, oldMask, newMask)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (ex *Exchange8[A, B, C, D, E, F, G, H]) AddBatch(batch Batch, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, rel ...Relation) {
	ex.AddBatchFn(batch, func(_ Entity, pa *A, pb *B, pc *C, pd *D, pe *E, pf *F, pg *G, ph *H) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
		*pg = *g
		*ph = *h
	}, rel...)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange8[A, B, C, D, E, F, G, H]) AddBatchFn(batch Batch, fn func(Entity, *A, *B, *C, *D, *E, *F, *G, *H), rel ...Relation) {
	ex.exchangeBatchFn(&batch, fn, false, rel...)
}

// RemoveBatch removes the components previously specified with [Exchange8.Removes]
// from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (ex *Exchange8[A, B, C, D, E, F, G, H]) RemoveBatch(batch Batch, fn func(entity Entity)) {
	removeBatch(ex.world, &batch, ex.remove, fn)
}

// ExchangeBatch performs the exchange on all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (ex *Exchange8[A, B, C, D, E, F, G, H]) ExchangeBatch(batch Batch, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, rel ...Relation) {
	ex.ExchangeBatchFn(batch, func(_ Entity, pa *A, pb *B, pc *C, pd *D, pe *E, pf *F, pg *G, ph *H) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
		*pg = *g
		*ph = *h
	}, rel...)
}

// ExchangeBatchFn performs the exchange on all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (ex *Exchange8[A, B, C, D, E, F, G, H]) ExchangeBatchFn(batch Batch, fn func(Entity, *A, *B, *C, *D, *E, *F, *G, *H), rel ...Relation) {
	ex.exchangeBatchFn(&batch, fn, true, rel...)
}

func (ex *Exchange8[A, B, C, D, E, F, G, H]) exchangeBatchFn(batch *Batch, fn func(Entity, *A, *B, *C, *D, *E, *F, *G, *H), remove bool, rel ...Relation) {
	ex.relations = relationSlice(rel).ToRelations(ex.world, &ex.mask, ex.ids, ex.relations[:0], false)

	var process func(tableID tableID, start, len uint32)
	if fn != nil {
		process = func(tableID tableID, start, len uint32) {
			table := &ex.world.storage.tables[tableID]
			columnA := table.Column(ex.ids[0])
			columnB := table.Column(ex.ids[1])
			columnC := table.Column(ex.ids[2])
			columnD := table.Column(ex.ids[3])
			columnE := table.Column(ex.ids[4])
			columnF := table.Column(ex.ids[5])
			columnG := table.Column(ex.ids[6])
			columnH := table.Column(ex.ids[7])

			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
					(*D)(columnD.Get(index)),
					(*E)(columnE.Get(index)),
					(*F)(columnF.Get(index)),
					(*G)(columnG.Get(index)),
					(*H)(columnH.Get(index)),
				)
			}
		}
	}
	if remove {
		ex.world.exchangeBatch(batch, ex.ids, ex.remove, ex.relations, process)
	} else {
		ex.world.exchangeBatch(batch, ex.ids, nil, ex.relations, process)
	}
}

func (ex *Exchange8[A, B, C, D, E, F, G, H]) runCallback(entity Entity, fn func(a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H)) {
	index := &ex.world.storage.entities[entity.id]
	table := &ex.world.storage.tables[index.table]
	row := uintptr(index.row)
	fn(
		(*A)(table.Column(ex.ids[0]).Get(row)),
		(*B)(table.Column(ex.ids[1]).Get(row)),
		(*C)(table.Column(ex.ids[2]).Get(row)),
		(*D)(table.Column(ex.ids[3]).Get(row)),
		(*E)(table.Column(ex.ids[4]).Get(row)),
		(*F)(table.Column(ex.ids[5]).Get(row)),
		(*G)(table.Column(ex.ids[6]).Get(row)),
		(*H)(table.Column(ex.ids[7]).Get(row)),
	)
}
