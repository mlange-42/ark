package ecs

// Code generated by go generate; DO NOT EDIT.

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestMap1(t *testing.T) {
	n := 12
	w := NewWorld(4)

	mapper := NewMap1[CompA](&w)

	entities := []Entity{}
	for range n {
		e := mapper.NewEntity(&CompA{})
		entities = append(entities, e)
		e = w.NewEntity()
		mapper.Add(e, &CompA{})
		entities = append(entities, e)
	}

	for _, e := range entities {
		_ = mapper.Get(e)
		assert.True(t, mapper.HasAll(e))
	}

	for _, e := range entities {
		mapper.Remove(e)
		assert.False(t, mapper.HasAll(e))
	}

	assert.Panics(t, func() {
		mapper.Get(Entity{})
	})
	assert.Panics(t, func() {
		mapper.HasAll(Entity{})
	})
	assert.Panics(t, func() {
		mapper.Add(Entity{}, &CompA{})
	})
	assert.Panics(t, func() {
		mapper.Remove(Entity{})
	})
}

func TestMap1NewBatch(t *testing.T) {
	n := 12
	w := NewWorld(8)

	mapper := NewMap1[CompA](&w)

	for range n {
		_ = mapper.NewEntity(&CompA{})
	}
	mapper.NewBatch(n*2, &CompA{})

	filter := NewFilter1[CompA](&w)
	query := filter.Query()
	cnt := 0
	var lastEntity Entity
	for query.Next() {
		_ = query.Get()
		lastEntity = query.Entity()
		cnt++
	}
	assert.True(t, mapper.HasAll(lastEntity))
	assert.Equal(t, n*3, cnt)
}

func TestMap1NewBatchFn(t *testing.T) {
	n := 12
	w := NewWorld(8)

	mapper := NewMap1[CompA](&w)

	for range n {
		_ = mapper.NewEntity(&CompA{})
	}
	mapper.NewBatchFn(2*n, func(entity Entity, a *CompA) {
		a.X = 5
		a.Y = 6
	})

	filter := NewFilter1[CompA](&w)
	query := filter.Query()
	cnt := 0
	var lastEntity Entity
	for query.Next() {
		_ = query.Get()
		lastEntity = query.Entity()
		cnt++
	}
	assert.True(t, mapper.HasAll(lastEntity))
	assert.Equal(t, 3*n, cnt)
}

func TestMap1Relations(t *testing.T) {
	w := NewWorld(8)

	mapper := NewMap1[ChildOf](&w)

	parent1 := w.NewEntity()
	parent2 := w.NewEntity()

	e := mapper.NewEntity(&ChildOf{}, Rel(0, parent1))
	assert.Equal(t, parent1, mapper.GetRelation(e, 0))
	assert.Equal(t, parent1, mapper.GetRelationUnchecked(e, 0))

	mapper.SetRelations(e, Rel(0, parent2))
	assert.Equal(t, parent2, mapper.GetRelation(e, 0))

	assert.Panics(t, func() {
		mapper.SetRelations(Entity{}, Rel(0, parent2))
	})
	assert.Panics(t, func() {
		mapper.GetRelation(Entity{}, 0)
	})
}

func TestMap2(t *testing.T) {
	n := 12
	w := NewWorld(4)

	mapper := NewMap2[CompA, CompB](&w)

	entities := []Entity{}
	for range n {
		e := mapper.NewEntity(&CompA{}, &CompB{})
		entities = append(entities, e)
		e = w.NewEntity()
		mapper.Add(e, &CompA{}, &CompB{})
		entities = append(entities, e)
	}

	for _, e := range entities {
		_, _ = mapper.Get(e)
		assert.True(t, mapper.HasAll(e))
	}

	for _, e := range entities {
		mapper.Remove(e)
		assert.False(t, mapper.HasAll(e))
	}

	assert.Panics(t, func() {
		mapper.Get(Entity{})
	})
	assert.Panics(t, func() {
		mapper.HasAll(Entity{})
	})
	assert.Panics(t, func() {
		mapper.Add(Entity{}, &CompA{}, &CompB{})
	})
	assert.Panics(t, func() {
		mapper.Remove(Entity{})
	})
}

func TestMap2NewBatch(t *testing.T) {
	n := 12
	w := NewWorld(8)

	mapper := NewMap2[CompA, CompB](&w)

	for range n {
		_ = mapper.NewEntity(&CompA{}, &CompB{})
	}
	mapper.NewBatch(n*2, &CompA{}, &CompB{})

	filter := NewFilter2[CompA, CompB](&w)
	query := filter.Query()
	cnt := 0
	var lastEntity Entity
	for query.Next() {
		_, _ = query.Get()
		lastEntity = query.Entity()
		cnt++
	}
	assert.True(t, mapper.HasAll(lastEntity))
	assert.Equal(t, n*3, cnt)
}

func TestMap2NewBatchFn(t *testing.T) {
	n := 12
	w := NewWorld(8)

	mapper := NewMap2[CompA, CompB](&w)

	for range n {
		_ = mapper.NewEntity(&CompA{}, &CompB{})
	}
	mapper.NewBatchFn(2*n, func(entity Entity, a *CompA, b *CompB) {
		a.X = 5
		a.Y = 6
	})

	filter := NewFilter2[CompA, CompB](&w)
	query := filter.Query()
	cnt := 0
	var lastEntity Entity
	for query.Next() {
		_, _ = query.Get()
		lastEntity = query.Entity()
		cnt++
	}
	assert.True(t, mapper.HasAll(lastEntity))
	assert.Equal(t, 3*n, cnt)
}

func TestMap2Relations(t *testing.T) {
	w := NewWorld(8)

	mapper := NewMap2[ChildOf, CompB](&w)

	parent1 := w.NewEntity()
	parent2 := w.NewEntity()

	e := mapper.NewEntity(&ChildOf{}, &CompB{}, Rel(0, parent1))
	assert.Equal(t, parent1, mapper.GetRelation(e, 0))
	assert.Equal(t, parent1, mapper.GetRelationUnchecked(e, 0))

	mapper.SetRelations(e, Rel(0, parent2))
	assert.Equal(t, parent2, mapper.GetRelation(e, 0))

	assert.Panics(t, func() {
		mapper.SetRelations(Entity{}, Rel(0, parent2))
	})
	assert.Panics(t, func() {
		mapper.GetRelation(Entity{}, 0)
	})
}

func TestMap3(t *testing.T) {
	n := 12
	w := NewWorld(4)

	mapper := NewMap3[CompA, CompB, CompC](&w)

	entities := []Entity{}
	for range n {
		e := mapper.NewEntity(&CompA{}, &CompB{}, &CompC{})
		entities = append(entities, e)
		e = w.NewEntity()
		mapper.Add(e, &CompA{}, &CompB{}, &CompC{})
		entities = append(entities, e)
	}

	for _, e := range entities {
		_, _, _ = mapper.Get(e)
		assert.True(t, mapper.HasAll(e))
	}

	for _, e := range entities {
		mapper.Remove(e)
		assert.False(t, mapper.HasAll(e))
	}

	assert.Panics(t, func() {
		mapper.Get(Entity{})
	})
	assert.Panics(t, func() {
		mapper.HasAll(Entity{})
	})
	assert.Panics(t, func() {
		mapper.Add(Entity{}, &CompA{}, &CompB{}, &CompC{})
	})
	assert.Panics(t, func() {
		mapper.Remove(Entity{})
	})
}

func TestMap3NewBatch(t *testing.T) {
	n := 12
	w := NewWorld(8)

	mapper := NewMap3[CompA, CompB, CompC](&w)

	for range n {
		_ = mapper.NewEntity(&CompA{}, &CompB{}, &CompC{})
	}
	mapper.NewBatch(n*2, &CompA{}, &CompB{}, &CompC{})

	filter := NewFilter3[CompA, CompB, CompC](&w)
	query := filter.Query()
	cnt := 0
	var lastEntity Entity
	for query.Next() {
		_, _, _ = query.Get()
		lastEntity = query.Entity()
		cnt++
	}
	assert.True(t, mapper.HasAll(lastEntity))
	assert.Equal(t, n*3, cnt)
}

func TestMap3NewBatchFn(t *testing.T) {
	n := 12
	w := NewWorld(8)

	mapper := NewMap3[CompA, CompB, CompC](&w)

	for range n {
		_ = mapper.NewEntity(&CompA{}, &CompB{}, &CompC{})
	}
	mapper.NewBatchFn(2*n, func(entity Entity, a *CompA, b *CompB, c *CompC) {
		a.X = 5
		a.Y = 6
	})

	filter := NewFilter3[CompA, CompB, CompC](&w)
	query := filter.Query()
	cnt := 0
	var lastEntity Entity
	for query.Next() {
		_, _, _ = query.Get()
		lastEntity = query.Entity()
		cnt++
	}
	assert.True(t, mapper.HasAll(lastEntity))
	assert.Equal(t, 3*n, cnt)
}

func TestMap3Relations(t *testing.T) {
	w := NewWorld(8)

	mapper := NewMap3[ChildOf, CompB, CompC](&w)

	parent1 := w.NewEntity()
	parent2 := w.NewEntity()

	e := mapper.NewEntity(&ChildOf{}, &CompB{}, &CompC{}, Rel(0, parent1))
	assert.Equal(t, parent1, mapper.GetRelation(e, 0))
	assert.Equal(t, parent1, mapper.GetRelationUnchecked(e, 0))

	mapper.SetRelations(e, Rel(0, parent2))
	assert.Equal(t, parent2, mapper.GetRelation(e, 0))

	assert.Panics(t, func() {
		mapper.SetRelations(Entity{}, Rel(0, parent2))
	})
	assert.Panics(t, func() {
		mapper.GetRelation(Entity{}, 0)
	})
}

func TestMap4(t *testing.T) {
	n := 12
	w := NewWorld(4)

	mapper := NewMap4[CompA, CompB, CompC, CompD](&w)

	entities := []Entity{}
	for range n {
		e := mapper.NewEntity(&CompA{}, &CompB{}, &CompC{}, &CompD{})
		entities = append(entities, e)
		e = w.NewEntity()
		mapper.Add(e, &CompA{}, &CompB{}, &CompC{}, &CompD{})
		entities = append(entities, e)
	}

	for _, e := range entities {
		_, _, _, _ = mapper.Get(e)
		assert.True(t, mapper.HasAll(e))
	}

	for _, e := range entities {
		mapper.Remove(e)
		assert.False(t, mapper.HasAll(e))
	}

	assert.Panics(t, func() {
		mapper.Get(Entity{})
	})
	assert.Panics(t, func() {
		mapper.HasAll(Entity{})
	})
	assert.Panics(t, func() {
		mapper.Add(Entity{}, &CompA{}, &CompB{}, &CompC{}, &CompD{})
	})
	assert.Panics(t, func() {
		mapper.Remove(Entity{})
	})
}

func TestMap4NewBatch(t *testing.T) {
	n := 12
	w := NewWorld(8)

	mapper := NewMap4[CompA, CompB, CompC, CompD](&w)

	for range n {
		_ = mapper.NewEntity(&CompA{}, &CompB{}, &CompC{}, &CompD{})
	}
	mapper.NewBatch(n*2, &CompA{}, &CompB{}, &CompC{}, &CompD{})

	filter := NewFilter4[CompA, CompB, CompC, CompD](&w)
	query := filter.Query()
	cnt := 0
	var lastEntity Entity
	for query.Next() {
		_, _, _, _ = query.Get()
		lastEntity = query.Entity()
		cnt++
	}
	assert.True(t, mapper.HasAll(lastEntity))
	assert.Equal(t, n*3, cnt)
}

func TestMap4NewBatchFn(t *testing.T) {
	n := 12
	w := NewWorld(8)

	mapper := NewMap4[CompA, CompB, CompC, CompD](&w)

	for range n {
		_ = mapper.NewEntity(&CompA{}, &CompB{}, &CompC{}, &CompD{})
	}
	mapper.NewBatchFn(2*n, func(entity Entity, a *CompA, b *CompB, c *CompC, d *CompD) {
		a.X = 5
		a.Y = 6
	})

	filter := NewFilter4[CompA, CompB, CompC, CompD](&w)
	query := filter.Query()
	cnt := 0
	var lastEntity Entity
	for query.Next() {
		_, _, _, _ = query.Get()
		lastEntity = query.Entity()
		cnt++
	}
	assert.True(t, mapper.HasAll(lastEntity))
	assert.Equal(t, 3*n, cnt)
}

func TestMap4Relations(t *testing.T) {
	w := NewWorld(8)

	mapper := NewMap4[ChildOf, CompB, CompC, CompD](&w)

	parent1 := w.NewEntity()
	parent2 := w.NewEntity()

	e := mapper.NewEntity(&ChildOf{}, &CompB{}, &CompC{}, &CompD{}, Rel(0, parent1))
	assert.Equal(t, parent1, mapper.GetRelation(e, 0))
	assert.Equal(t, parent1, mapper.GetRelationUnchecked(e, 0))

	mapper.SetRelations(e, Rel(0, parent2))
	assert.Equal(t, parent2, mapper.GetRelation(e, 0))

	assert.Panics(t, func() {
		mapper.SetRelations(Entity{}, Rel(0, parent2))
	})
	assert.Panics(t, func() {
		mapper.GetRelation(Entity{}, 0)
	})
}

func TestMap5(t *testing.T) {
	n := 12
	w := NewWorld(4)

	mapper := NewMap5[CompA, CompB, CompC, CompD, CompE](&w)

	entities := []Entity{}
	for range n {
		e := mapper.NewEntity(&CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{})
		entities = append(entities, e)
		e = w.NewEntity()
		mapper.Add(e, &CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{})
		entities = append(entities, e)
	}

	for _, e := range entities {
		_, _, _, _, _ = mapper.Get(e)
		assert.True(t, mapper.HasAll(e))
	}

	for _, e := range entities {
		mapper.Remove(e)
		assert.False(t, mapper.HasAll(e))
	}

	assert.Panics(t, func() {
		mapper.Get(Entity{})
	})
	assert.Panics(t, func() {
		mapper.HasAll(Entity{})
	})
	assert.Panics(t, func() {
		mapper.Add(Entity{}, &CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{})
	})
	assert.Panics(t, func() {
		mapper.Remove(Entity{})
	})
}

func TestMap5NewBatch(t *testing.T) {
	n := 12
	w := NewWorld(8)

	mapper := NewMap5[CompA, CompB, CompC, CompD, CompE](&w)

	for range n {
		_ = mapper.NewEntity(&CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{})
	}
	mapper.NewBatch(n*2, &CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{})

	filter := NewFilter5[CompA, CompB, CompC, CompD, CompE](&w)
	query := filter.Query()
	cnt := 0
	var lastEntity Entity
	for query.Next() {
		_, _, _, _, _ = query.Get()
		lastEntity = query.Entity()
		cnt++
	}
	assert.True(t, mapper.HasAll(lastEntity))
	assert.Equal(t, n*3, cnt)
}

func TestMap5NewBatchFn(t *testing.T) {
	n := 12
	w := NewWorld(8)

	mapper := NewMap5[CompA, CompB, CompC, CompD, CompE](&w)

	for range n {
		_ = mapper.NewEntity(&CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{})
	}
	mapper.NewBatchFn(2*n, func(entity Entity, a *CompA, b *CompB, c *CompC, d *CompD, e *CompE) {
		a.X = 5
		a.Y = 6
	})

	filter := NewFilter5[CompA, CompB, CompC, CompD, CompE](&w)
	query := filter.Query()
	cnt := 0
	var lastEntity Entity
	for query.Next() {
		_, _, _, _, _ = query.Get()
		lastEntity = query.Entity()
		cnt++
	}
	assert.True(t, mapper.HasAll(lastEntity))
	assert.Equal(t, 3*n, cnt)
}

func TestMap5Relations(t *testing.T) {
	w := NewWorld(8)

	mapper := NewMap5[ChildOf, CompB, CompC, CompD, CompE](&w)

	parent1 := w.NewEntity()
	parent2 := w.NewEntity()

	e := mapper.NewEntity(&ChildOf{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, Rel(0, parent1))
	assert.Equal(t, parent1, mapper.GetRelation(e, 0))
	assert.Equal(t, parent1, mapper.GetRelationUnchecked(e, 0))

	mapper.SetRelations(e, Rel(0, parent2))
	assert.Equal(t, parent2, mapper.GetRelation(e, 0))

	assert.Panics(t, func() {
		mapper.SetRelations(Entity{}, Rel(0, parent2))
	})
	assert.Panics(t, func() {
		mapper.GetRelation(Entity{}, 0)
	})
}

func TestMap6(t *testing.T) {
	n := 12
	w := NewWorld(4)

	mapper := NewMap6[CompA, CompB, CompC, CompD, CompE, CompF](&w)

	entities := []Entity{}
	for range n {
		e := mapper.NewEntity(&CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{})
		entities = append(entities, e)
		e = w.NewEntity()
		mapper.Add(e, &CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{})
		entities = append(entities, e)
	}

	for _, e := range entities {
		_, _, _, _, _, _ = mapper.Get(e)
		assert.True(t, mapper.HasAll(e))
	}

	for _, e := range entities {
		mapper.Remove(e)
		assert.False(t, mapper.HasAll(e))
	}

	assert.Panics(t, func() {
		mapper.Get(Entity{})
	})
	assert.Panics(t, func() {
		mapper.HasAll(Entity{})
	})
	assert.Panics(t, func() {
		mapper.Add(Entity{}, &CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{})
	})
	assert.Panics(t, func() {
		mapper.Remove(Entity{})
	})
}

func TestMap6NewBatch(t *testing.T) {
	n := 12
	w := NewWorld(8)

	mapper := NewMap6[CompA, CompB, CompC, CompD, CompE, CompF](&w)

	for range n {
		_ = mapper.NewEntity(&CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{})
	}
	mapper.NewBatch(n*2, &CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{})

	filter := NewFilter6[CompA, CompB, CompC, CompD, CompE, CompF](&w)
	query := filter.Query()
	cnt := 0
	var lastEntity Entity
	for query.Next() {
		_, _, _, _, _, _ = query.Get()
		lastEntity = query.Entity()
		cnt++
	}
	assert.True(t, mapper.HasAll(lastEntity))
	assert.Equal(t, n*3, cnt)
}

func TestMap6NewBatchFn(t *testing.T) {
	n := 12
	w := NewWorld(8)

	mapper := NewMap6[CompA, CompB, CompC, CompD, CompE, CompF](&w)

	for range n {
		_ = mapper.NewEntity(&CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{})
	}
	mapper.NewBatchFn(2*n, func(entity Entity, a *CompA, b *CompB, c *CompC, d *CompD, e *CompE, f *CompF) {
		a.X = 5
		a.Y = 6
	})

	filter := NewFilter6[CompA, CompB, CompC, CompD, CompE, CompF](&w)
	query := filter.Query()
	cnt := 0
	var lastEntity Entity
	for query.Next() {
		_, _, _, _, _, _ = query.Get()
		lastEntity = query.Entity()
		cnt++
	}
	assert.True(t, mapper.HasAll(lastEntity))
	assert.Equal(t, 3*n, cnt)
}

func TestMap6Relations(t *testing.T) {
	w := NewWorld(8)

	mapper := NewMap6[ChildOf, CompB, CompC, CompD, CompE, CompF](&w)

	parent1 := w.NewEntity()
	parent2 := w.NewEntity()

	e := mapper.NewEntity(&ChildOf{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{}, Rel(0, parent1))
	assert.Equal(t, parent1, mapper.GetRelation(e, 0))
	assert.Equal(t, parent1, mapper.GetRelationUnchecked(e, 0))

	mapper.SetRelations(e, Rel(0, parent2))
	assert.Equal(t, parent2, mapper.GetRelation(e, 0))

	assert.Panics(t, func() {
		mapper.SetRelations(Entity{}, Rel(0, parent2))
	})
	assert.Panics(t, func() {
		mapper.GetRelation(Entity{}, 0)
	})
}

func TestMap7(t *testing.T) {
	n := 12
	w := NewWorld(4)

	mapper := NewMap7[CompA, CompB, CompC, CompD, CompE, CompF, CompG](&w)

	entities := []Entity{}
	for range n {
		e := mapper.NewEntity(&CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{}, &CompG{})
		entities = append(entities, e)
		e = w.NewEntity()
		mapper.Add(e, &CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{}, &CompG{})
		entities = append(entities, e)
	}

	for _, e := range entities {
		_, _, _, _, _, _, _ = mapper.Get(e)
		assert.True(t, mapper.HasAll(e))
	}

	for _, e := range entities {
		mapper.Remove(e)
		assert.False(t, mapper.HasAll(e))
	}

	assert.Panics(t, func() {
		mapper.Get(Entity{})
	})
	assert.Panics(t, func() {
		mapper.HasAll(Entity{})
	})
	assert.Panics(t, func() {
		mapper.Add(Entity{}, &CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{}, &CompG{})
	})
	assert.Panics(t, func() {
		mapper.Remove(Entity{})
	})
}

func TestMap7NewBatch(t *testing.T) {
	n := 12
	w := NewWorld(8)

	mapper := NewMap7[CompA, CompB, CompC, CompD, CompE, CompF, CompG](&w)

	for range n {
		_ = mapper.NewEntity(&CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{}, &CompG{})
	}
	mapper.NewBatch(n*2, &CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{}, &CompG{})

	filter := NewFilter7[CompA, CompB, CompC, CompD, CompE, CompF, CompG](&w)
	query := filter.Query()
	cnt := 0
	var lastEntity Entity
	for query.Next() {
		_, _, _, _, _, _, _ = query.Get()
		lastEntity = query.Entity()
		cnt++
	}
	assert.True(t, mapper.HasAll(lastEntity))
	assert.Equal(t, n*3, cnt)
}

func TestMap7NewBatchFn(t *testing.T) {
	n := 12
	w := NewWorld(8)

	mapper := NewMap7[CompA, CompB, CompC, CompD, CompE, CompF, CompG](&w)

	for range n {
		_ = mapper.NewEntity(&CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{}, &CompG{})
	}
	mapper.NewBatchFn(2*n, func(entity Entity, a *CompA, b *CompB, c *CompC, d *CompD, e *CompE, f *CompF, g *CompG) {
		a.X = 5
		a.Y = 6
	})

	filter := NewFilter7[CompA, CompB, CompC, CompD, CompE, CompF, CompG](&w)
	query := filter.Query()
	cnt := 0
	var lastEntity Entity
	for query.Next() {
		_, _, _, _, _, _, _ = query.Get()
		lastEntity = query.Entity()
		cnt++
	}
	assert.True(t, mapper.HasAll(lastEntity))
	assert.Equal(t, 3*n, cnt)
}

func TestMap7Relations(t *testing.T) {
	w := NewWorld(8)

	mapper := NewMap7[ChildOf, CompB, CompC, CompD, CompE, CompF, CompG](&w)

	parent1 := w.NewEntity()
	parent2 := w.NewEntity()

	e := mapper.NewEntity(&ChildOf{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{}, &CompG{}, Rel(0, parent1))
	assert.Equal(t, parent1, mapper.GetRelation(e, 0))
	assert.Equal(t, parent1, mapper.GetRelationUnchecked(e, 0))

	mapper.SetRelations(e, Rel(0, parent2))
	assert.Equal(t, parent2, mapper.GetRelation(e, 0))

	assert.Panics(t, func() {
		mapper.SetRelations(Entity{}, Rel(0, parent2))
	})
	assert.Panics(t, func() {
		mapper.GetRelation(Entity{}, 0)
	})
}

func TestMap8(t *testing.T) {
	n := 12
	w := NewWorld(4)

	mapper := NewMap8[CompA, CompB, CompC, CompD, CompE, CompF, CompG, CompH](&w)

	entities := []Entity{}
	for range n {
		e := mapper.NewEntity(&CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{}, &CompG{}, &CompH{})
		entities = append(entities, e)
		e = w.NewEntity()
		mapper.Add(e, &CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{}, &CompG{}, &CompH{})
		entities = append(entities, e)
	}

	for _, e := range entities {
		_, _, _, _, _, _, _, _ = mapper.Get(e)
		assert.True(t, mapper.HasAll(e))
	}

	for _, e := range entities {
		mapper.Remove(e)
		assert.False(t, mapper.HasAll(e))
	}

	assert.Panics(t, func() {
		mapper.Get(Entity{})
	})
	assert.Panics(t, func() {
		mapper.HasAll(Entity{})
	})
	assert.Panics(t, func() {
		mapper.Add(Entity{}, &CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{}, &CompG{}, &CompH{})
	})
	assert.Panics(t, func() {
		mapper.Remove(Entity{})
	})
}

func TestMap8NewBatch(t *testing.T) {
	n := 12
	w := NewWorld(8)

	mapper := NewMap8[CompA, CompB, CompC, CompD, CompE, CompF, CompG, CompH](&w)

	for range n {
		_ = mapper.NewEntity(&CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{}, &CompG{}, &CompH{})
	}
	mapper.NewBatch(n*2, &CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{}, &CompG{}, &CompH{})

	filter := NewFilter8[CompA, CompB, CompC, CompD, CompE, CompF, CompG, CompH](&w)
	query := filter.Query()
	cnt := 0
	var lastEntity Entity
	for query.Next() {
		_, _, _, _, _, _, _, _ = query.Get()
		lastEntity = query.Entity()
		cnt++
	}
	assert.True(t, mapper.HasAll(lastEntity))
	assert.Equal(t, n*3, cnt)
}

func TestMap8NewBatchFn(t *testing.T) {
	n := 12
	w := NewWorld(8)

	mapper := NewMap8[CompA, CompB, CompC, CompD, CompE, CompF, CompG, CompH](&w)

	for range n {
		_ = mapper.NewEntity(&CompA{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{}, &CompG{}, &CompH{})
	}
	mapper.NewBatchFn(2*n, func(entity Entity, a *CompA, b *CompB, c *CompC, d *CompD, e *CompE, f *CompF, g *CompG, h *CompH) {
		a.X = 5
		a.Y = 6
	})

	filter := NewFilter8[CompA, CompB, CompC, CompD, CompE, CompF, CompG, CompH](&w)
	query := filter.Query()
	cnt := 0
	var lastEntity Entity
	for query.Next() {
		_, _, _, _, _, _, _, _ = query.Get()
		lastEntity = query.Entity()
		cnt++
	}
	assert.True(t, mapper.HasAll(lastEntity))
	assert.Equal(t, 3*n, cnt)
}

func TestMap8Relations(t *testing.T) {
	w := NewWorld(8)

	mapper := NewMap8[ChildOf, CompB, CompC, CompD, CompE, CompF, CompG, CompH](&w)

	parent1 := w.NewEntity()
	parent2 := w.NewEntity()

	e := mapper.NewEntity(&ChildOf{}, &CompB{}, &CompC{}, &CompD{}, &CompE{}, &CompF{}, &CompG{}, &CompH{}, Rel(0, parent1))
	assert.Equal(t, parent1, mapper.GetRelation(e, 0))
	assert.Equal(t, parent1, mapper.GetRelationUnchecked(e, 0))

	mapper.SetRelations(e, Rel(0, parent2))
	assert.Equal(t, parent2, mapper.GetRelation(e, 0))

	assert.Panics(t, func() {
		mapper.SetRelations(Entity{}, Rel(0, parent2))
	})
	assert.Panics(t, func() {
		mapper.GetRelation(Entity{}, 0)
	})
}
