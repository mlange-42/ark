package ecs

// Code generated by go generate; DO NOT EDIT.

type cursor struct {
	archetype int
	table     int
	index     uintptr
	maxIndex  int64
}

// Query0 is a query for 0 components.
// Use a [NewFilter0] to create one.
type Query0 struct {
	world      *World
	mask       Mask
	without    Mask
	lock       uint8
	cursor     cursor
	table      *table
	components []*componentStorage
	hasWithout bool
}

func newQuery0(world *World, mask Mask, without Mask) Query0 {
	components := make([]*componentStorage, 0)

	return Query0{
		world:      world,
		mask:       mask,
		without:    without,
		hasWithout: !without.IsZero(),
		lock:       world.lock(),
		components: components,
		cursor: cursor{
			archetype: -1,
			table:     -1,
			index:     0,
			maxIndex:  -1,
		},
	}
}

// Next advances the query's cursor to the next entity.
func (q *Query0) Next() bool {
	if int64(q.cursor.index) < q.cursor.maxIndex {
		q.cursor.index++
		return true
	}
	return q.nextTableOrArchetype()
}

// Entity returns the current entity.
func (q *Query0) Entity() Entity {
	return q.table.GetEntity(q.cursor.index)
}

// Get returns the queried components of the current entity.
func (q *Query0) Get() {
	return
}

// Close closes the Query and unlocks the world.
//
// Automatically called when iteration finishes.
// Needs to be called only if breaking out of the query iteration or not iterating at all.
func (q *Query0) Close() {
	q.cursor.archetype = -2
	q.cursor.table = -2
	q.table = nil
	q.world.unlock(q.lock)
}

func (q *Query0) nextTableOrArchetype() bool {
	if q.cursor.archetype >= 0 && q.nextTable() {
		return true
	}
	return q.nextArchetype()
}

func (q *Query0) nextArchetype() bool {
	maxArchIndex := len(q.world.storage.archetypes) - 1
	for q.cursor.archetype < maxArchIndex {
		q.cursor.archetype++
		archetype := &q.world.storage.archetypes[q.cursor.archetype]
		if !archetype.mask.Contains(&q.mask) ||
			archetype.mask.ContainsAny(&q.without) {
			continue
		}

		q.cursor.table = -1
		if q.nextTable() {
			return true
		}
	}
	if q.cursor.archetype < -1 {
		panic("query is already closed. Create a new one to iterate again")
	}
	q.Close()
	return false
}

func (q *Query0) nextTable() bool {
	archetype := &q.world.storage.archetypes[q.cursor.archetype]
	maxTableIndex := len(archetype.tables) - 1
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		q.table = archetype.tables[q.cursor.table]
		if q.table.entities.Len() == 0 {
			continue
		}

		q.cursor.index = 0
		q.cursor.maxIndex = int64(q.table.entities.Len() - 1)
		return true
	}
	return false
}

// Query1 is a query for 1 components.
// Use a [NewFilter1] to create one.
type Query1[A any] struct {
	world      *World
	mask       Mask
	without    Mask
	lock       uint8
	cursor     cursor
	table      *table
	components []*componentStorage
	columnA    *column
	hasWithout bool
}

func newQuery1[A any](world *World, mask Mask, without Mask, ids []ID) Query1[A] {
	components := make([]*componentStorage, 1)
	for i := range 1 {
		components[i] = &world.storage.components[ids[i].id]
	}

	return Query1[A]{
		world:      world,
		mask:       mask,
		without:    without,
		hasWithout: !without.IsZero(),
		lock:       world.lock(),
		components: components,
		cursor: cursor{
			archetype: -1,
			table:     -1,
			index:     0,
			maxIndex:  -1,
		},
	}
}

// Next advances the query's cursor to the next entity.
func (q *Query1[A]) Next() bool {
	if int64(q.cursor.index) < q.cursor.maxIndex {
		q.cursor.index++
		return true
	}
	return q.nextTableOrArchetype()
}

// Entity returns the current entity.
func (q *Query1[A]) Entity() Entity {
	return q.table.GetEntity(q.cursor.index)
}

// Get returns the queried components of the current entity.
func (q *Query1[A]) Get() *A {
	return (*A)(q.columnA.Get(q.cursor.index))
}

// Close closes the Query and unlocks the world.
//
// Automatically called when iteration finishes.
// Needs to be called only if breaking out of the query iteration or not iterating at all.
func (q *Query1[A]) Close() {
	q.cursor.archetype = -2
	q.cursor.table = -2
	q.table = nil
	q.columnA = nil
	q.world.unlock(q.lock)
}

func (q *Query1[A]) nextTableOrArchetype() bool {
	if q.cursor.archetype >= 0 && q.nextTable() {
		return true
	}
	return q.nextArchetype()
}

func (q *Query1[A]) nextArchetype() bool {
	maxArchIndex := len(q.world.storage.archetypes) - 1
	for q.cursor.archetype < maxArchIndex {
		q.cursor.archetype++
		archetype := &q.world.storage.archetypes[q.cursor.archetype]
		if !archetype.mask.Contains(&q.mask) ||
			archetype.mask.ContainsAny(&q.without) {
			continue
		}

		q.cursor.table = -1
		if q.nextTable() {
			return true
		}
	}
	if q.cursor.archetype < -1 {
		panic("query is already closed. Create a new one to iterate again")
	}
	q.Close()
	return false
}

func (q *Query1[A]) nextTable() bool {
	archetype := &q.world.storage.archetypes[q.cursor.archetype]
	maxTableIndex := len(archetype.tables) - 1
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		q.table = archetype.tables[q.cursor.table]
		if q.table.entities.Len() == 0 {
			continue
		}
		q.columnA = q.components[0].columns[q.table.id]

		q.cursor.index = 0
		q.cursor.maxIndex = int64(q.table.entities.Len() - 1)
		return true
	}
	return false
}

// Query2 is a query for 2 components.
// Use a [NewFilter2] to create one.
type Query2[A any, B any] struct {
	world      *World
	mask       Mask
	without    Mask
	lock       uint8
	cursor     cursor
	table      *table
	components []*componentStorage
	columnA    *column
	columnB    *column
	hasWithout bool
}

func newQuery2[A any, B any](world *World, mask Mask, without Mask, ids []ID) Query2[A, B] {
	components := make([]*componentStorage, 2)
	for i := range 2 {
		components[i] = &world.storage.components[ids[i].id]
	}

	return Query2[A, B]{
		world:      world,
		mask:       mask,
		without:    without,
		hasWithout: !without.IsZero(),
		lock:       world.lock(),
		components: components,
		cursor: cursor{
			archetype: -1,
			table:     -1,
			index:     0,
			maxIndex:  -1,
		},
	}
}

// Next advances the query's cursor to the next entity.
func (q *Query2[A, B]) Next() bool {
	if int64(q.cursor.index) < q.cursor.maxIndex {
		q.cursor.index++
		return true
	}
	return q.nextTableOrArchetype()
}

// Entity returns the current entity.
func (q *Query2[A, B]) Entity() Entity {
	return q.table.GetEntity(q.cursor.index)
}

// Get returns the queried components of the current entity.
func (q *Query2[A, B]) Get() (*A, *B) {
	return (*A)(q.columnA.Get(q.cursor.index)),
		(*B)(q.columnB.Get(q.cursor.index))
}

// Close closes the Query and unlocks the world.
//
// Automatically called when iteration finishes.
// Needs to be called only if breaking out of the query iteration or not iterating at all.
func (q *Query2[A, B]) Close() {
	q.cursor.archetype = -2
	q.cursor.table = -2
	q.table = nil
	q.columnA = nil
	q.columnB = nil
	q.world.unlock(q.lock)
}

func (q *Query2[A, B]) nextTableOrArchetype() bool {
	if q.cursor.archetype >= 0 && q.nextTable() {
		return true
	}
	return q.nextArchetype()
}

func (q *Query2[A, B]) nextArchetype() bool {
	maxArchIndex := len(q.world.storage.archetypes) - 1
	for q.cursor.archetype < maxArchIndex {
		q.cursor.archetype++
		archetype := &q.world.storage.archetypes[q.cursor.archetype]
		if !archetype.mask.Contains(&q.mask) ||
			archetype.mask.ContainsAny(&q.without) {
			continue
		}

		q.cursor.table = -1
		if q.nextTable() {
			return true
		}
	}
	if q.cursor.archetype < -1 {
		panic("query is already closed. Create a new one to iterate again")
	}
	q.Close()
	return false
}

func (q *Query2[A, B]) nextTable() bool {
	archetype := &q.world.storage.archetypes[q.cursor.archetype]
	maxTableIndex := len(archetype.tables) - 1
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		q.table = archetype.tables[q.cursor.table]
		if q.table.entities.Len() == 0 {
			continue
		}
		q.columnA = q.components[0].columns[q.table.id]
		q.columnB = q.components[1].columns[q.table.id]

		q.cursor.index = 0
		q.cursor.maxIndex = int64(q.table.entities.Len() - 1)
		return true
	}
	return false
}

// Query3 is a query for 3 components.
// Use a [NewFilter3] to create one.
type Query3[A any, B any, C any] struct {
	world      *World
	mask       Mask
	without    Mask
	lock       uint8
	cursor     cursor
	table      *table
	components []*componentStorage
	columnA    *column
	columnB    *column
	columnC    *column
	hasWithout bool
}

func newQuery3[A any, B any, C any](world *World, mask Mask, without Mask, ids []ID) Query3[A, B, C] {
	components := make([]*componentStorage, 3)
	for i := range 3 {
		components[i] = &world.storage.components[ids[i].id]
	}

	return Query3[A, B, C]{
		world:      world,
		mask:       mask,
		without:    without,
		hasWithout: !without.IsZero(),
		lock:       world.lock(),
		components: components,
		cursor: cursor{
			archetype: -1,
			table:     -1,
			index:     0,
			maxIndex:  -1,
		},
	}
}

// Next advances the query's cursor to the next entity.
func (q *Query3[A, B, C]) Next() bool {
	if int64(q.cursor.index) < q.cursor.maxIndex {
		q.cursor.index++
		return true
	}
	return q.nextTableOrArchetype()
}

// Entity returns the current entity.
func (q *Query3[A, B, C]) Entity() Entity {
	return q.table.GetEntity(q.cursor.index)
}

// Get returns the queried components of the current entity.
func (q *Query3[A, B, C]) Get() (*A, *B, *C) {
	return (*A)(q.columnA.Get(q.cursor.index)),
		(*B)(q.columnB.Get(q.cursor.index)),
		(*C)(q.columnC.Get(q.cursor.index))
}

// Close closes the Query and unlocks the world.
//
// Automatically called when iteration finishes.
// Needs to be called only if breaking out of the query iteration or not iterating at all.
func (q *Query3[A, B, C]) Close() {
	q.cursor.archetype = -2
	q.cursor.table = -2
	q.table = nil
	q.columnA = nil
	q.columnB = nil
	q.columnC = nil
	q.world.unlock(q.lock)
}

func (q *Query3[A, B, C]) nextTableOrArchetype() bool {
	if q.cursor.archetype >= 0 && q.nextTable() {
		return true
	}
	return q.nextArchetype()
}

func (q *Query3[A, B, C]) nextArchetype() bool {
	maxArchIndex := len(q.world.storage.archetypes) - 1
	for q.cursor.archetype < maxArchIndex {
		q.cursor.archetype++
		archetype := &q.world.storage.archetypes[q.cursor.archetype]
		if !archetype.mask.Contains(&q.mask) ||
			archetype.mask.ContainsAny(&q.without) {
			continue
		}

		q.cursor.table = -1
		if q.nextTable() {
			return true
		}
	}
	if q.cursor.archetype < -1 {
		panic("query is already closed. Create a new one to iterate again")
	}
	q.Close()
	return false
}

func (q *Query3[A, B, C]) nextTable() bool {
	archetype := &q.world.storage.archetypes[q.cursor.archetype]
	maxTableIndex := len(archetype.tables) - 1
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		q.table = archetype.tables[q.cursor.table]
		if q.table.entities.Len() == 0 {
			continue
		}
		q.columnA = q.components[0].columns[q.table.id]
		q.columnB = q.components[1].columns[q.table.id]
		q.columnC = q.components[2].columns[q.table.id]

		q.cursor.index = 0
		q.cursor.maxIndex = int64(q.table.entities.Len() - 1)
		return true
	}
	return false
}

// Query4 is a query for 4 components.
// Use a [NewFilter4] to create one.
type Query4[A any, B any, C any, D any] struct {
	world      *World
	mask       Mask
	without    Mask
	lock       uint8
	cursor     cursor
	table      *table
	components []*componentStorage
	columnA    *column
	columnB    *column
	columnC    *column
	columnD    *column
	hasWithout bool
}

func newQuery4[A any, B any, C any, D any](world *World, mask Mask, without Mask, ids []ID) Query4[A, B, C, D] {
	components := make([]*componentStorage, 4)
	for i := range 4 {
		components[i] = &world.storage.components[ids[i].id]
	}

	return Query4[A, B, C, D]{
		world:      world,
		mask:       mask,
		without:    without,
		hasWithout: !without.IsZero(),
		lock:       world.lock(),
		components: components,
		cursor: cursor{
			archetype: -1,
			table:     -1,
			index:     0,
			maxIndex:  -1,
		},
	}
}

// Next advances the query's cursor to the next entity.
func (q *Query4[A, B, C, D]) Next() bool {
	if int64(q.cursor.index) < q.cursor.maxIndex {
		q.cursor.index++
		return true
	}
	return q.nextTableOrArchetype()
}

// Entity returns the current entity.
func (q *Query4[A, B, C, D]) Entity() Entity {
	return q.table.GetEntity(q.cursor.index)
}

// Get returns the queried components of the current entity.
func (q *Query4[A, B, C, D]) Get() (*A, *B, *C, *D) {
	return (*A)(q.columnA.Get(q.cursor.index)),
		(*B)(q.columnB.Get(q.cursor.index)),
		(*C)(q.columnC.Get(q.cursor.index)),
		(*D)(q.columnD.Get(q.cursor.index))
}

// Close closes the Query and unlocks the world.
//
// Automatically called when iteration finishes.
// Needs to be called only if breaking out of the query iteration or not iterating at all.
func (q *Query4[A, B, C, D]) Close() {
	q.cursor.archetype = -2
	q.cursor.table = -2
	q.table = nil
	q.columnA = nil
	q.columnB = nil
	q.columnC = nil
	q.columnD = nil
	q.world.unlock(q.lock)
}

func (q *Query4[A, B, C, D]) nextTableOrArchetype() bool {
	if q.cursor.archetype >= 0 && q.nextTable() {
		return true
	}
	return q.nextArchetype()
}

func (q *Query4[A, B, C, D]) nextArchetype() bool {
	maxArchIndex := len(q.world.storage.archetypes) - 1
	for q.cursor.archetype < maxArchIndex {
		q.cursor.archetype++
		archetype := &q.world.storage.archetypes[q.cursor.archetype]
		if !archetype.mask.Contains(&q.mask) ||
			archetype.mask.ContainsAny(&q.without) {
			continue
		}

		q.cursor.table = -1
		if q.nextTable() {
			return true
		}
	}
	if q.cursor.archetype < -1 {
		panic("query is already closed. Create a new one to iterate again")
	}
	q.Close()
	return false
}

func (q *Query4[A, B, C, D]) nextTable() bool {
	archetype := &q.world.storage.archetypes[q.cursor.archetype]
	maxTableIndex := len(archetype.tables) - 1
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		q.table = archetype.tables[q.cursor.table]
		if q.table.entities.Len() == 0 {
			continue
		}
		q.columnA = q.components[0].columns[q.table.id]
		q.columnB = q.components[1].columns[q.table.id]
		q.columnC = q.components[2].columns[q.table.id]
		q.columnD = q.components[3].columns[q.table.id]

		q.cursor.index = 0
		q.cursor.maxIndex = int64(q.table.entities.Len() - 1)
		return true
	}
	return false
}

// Query5 is a query for 5 components.
// Use a [NewFilter5] to create one.
type Query5[A any, B any, C any, D any, E any] struct {
	world      *World
	mask       Mask
	without    Mask
	lock       uint8
	cursor     cursor
	table      *table
	components []*componentStorage
	columnA    *column
	columnB    *column
	columnC    *column
	columnD    *column
	columnE    *column
	hasWithout bool
}

func newQuery5[A any, B any, C any, D any, E any](world *World, mask Mask, without Mask, ids []ID) Query5[A, B, C, D, E] {
	components := make([]*componentStorage, 5)
	for i := range 5 {
		components[i] = &world.storage.components[ids[i].id]
	}

	return Query5[A, B, C, D, E]{
		world:      world,
		mask:       mask,
		without:    without,
		hasWithout: !without.IsZero(),
		lock:       world.lock(),
		components: components,
		cursor: cursor{
			archetype: -1,
			table:     -1,
			index:     0,
			maxIndex:  -1,
		},
	}
}

// Next advances the query's cursor to the next entity.
func (q *Query5[A, B, C, D, E]) Next() bool {
	if int64(q.cursor.index) < q.cursor.maxIndex {
		q.cursor.index++
		return true
	}
	return q.nextTableOrArchetype()
}

// Entity returns the current entity.
func (q *Query5[A, B, C, D, E]) Entity() Entity {
	return q.table.GetEntity(q.cursor.index)
}

// Get returns the queried components of the current entity.
func (q *Query5[A, B, C, D, E]) Get() (*A, *B, *C, *D, *E) {
	return (*A)(q.columnA.Get(q.cursor.index)),
		(*B)(q.columnB.Get(q.cursor.index)),
		(*C)(q.columnC.Get(q.cursor.index)),
		(*D)(q.columnD.Get(q.cursor.index)),
		(*E)(q.columnE.Get(q.cursor.index))
}

// Close closes the Query and unlocks the world.
//
// Automatically called when iteration finishes.
// Needs to be called only if breaking out of the query iteration or not iterating at all.
func (q *Query5[A, B, C, D, E]) Close() {
	q.cursor.archetype = -2
	q.cursor.table = -2
	q.table = nil
	q.columnA = nil
	q.columnB = nil
	q.columnC = nil
	q.columnD = nil
	q.columnE = nil
	q.world.unlock(q.lock)
}

func (q *Query5[A, B, C, D, E]) nextTableOrArchetype() bool {
	if q.cursor.archetype >= 0 && q.nextTable() {
		return true
	}
	return q.nextArchetype()
}

func (q *Query5[A, B, C, D, E]) nextArchetype() bool {
	maxArchIndex := len(q.world.storage.archetypes) - 1
	for q.cursor.archetype < maxArchIndex {
		q.cursor.archetype++
		archetype := &q.world.storage.archetypes[q.cursor.archetype]
		if !archetype.mask.Contains(&q.mask) ||
			archetype.mask.ContainsAny(&q.without) {
			continue
		}

		q.cursor.table = -1
		if q.nextTable() {
			return true
		}
	}
	if q.cursor.archetype < -1 {
		panic("query is already closed. Create a new one to iterate again")
	}
	q.Close()
	return false
}

func (q *Query5[A, B, C, D, E]) nextTable() bool {
	archetype := &q.world.storage.archetypes[q.cursor.archetype]
	maxTableIndex := len(archetype.tables) - 1
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		q.table = archetype.tables[q.cursor.table]
		if q.table.entities.Len() == 0 {
			continue
		}
		q.columnA = q.components[0].columns[q.table.id]
		q.columnB = q.components[1].columns[q.table.id]
		q.columnC = q.components[2].columns[q.table.id]
		q.columnD = q.components[3].columns[q.table.id]
		q.columnE = q.components[4].columns[q.table.id]

		q.cursor.index = 0
		q.cursor.maxIndex = int64(q.table.entities.Len() - 1)
		return true
	}
	return false
}

// Query6 is a query for 6 components.
// Use a [NewFilter6] to create one.
type Query6[A any, B any, C any, D any, E any, F any] struct {
	world      *World
	mask       Mask
	without    Mask
	lock       uint8
	cursor     cursor
	table      *table
	components []*componentStorage
	columnA    *column
	columnB    *column
	columnC    *column
	columnD    *column
	columnE    *column
	columnF    *column
	hasWithout bool
}

func newQuery6[A any, B any, C any, D any, E any, F any](world *World, mask Mask, without Mask, ids []ID) Query6[A, B, C, D, E, F] {
	components := make([]*componentStorage, 6)
	for i := range 6 {
		components[i] = &world.storage.components[ids[i].id]
	}

	return Query6[A, B, C, D, E, F]{
		world:      world,
		mask:       mask,
		without:    without,
		hasWithout: !without.IsZero(),
		lock:       world.lock(),
		components: components,
		cursor: cursor{
			archetype: -1,
			table:     -1,
			index:     0,
			maxIndex:  -1,
		},
	}
}

// Next advances the query's cursor to the next entity.
func (q *Query6[A, B, C, D, E, F]) Next() bool {
	if int64(q.cursor.index) < q.cursor.maxIndex {
		q.cursor.index++
		return true
	}
	return q.nextTableOrArchetype()
}

// Entity returns the current entity.
func (q *Query6[A, B, C, D, E, F]) Entity() Entity {
	return q.table.GetEntity(q.cursor.index)
}

// Get returns the queried components of the current entity.
func (q *Query6[A, B, C, D, E, F]) Get() (*A, *B, *C, *D, *E, *F) {
	return (*A)(q.columnA.Get(q.cursor.index)),
		(*B)(q.columnB.Get(q.cursor.index)),
		(*C)(q.columnC.Get(q.cursor.index)),
		(*D)(q.columnD.Get(q.cursor.index)),
		(*E)(q.columnE.Get(q.cursor.index)),
		(*F)(q.columnF.Get(q.cursor.index))
}

// Close closes the Query and unlocks the world.
//
// Automatically called when iteration finishes.
// Needs to be called only if breaking out of the query iteration or not iterating at all.
func (q *Query6[A, B, C, D, E, F]) Close() {
	q.cursor.archetype = -2
	q.cursor.table = -2
	q.table = nil
	q.columnA = nil
	q.columnB = nil
	q.columnC = nil
	q.columnD = nil
	q.columnE = nil
	q.columnF = nil
	q.world.unlock(q.lock)
}

func (q *Query6[A, B, C, D, E, F]) nextTableOrArchetype() bool {
	if q.cursor.archetype >= 0 && q.nextTable() {
		return true
	}
	return q.nextArchetype()
}

func (q *Query6[A, B, C, D, E, F]) nextArchetype() bool {
	maxArchIndex := len(q.world.storage.archetypes) - 1
	for q.cursor.archetype < maxArchIndex {
		q.cursor.archetype++
		archetype := &q.world.storage.archetypes[q.cursor.archetype]
		if !archetype.mask.Contains(&q.mask) ||
			archetype.mask.ContainsAny(&q.without) {
			continue
		}

		q.cursor.table = -1
		if q.nextTable() {
			return true
		}
	}
	if q.cursor.archetype < -1 {
		panic("query is already closed. Create a new one to iterate again")
	}
	q.Close()
	return false
}

func (q *Query6[A, B, C, D, E, F]) nextTable() bool {
	archetype := &q.world.storage.archetypes[q.cursor.archetype]
	maxTableIndex := len(archetype.tables) - 1
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		q.table = archetype.tables[q.cursor.table]
		if q.table.entities.Len() == 0 {
			continue
		}
		q.columnA = q.components[0].columns[q.table.id]
		q.columnB = q.components[1].columns[q.table.id]
		q.columnC = q.components[2].columns[q.table.id]
		q.columnD = q.components[3].columns[q.table.id]
		q.columnE = q.components[4].columns[q.table.id]
		q.columnF = q.components[5].columns[q.table.id]

		q.cursor.index = 0
		q.cursor.maxIndex = int64(q.table.entities.Len() - 1)
		return true
	}
	return false
}

// Query7 is a query for 7 components.
// Use a [NewFilter7] to create one.
type Query7[A any, B any, C any, D any, E any, F any, G any] struct {
	world      *World
	mask       Mask
	without    Mask
	lock       uint8
	cursor     cursor
	table      *table
	components []*componentStorage
	columnA    *column
	columnB    *column
	columnC    *column
	columnD    *column
	columnE    *column
	columnF    *column
	columnG    *column
	hasWithout bool
}

func newQuery7[A any, B any, C any, D any, E any, F any, G any](world *World, mask Mask, without Mask, ids []ID) Query7[A, B, C, D, E, F, G] {
	components := make([]*componentStorage, 7)
	for i := range 7 {
		components[i] = &world.storage.components[ids[i].id]
	}

	return Query7[A, B, C, D, E, F, G]{
		world:      world,
		mask:       mask,
		without:    without,
		hasWithout: !without.IsZero(),
		lock:       world.lock(),
		components: components,
		cursor: cursor{
			archetype: -1,
			table:     -1,
			index:     0,
			maxIndex:  -1,
		},
	}
}

// Next advances the query's cursor to the next entity.
func (q *Query7[A, B, C, D, E, F, G]) Next() bool {
	if int64(q.cursor.index) < q.cursor.maxIndex {
		q.cursor.index++
		return true
	}
	return q.nextTableOrArchetype()
}

// Entity returns the current entity.
func (q *Query7[A, B, C, D, E, F, G]) Entity() Entity {
	return q.table.GetEntity(q.cursor.index)
}

// Get returns the queried components of the current entity.
func (q *Query7[A, B, C, D, E, F, G]) Get() (*A, *B, *C, *D, *E, *F, *G) {
	return (*A)(q.columnA.Get(q.cursor.index)),
		(*B)(q.columnB.Get(q.cursor.index)),
		(*C)(q.columnC.Get(q.cursor.index)),
		(*D)(q.columnD.Get(q.cursor.index)),
		(*E)(q.columnE.Get(q.cursor.index)),
		(*F)(q.columnF.Get(q.cursor.index)),
		(*G)(q.columnG.Get(q.cursor.index))
}

// Close closes the Query and unlocks the world.
//
// Automatically called when iteration finishes.
// Needs to be called only if breaking out of the query iteration or not iterating at all.
func (q *Query7[A, B, C, D, E, F, G]) Close() {
	q.cursor.archetype = -2
	q.cursor.table = -2
	q.table = nil
	q.columnA = nil
	q.columnB = nil
	q.columnC = nil
	q.columnD = nil
	q.columnE = nil
	q.columnF = nil
	q.columnG = nil
	q.world.unlock(q.lock)
}

func (q *Query7[A, B, C, D, E, F, G]) nextTableOrArchetype() bool {
	if q.cursor.archetype >= 0 && q.nextTable() {
		return true
	}
	return q.nextArchetype()
}

func (q *Query7[A, B, C, D, E, F, G]) nextArchetype() bool {
	maxArchIndex := len(q.world.storage.archetypes) - 1
	for q.cursor.archetype < maxArchIndex {
		q.cursor.archetype++
		archetype := &q.world.storage.archetypes[q.cursor.archetype]
		if !archetype.mask.Contains(&q.mask) ||
			archetype.mask.ContainsAny(&q.without) {
			continue
		}

		q.cursor.table = -1
		if q.nextTable() {
			return true
		}
	}
	if q.cursor.archetype < -1 {
		panic("query is already closed. Create a new one to iterate again")
	}
	q.Close()
	return false
}

func (q *Query7[A, B, C, D, E, F, G]) nextTable() bool {
	archetype := &q.world.storage.archetypes[q.cursor.archetype]
	maxTableIndex := len(archetype.tables) - 1
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		q.table = archetype.tables[q.cursor.table]
		if q.table.entities.Len() == 0 {
			continue
		}
		q.columnA = q.components[0].columns[q.table.id]
		q.columnB = q.components[1].columns[q.table.id]
		q.columnC = q.components[2].columns[q.table.id]
		q.columnD = q.components[3].columns[q.table.id]
		q.columnE = q.components[4].columns[q.table.id]
		q.columnF = q.components[5].columns[q.table.id]
		q.columnG = q.components[6].columns[q.table.id]

		q.cursor.index = 0
		q.cursor.maxIndex = int64(q.table.entities.Len() - 1)
		return true
	}
	return false
}

// Query8 is a query for 8 components.
// Use a [NewFilter8] to create one.
type Query8[A any, B any, C any, D any, E any, F any, G any, H any] struct {
	world      *World
	mask       Mask
	without    Mask
	lock       uint8
	cursor     cursor
	table      *table
	components []*componentStorage
	columnA    *column
	columnB    *column
	columnC    *column
	columnD    *column
	columnE    *column
	columnF    *column
	columnG    *column
	columnH    *column
	hasWithout bool
}

func newQuery8[A any, B any, C any, D any, E any, F any, G any, H any](world *World, mask Mask, without Mask, ids []ID) Query8[A, B, C, D, E, F, G, H] {
	components := make([]*componentStorage, 8)
	for i := range 8 {
		components[i] = &world.storage.components[ids[i].id]
	}

	return Query8[A, B, C, D, E, F, G, H]{
		world:      world,
		mask:       mask,
		without:    without,
		hasWithout: !without.IsZero(),
		lock:       world.lock(),
		components: components,
		cursor: cursor{
			archetype: -1,
			table:     -1,
			index:     0,
			maxIndex:  -1,
		},
	}
}

// Next advances the query's cursor to the next entity.
func (q *Query8[A, B, C, D, E, F, G, H]) Next() bool {
	if int64(q.cursor.index) < q.cursor.maxIndex {
		q.cursor.index++
		return true
	}
	return q.nextTableOrArchetype()
}

// Entity returns the current entity.
func (q *Query8[A, B, C, D, E, F, G, H]) Entity() Entity {
	return q.table.GetEntity(q.cursor.index)
}

// Get returns the queried components of the current entity.
func (q *Query8[A, B, C, D, E, F, G, H]) Get() (*A, *B, *C, *D, *E, *F, *G, *H) {
	return (*A)(q.columnA.Get(q.cursor.index)),
		(*B)(q.columnB.Get(q.cursor.index)),
		(*C)(q.columnC.Get(q.cursor.index)),
		(*D)(q.columnD.Get(q.cursor.index)),
		(*E)(q.columnE.Get(q.cursor.index)),
		(*F)(q.columnF.Get(q.cursor.index)),
		(*G)(q.columnG.Get(q.cursor.index)),
		(*H)(q.columnH.Get(q.cursor.index))
}

// Close closes the Query and unlocks the world.
//
// Automatically called when iteration finishes.
// Needs to be called only if breaking out of the query iteration or not iterating at all.
func (q *Query8[A, B, C, D, E, F, G, H]) Close() {
	q.cursor.archetype = -2
	q.cursor.table = -2
	q.table = nil
	q.columnA = nil
	q.columnB = nil
	q.columnC = nil
	q.columnD = nil
	q.columnE = nil
	q.columnF = nil
	q.columnG = nil
	q.columnH = nil
	q.world.unlock(q.lock)
}

func (q *Query8[A, B, C, D, E, F, G, H]) nextTableOrArchetype() bool {
	if q.cursor.archetype >= 0 && q.nextTable() {
		return true
	}
	return q.nextArchetype()
}

func (q *Query8[A, B, C, D, E, F, G, H]) nextArchetype() bool {
	maxArchIndex := len(q.world.storage.archetypes) - 1
	for q.cursor.archetype < maxArchIndex {
		q.cursor.archetype++
		archetype := &q.world.storage.archetypes[q.cursor.archetype]
		if !archetype.mask.Contains(&q.mask) ||
			archetype.mask.ContainsAny(&q.without) {
			continue
		}

		q.cursor.table = -1
		if q.nextTable() {
			return true
		}
	}
	if q.cursor.archetype < -1 {
		panic("query is already closed. Create a new one to iterate again")
	}
	q.Close()
	return false
}

func (q *Query8[A, B, C, D, E, F, G, H]) nextTable() bool {
	archetype := &q.world.storage.archetypes[q.cursor.archetype]
	maxTableIndex := len(archetype.tables) - 1
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		q.table = archetype.tables[q.cursor.table]
		if q.table.entities.Len() == 0 {
			continue
		}
		q.columnA = q.components[0].columns[q.table.id]
		q.columnB = q.components[1].columns[q.table.id]
		q.columnC = q.components[2].columns[q.table.id]
		q.columnD = q.components[3].columns[q.table.id]
		q.columnE = q.components[4].columns[q.table.id]
		q.columnF = q.components[5].columns[q.table.id]
		q.columnG = q.components[6].columns[q.table.id]
		q.columnH = q.components[7].columns[q.table.id]

		q.cursor.index = 0
		q.cursor.maxIndex = int64(q.table.entities.Len() - 1)
		return true
	}
	return false
}
