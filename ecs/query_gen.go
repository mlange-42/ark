package ecs

// Code generated by go generate; DO NOT EDIT.

type cursor struct {
	archetype int32
	table     int32
	index     uintptr
	maxIndex  int64
}

// Query0 is a query for 0 components.
// Use a [Filter0] to create one.
//
// Queries are one-time use iterators and must be re-created each time before iterating.
//
// See [Query2] for a usage example.
type Query0 struct {
	world       *World
	filter      *filter
	table       *table
	cache       *cacheEntry
	relations   []relationID
	tables      []tableID
	components  []*componentStorage
	cursor      cursor
	lock        uint8
	rareComp    uint8
	hasRareComp bool
}

// Count counts the entities matching this query.
//
// Has some overhead of iterating through archetypes.
// However, this is still much faster than manual counting via iteration.
//
// Does not iterate or close the query.
//
// See [Query2.Count] for an example.
func (q *Query0) Count() int {
	if q.cache == nil {
		if q.hasRareComp {
			return countQuery(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp])
		} else {
			return countQuery(&q.world.storage, q.filter, q.relations, q.world.storage.allArchetypes)
		}
	}
	return countQueryCache(&q.world.storage, q.cache, q.relations)
}

// EntityAt returns the entity at a given index.
//
// The method is particularly useful for random sampling of entities from a query.
// However, performance depends on the number of archetypes in the world and in the query.
// In worlds with many archetypes, it is recommended to use a registered/cached filter.
//
// Do not use this to iterate a query! Use [Query0.Next] instead.
//
// Panics if the index is out of range, as indicated by [Query0.Count].
//
// See [Query2.EntityAt] for an example.
func (q *Query0) EntityAt(index int) Entity {
	if q.cache == nil {
		if q.hasRareComp {
			return entityAt(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp], uint32(index))
		} else {
			return entityAt(&q.world.storage, q.filter, q.relations, q.world.storage.allArchetypes, uint32(index))
		}
	}
	return entityAtCache(&q.world.storage, q.cache, q.relations, uint32(index))
}

// Close closes the Query and unlocks the world.
//
// Automatically called when iteration completes.
// Needs to be called only if breaking out of the query iteration or not iterating at all.
func (q *Query0) Close() {
	q.cursor.archetype = -2
	q.cursor.table = -2
	q.tables = nil
	q.table = nil
	q.cache = nil
	q.world.unlock(q.lock)
}

func (q *Query0) nextTableOrArchetype() bool {
	if q.cache != nil {
		return q.nextTable(q.cache.tables)
	}
	if q.cursor.archetype >= 0 && q.nextTable(q.tables) {
		return true
	}
	return q.nextArchetype()
}

func (q *Query0) nextArchetype() bool {
	q.tables = nil
	var archetypes []archetypeID
	if q.hasRareComp {
		archetypes = q.world.storage.componentIndex[q.rareComp]
	} else {
		archetypes = q.world.storage.allArchetypes
	}
	maxArchIndex := int32(len(archetypes) - 1)
	for q.cursor.archetype < maxArchIndex {
		q.cursor.archetype++
		archetype := &q.world.storage.archetypes[archetypes[q.cursor.archetype]]

		if !q.filter.matches(&archetype.mask) {
			continue
		}

		if !archetype.HasRelations() {
			table := &q.world.storage.tables[archetype.tables.tables[0]]
			if table.Len() > 0 {
				q.setTable(0, table)
				return true
			}
			continue
		}

		q.tables = archetype.GetTables(q.relations)
		q.cursor.table = -1
		if q.nextTable(q.tables) {
			return true
		}
	}
	q.Close()
	return false
}

func (q *Query0) nextTable(tables []tableID) bool {
	maxTableIndex := int32(len(tables) - 1)
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		table := &q.world.storage.tables[tables[q.cursor.table]]
		if table.Len() == 0 {
			continue
		}
		if !table.Matches(q.relations) {
			continue
		}
		q.setTable(q.cursor.table, table)
		return true
	}
	if q.cache != nil {
		q.Close()
	}
	return false
}

func (q *Query0) setTable(index int32, table *table) {
	q.cursor.table = index
	q.table = table
	q.cursor.index = 0
	q.cursor.maxIndex = int64(q.table.Len() - 1)
}

// Query1 is a query for 1 components.
// Use a [Filter1] to create one.
//
// Queries are one-time use iterators and must be re-created each time before iterating.
//
// See [Query2] for a usage example.
type Query1[A any] struct {
	world      *World
	filter     *filter
	table      *table
	cache      *cacheEntry
	columnA    *column
	relations  []relationID
	tables     []tableID
	components []*componentStorage
	cursor     cursor
	lock       uint8
	rareComp   uint8
}

// GetRelation returns the entity relation target of the component at the given index.
func (q *Query1[A]) GetRelation(index int) Entity {
	return q.components[index].columns[q.table.id].target
}

// Count counts the entities matching this query.
//
// Has some overhead of iterating through archetypes.
// However, this is still much faster than manual counting via iteration.
//
// Does not iterate or close the query.
//
// See [Query2.Count] for an example.
func (q *Query1[A]) Count() int {
	if q.cache == nil {
		return countQuery(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp])
	}
	return countQueryCache(&q.world.storage, q.cache, q.relations)
}

// EntityAt returns the entity at a given index.
//
// The method is particularly useful for random sampling of entities from a query.
// However, performance depends on the number of archetypes in the world and in the query.
// In worlds with many archetypes, it is recommended to use a registered/cached filter.
//
// Do not use this to iterate a query! Use [Query1.Next] instead.
//
// Panics if the index is out of range, as indicated by [Query1.Count].
//
// See [Query2.EntityAt] for an example.
func (q *Query1[A]) EntityAt(index int) Entity {
	if q.cache == nil {
		return entityAt(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp], uint32(index))
	}
	return entityAtCache(&q.world.storage, q.cache, q.relations, uint32(index))
}

// Close closes the Query and unlocks the world.
//
// Automatically called when iteration completes.
// Needs to be called only if breaking out of the query iteration or not iterating at all.
func (q *Query1[A]) Close() {
	q.cursor.archetype = -2
	q.cursor.table = -2
	q.tables = nil
	q.table = nil
	q.cache = nil
	q.columnA = nil
	q.world.unlock(q.lock)
}

func (q *Query1[A]) nextTableOrArchetype() bool {
	if q.cache != nil {
		return q.nextTable(q.cache.tables)
	}
	if q.cursor.archetype >= 0 && q.nextTable(q.tables) {
		return true
	}
	return q.nextArchetype()
}

func (q *Query1[A]) nextArchetype() bool {
	q.tables = nil
	archetypes := q.world.storage.componentIndex[q.rareComp]
	maxArchIndex := int32(len(archetypes) - 1)
	for q.cursor.archetype < maxArchIndex {
		q.cursor.archetype++
		archetype := &q.world.storage.archetypes[archetypes[q.cursor.archetype]]

		if !q.filter.matches(&archetype.mask) {
			continue
		}

		if !archetype.HasRelations() {
			table := &q.world.storage.tables[archetype.tables.tables[0]]
			if table.Len() > 0 {
				q.setTable(0, table)
				return true
			}
			continue
		}

		q.tables = archetype.GetTables(q.relations)
		q.cursor.table = -1
		if q.nextTable(q.tables) {
			return true
		}
	}
	q.Close()
	return false
}

func (q *Query1[A]) nextTable(tables []tableID) bool {
	maxTableIndex := int32(len(tables) - 1)
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		table := &q.world.storage.tables[tables[q.cursor.table]]
		if table.Len() == 0 {
			continue
		}
		if !table.Matches(q.relations) {
			continue
		}
		q.setTable(q.cursor.table, table)
		return true
	}
	if q.cache != nil {
		q.Close()
	}
	return false
}

func (q *Query1[A]) setTable(index int32, table *table) {
	q.cursor.table = index
	q.table = table
	q.columnA = q.components[0].columns[q.table.id]
	q.cursor.index = 0
	q.cursor.maxIndex = int64(q.table.Len() - 1)
}

// Query2 is a query for 2 components.
// Use a [Filter2] to create one.
//
// Queries are one-time use iterators and must be re-created each time before iterating.
type Query2[A any, B any] struct {
	world      *World
	filter     *filter
	table      *table
	cache      *cacheEntry
	columnA    *column
	columnB    *column
	relations  []relationID
	tables     []tableID
	components []*componentStorage
	cursor     cursor
	lock       uint8
	rareComp   uint8
}

// GetRelation returns the entity relation target of the component at the given index.
func (q *Query2[A, B]) GetRelation(index int) Entity {
	return q.components[index].columns[q.table.id].target
}

// Count counts the entities matching this query.
//
// Has some overhead of iterating through archetypes.
// However, this is still much faster than manual counting via iteration.
//
// Does not iterate or close the query.
func (q *Query2[A, B]) Count() int {
	if q.cache == nil {
		return countQuery(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp])
	}
	return countQueryCache(&q.world.storage, q.cache, q.relations)
}

// EntityAt returns the entity at a given index.
//
// The method is particularly useful for random sampling of entities from a query.
// However, performance depends on the number of archetypes in the world and in the query.
// In worlds with many archetypes, it is recommended to use a registered/cached filter.
//
// Do not use this to iterate a query! Use [Query2.Next] instead.
//
// Panics if the index is out of range, as indicated by [Query2.Count].
func (q *Query2[A, B]) EntityAt(index int) Entity {
	if q.cache == nil {
		return entityAt(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp], uint32(index))
	}
	return entityAtCache(&q.world.storage, q.cache, q.relations, uint32(index))
}

// Close closes the Query and unlocks the world.
//
// Automatically called when iteration completes.
// Needs to be called only if breaking out of the query iteration or not iterating at all.
func (q *Query2[A, B]) Close() {
	q.cursor.archetype = -2
	q.cursor.table = -2
	q.tables = nil
	q.table = nil
	q.cache = nil
	q.columnA = nil
	q.columnB = nil
	q.world.unlock(q.lock)
}

func (q *Query2[A, B]) nextTableOrArchetype() bool {
	if q.cache != nil {
		return q.nextTable(q.cache.tables)
	}
	if q.cursor.archetype >= 0 && q.nextTable(q.tables) {
		return true
	}
	return q.nextArchetype()
}

func (q *Query2[A, B]) nextArchetype() bool {
	q.tables = nil
	archetypes := q.world.storage.componentIndex[q.rareComp]
	maxArchIndex := int32(len(archetypes) - 1)
	for q.cursor.archetype < maxArchIndex {
		q.cursor.archetype++
		archetype := &q.world.storage.archetypes[archetypes[q.cursor.archetype]]

		if !q.filter.matches(&archetype.mask) {
			continue
		}

		if !archetype.HasRelations() {
			table := &q.world.storage.tables[archetype.tables.tables[0]]
			if table.Len() > 0 {
				q.setTable(0, table)
				return true
			}
			continue
		}

		q.tables = archetype.GetTables(q.relations)
		q.cursor.table = -1
		if q.nextTable(q.tables) {
			return true
		}
	}
	q.Close()
	return false
}

func (q *Query2[A, B]) nextTable(tables []tableID) bool {
	maxTableIndex := int32(len(tables) - 1)
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		table := &q.world.storage.tables[tables[q.cursor.table]]
		if table.Len() == 0 {
			continue
		}
		if !table.Matches(q.relations) {
			continue
		}
		q.setTable(q.cursor.table, table)
		return true
	}
	if q.cache != nil {
		q.Close()
	}
	return false
}

func (q *Query2[A, B]) setTable(index int32, table *table) {
	q.cursor.table = index
	q.table = table
	q.columnA = q.components[0].columns[q.table.id]
	q.columnB = q.components[1].columns[q.table.id]
	q.cursor.index = 0
	q.cursor.maxIndex = int64(q.table.Len() - 1)
}

// Query3 is a query for 3 components.
// Use a [Filter3] to create one.
//
// Queries are one-time use iterators and must be re-created each time before iterating.
//
// See [Query2] for a usage example.
type Query3[A any, B any, C any] struct {
	world      *World
	filter     *filter
	table      *table
	cache      *cacheEntry
	columnA    *column
	columnB    *column
	columnC    *column
	relations  []relationID
	tables     []tableID
	components []*componentStorage
	cursor     cursor
	lock       uint8
	rareComp   uint8
}

// GetRelation returns the entity relation target of the component at the given index.
func (q *Query3[A, B, C]) GetRelation(index int) Entity {
	return q.components[index].columns[q.table.id].target
}

// Count counts the entities matching this query.
//
// Has some overhead of iterating through archetypes.
// However, this is still much faster than manual counting via iteration.
//
// Does not iterate or close the query.
//
// See [Query2.Count] for an example.
func (q *Query3[A, B, C]) Count() int {
	if q.cache == nil {
		return countQuery(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp])
	}
	return countQueryCache(&q.world.storage, q.cache, q.relations)
}

// EntityAt returns the entity at a given index.
//
// The method is particularly useful for random sampling of entities from a query.
// However, performance depends on the number of archetypes in the world and in the query.
// In worlds with many archetypes, it is recommended to use a registered/cached filter.
//
// Do not use this to iterate a query! Use [Query3.Next] instead.
//
// Panics if the index is out of range, as indicated by [Query3.Count].
//
// See [Query2.EntityAt] for an example.
func (q *Query3[A, B, C]) EntityAt(index int) Entity {
	if q.cache == nil {
		return entityAt(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp], uint32(index))
	}
	return entityAtCache(&q.world.storage, q.cache, q.relations, uint32(index))
}

// Close closes the Query and unlocks the world.
//
// Automatically called when iteration completes.
// Needs to be called only if breaking out of the query iteration or not iterating at all.
func (q *Query3[A, B, C]) Close() {
	q.cursor.archetype = -2
	q.cursor.table = -2
	q.tables = nil
	q.table = nil
	q.cache = nil
	q.columnA = nil
	q.columnB = nil
	q.columnC = nil
	q.world.unlock(q.lock)
}

func (q *Query3[A, B, C]) nextTableOrArchetype() bool {
	if q.cache != nil {
		return q.nextTable(q.cache.tables)
	}
	if q.cursor.archetype >= 0 && q.nextTable(q.tables) {
		return true
	}
	return q.nextArchetype()
}

func (q *Query3[A, B, C]) nextArchetype() bool {
	q.tables = nil
	archetypes := q.world.storage.componentIndex[q.rareComp]
	maxArchIndex := int32(len(archetypes) - 1)
	for q.cursor.archetype < maxArchIndex {
		q.cursor.archetype++
		archetype := &q.world.storage.archetypes[archetypes[q.cursor.archetype]]

		if !q.filter.matches(&archetype.mask) {
			continue
		}

		if !archetype.HasRelations() {
			table := &q.world.storage.tables[archetype.tables.tables[0]]
			if table.Len() > 0 {
				q.setTable(0, table)
				return true
			}
			continue
		}

		q.tables = archetype.GetTables(q.relations)
		q.cursor.table = -1
		if q.nextTable(q.tables) {
			return true
		}
	}
	q.Close()
	return false
}

func (q *Query3[A, B, C]) nextTable(tables []tableID) bool {
	maxTableIndex := int32(len(tables) - 1)
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		table := &q.world.storage.tables[tables[q.cursor.table]]
		if table.Len() == 0 {
			continue
		}
		if !table.Matches(q.relations) {
			continue
		}
		q.setTable(q.cursor.table, table)
		return true
	}
	if q.cache != nil {
		q.Close()
	}
	return false
}

func (q *Query3[A, B, C]) setTable(index int32, table *table) {
	q.cursor.table = index
	q.table = table
	q.columnA = q.components[0].columns[q.table.id]
	q.columnB = q.components[1].columns[q.table.id]
	q.columnC = q.components[2].columns[q.table.id]
	q.cursor.index = 0
	q.cursor.maxIndex = int64(q.table.Len() - 1)
}

// Query4 is a query for 4 components.
// Use a [Filter4] to create one.
//
// Queries are one-time use iterators and must be re-created each time before iterating.
//
// See [Query2] for a usage example.
type Query4[A any, B any, C any, D any] struct {
	world      *World
	filter     *filter
	table      *table
	cache      *cacheEntry
	columnA    *column
	columnB    *column
	columnC    *column
	columnD    *column
	relations  []relationID
	tables     []tableID
	components []*componentStorage
	cursor     cursor
	lock       uint8
	rareComp   uint8
}

// GetRelation returns the entity relation target of the component at the given index.
func (q *Query4[A, B, C, D]) GetRelation(index int) Entity {
	return q.components[index].columns[q.table.id].target
}

// Count counts the entities matching this query.
//
// Has some overhead of iterating through archetypes.
// However, this is still much faster than manual counting via iteration.
//
// Does not iterate or close the query.
//
// See [Query2.Count] for an example.
func (q *Query4[A, B, C, D]) Count() int {
	if q.cache == nil {
		return countQuery(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp])
	}
	return countQueryCache(&q.world.storage, q.cache, q.relations)
}

// EntityAt returns the entity at a given index.
//
// The method is particularly useful for random sampling of entities from a query.
// However, performance depends on the number of archetypes in the world and in the query.
// In worlds with many archetypes, it is recommended to use a registered/cached filter.
//
// Do not use this to iterate a query! Use [Query4.Next] instead.
//
// Panics if the index is out of range, as indicated by [Query4.Count].
//
// See [Query2.EntityAt] for an example.
func (q *Query4[A, B, C, D]) EntityAt(index int) Entity {
	if q.cache == nil {
		return entityAt(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp], uint32(index))
	}
	return entityAtCache(&q.world.storage, q.cache, q.relations, uint32(index))
}

// Close closes the Query and unlocks the world.
//
// Automatically called when iteration completes.
// Needs to be called only if breaking out of the query iteration or not iterating at all.
func (q *Query4[A, B, C, D]) Close() {
	q.cursor.archetype = -2
	q.cursor.table = -2
	q.tables = nil
	q.table = nil
	q.cache = nil
	q.columnA = nil
	q.columnB = nil
	q.columnC = nil
	q.columnD = nil
	q.world.unlock(q.lock)
}

func (q *Query4[A, B, C, D]) nextTableOrArchetype() bool {
	if q.cache != nil {
		return q.nextTable(q.cache.tables)
	}
	if q.cursor.archetype >= 0 && q.nextTable(q.tables) {
		return true
	}
	return q.nextArchetype()
}

func (q *Query4[A, B, C, D]) nextArchetype() bool {
	q.tables = nil
	archetypes := q.world.storage.componentIndex[q.rareComp]
	maxArchIndex := int32(len(archetypes) - 1)
	for q.cursor.archetype < maxArchIndex {
		q.cursor.archetype++
		archetype := &q.world.storage.archetypes[archetypes[q.cursor.archetype]]

		if !q.filter.matches(&archetype.mask) {
			continue
		}

		if !archetype.HasRelations() {
			table := &q.world.storage.tables[archetype.tables.tables[0]]
			if table.Len() > 0 {
				q.setTable(0, table)
				return true
			}
			continue
		}

		q.tables = archetype.GetTables(q.relations)
		q.cursor.table = -1
		if q.nextTable(q.tables) {
			return true
		}
	}
	q.Close()
	return false
}

func (q *Query4[A, B, C, D]) nextTable(tables []tableID) bool {
	maxTableIndex := int32(len(tables) - 1)
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		table := &q.world.storage.tables[tables[q.cursor.table]]
		if table.Len() == 0 {
			continue
		}
		if !table.Matches(q.relations) {
			continue
		}
		q.setTable(q.cursor.table, table)
		return true
	}
	if q.cache != nil {
		q.Close()
	}
	return false
}

func (q *Query4[A, B, C, D]) setTable(index int32, table *table) {
	q.cursor.table = index
	q.table = table
	q.columnA = q.components[0].columns[q.table.id]
	q.columnB = q.components[1].columns[q.table.id]
	q.columnC = q.components[2].columns[q.table.id]
	q.columnD = q.components[3].columns[q.table.id]
	q.cursor.index = 0
	q.cursor.maxIndex = int64(q.table.Len() - 1)
}

// Query5 is a query for 5 components.
// Use a [Filter5] to create one.
//
// Queries are one-time use iterators and must be re-created each time before iterating.
//
// See [Query2] for a usage example.
type Query5[A any, B any, C any, D any, E any] struct {
	world      *World
	filter     *filter
	table      *table
	cache      *cacheEntry
	columnA    *column
	columnB    *column
	columnC    *column
	columnD    *column
	columnE    *column
	relations  []relationID
	tables     []tableID
	components []*componentStorage
	cursor     cursor
	lock       uint8
	rareComp   uint8
}

// GetRelation returns the entity relation target of the component at the given index.
func (q *Query5[A, B, C, D, E]) GetRelation(index int) Entity {
	return q.components[index].columns[q.table.id].target
}

// Count counts the entities matching this query.
//
// Has some overhead of iterating through archetypes.
// However, this is still much faster than manual counting via iteration.
//
// Does not iterate or close the query.
//
// See [Query2.Count] for an example.
func (q *Query5[A, B, C, D, E]) Count() int {
	if q.cache == nil {
		return countQuery(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp])
	}
	return countQueryCache(&q.world.storage, q.cache, q.relations)
}

// EntityAt returns the entity at a given index.
//
// The method is particularly useful for random sampling of entities from a query.
// However, performance depends on the number of archetypes in the world and in the query.
// In worlds with many archetypes, it is recommended to use a registered/cached filter.
//
// Do not use this to iterate a query! Use [Query5.Next] instead.
//
// Panics if the index is out of range, as indicated by [Query5.Count].
//
// See [Query2.EntityAt] for an example.
func (q *Query5[A, B, C, D, E]) EntityAt(index int) Entity {
	if q.cache == nil {
		return entityAt(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp], uint32(index))
	}
	return entityAtCache(&q.world.storage, q.cache, q.relations, uint32(index))
}

// Close closes the Query and unlocks the world.
//
// Automatically called when iteration completes.
// Needs to be called only if breaking out of the query iteration or not iterating at all.
func (q *Query5[A, B, C, D, E]) Close() {
	q.cursor.archetype = -2
	q.cursor.table = -2
	q.tables = nil
	q.table = nil
	q.cache = nil
	q.columnA = nil
	q.columnB = nil
	q.columnC = nil
	q.columnD = nil
	q.columnE = nil
	q.world.unlock(q.lock)
}

func (q *Query5[A, B, C, D, E]) nextTableOrArchetype() bool {
	if q.cache != nil {
		return q.nextTable(q.cache.tables)
	}
	if q.cursor.archetype >= 0 && q.nextTable(q.tables) {
		return true
	}
	return q.nextArchetype()
}

func (q *Query5[A, B, C, D, E]) nextArchetype() bool {
	q.tables = nil
	archetypes := q.world.storage.componentIndex[q.rareComp]
	maxArchIndex := int32(len(archetypes) - 1)
	for q.cursor.archetype < maxArchIndex {
		q.cursor.archetype++
		archetype := &q.world.storage.archetypes[archetypes[q.cursor.archetype]]

		if !q.filter.matches(&archetype.mask) {
			continue
		}

		if !archetype.HasRelations() {
			table := &q.world.storage.tables[archetype.tables.tables[0]]
			if table.Len() > 0 {
				q.setTable(0, table)
				return true
			}
			continue
		}

		q.tables = archetype.GetTables(q.relations)
		q.cursor.table = -1
		if q.nextTable(q.tables) {
			return true
		}
	}
	q.Close()
	return false
}

func (q *Query5[A, B, C, D, E]) nextTable(tables []tableID) bool {
	maxTableIndex := int32(len(tables) - 1)
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		table := &q.world.storage.tables[tables[q.cursor.table]]
		if table.Len() == 0 {
			continue
		}
		if !table.Matches(q.relations) {
			continue
		}
		q.setTable(q.cursor.table, table)
		return true
	}
	if q.cache != nil {
		q.Close()
	}
	return false
}

func (q *Query5[A, B, C, D, E]) setTable(index int32, table *table) {
	q.cursor.table = index
	q.table = table
	q.columnA = q.components[0].columns[q.table.id]
	q.columnB = q.components[1].columns[q.table.id]
	q.columnC = q.components[2].columns[q.table.id]
	q.columnD = q.components[3].columns[q.table.id]
	q.columnE = q.components[4].columns[q.table.id]
	q.cursor.index = 0
	q.cursor.maxIndex = int64(q.table.Len() - 1)
}

// Query6 is a query for 6 components.
// Use a [Filter6] to create one.
//
// Queries are one-time use iterators and must be re-created each time before iterating.
//
// See [Query2] for a usage example.
type Query6[A any, B any, C any, D any, E any, F any] struct {
	world      *World
	filter     *filter
	table      *table
	cache      *cacheEntry
	columnA    *column
	columnB    *column
	columnC    *column
	columnD    *column
	columnE    *column
	columnF    *column
	relations  []relationID
	tables     []tableID
	components []*componentStorage
	cursor     cursor
	lock       uint8
	rareComp   uint8
}

// GetRelation returns the entity relation target of the component at the given index.
func (q *Query6[A, B, C, D, E, F]) GetRelation(index int) Entity {
	return q.components[index].columns[q.table.id].target
}

// Count counts the entities matching this query.
//
// Has some overhead of iterating through archetypes.
// However, this is still much faster than manual counting via iteration.
//
// Does not iterate or close the query.
//
// See [Query2.Count] for an example.
func (q *Query6[A, B, C, D, E, F]) Count() int {
	if q.cache == nil {
		return countQuery(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp])
	}
	return countQueryCache(&q.world.storage, q.cache, q.relations)
}

// EntityAt returns the entity at a given index.
//
// The method is particularly useful for random sampling of entities from a query.
// However, performance depends on the number of archetypes in the world and in the query.
// In worlds with many archetypes, it is recommended to use a registered/cached filter.
//
// Do not use this to iterate a query! Use [Query6.Next] instead.
//
// Panics if the index is out of range, as indicated by [Query6.Count].
//
// See [Query2.EntityAt] for an example.
func (q *Query6[A, B, C, D, E, F]) EntityAt(index int) Entity {
	if q.cache == nil {
		return entityAt(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp], uint32(index))
	}
	return entityAtCache(&q.world.storage, q.cache, q.relations, uint32(index))
}

// Close closes the Query and unlocks the world.
//
// Automatically called when iteration completes.
// Needs to be called only if breaking out of the query iteration or not iterating at all.
func (q *Query6[A, B, C, D, E, F]) Close() {
	q.cursor.archetype = -2
	q.cursor.table = -2
	q.tables = nil
	q.table = nil
	q.cache = nil
	q.columnA = nil
	q.columnB = nil
	q.columnC = nil
	q.columnD = nil
	q.columnE = nil
	q.columnF = nil
	q.world.unlock(q.lock)
}

func (q *Query6[A, B, C, D, E, F]) nextTableOrArchetype() bool {
	if q.cache != nil {
		return q.nextTable(q.cache.tables)
	}
	if q.cursor.archetype >= 0 && q.nextTable(q.tables) {
		return true
	}
	return q.nextArchetype()
}

func (q *Query6[A, B, C, D, E, F]) nextArchetype() bool {
	q.tables = nil
	archetypes := q.world.storage.componentIndex[q.rareComp]
	maxArchIndex := int32(len(archetypes) - 1)
	for q.cursor.archetype < maxArchIndex {
		q.cursor.archetype++
		archetype := &q.world.storage.archetypes[archetypes[q.cursor.archetype]]

		if !q.filter.matches(&archetype.mask) {
			continue
		}

		if !archetype.HasRelations() {
			table := &q.world.storage.tables[archetype.tables.tables[0]]
			if table.Len() > 0 {
				q.setTable(0, table)
				return true
			}
			continue
		}

		q.tables = archetype.GetTables(q.relations)
		q.cursor.table = -1
		if q.nextTable(q.tables) {
			return true
		}
	}
	q.Close()
	return false
}

func (q *Query6[A, B, C, D, E, F]) nextTable(tables []tableID) bool {
	maxTableIndex := int32(len(tables) - 1)
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		table := &q.world.storage.tables[tables[q.cursor.table]]
		if table.Len() == 0 {
			continue
		}
		if !table.Matches(q.relations) {
			continue
		}
		q.setTable(q.cursor.table, table)
		return true
	}
	if q.cache != nil {
		q.Close()
	}
	return false
}

func (q *Query6[A, B, C, D, E, F]) setTable(index int32, table *table) {
	q.cursor.table = index
	q.table = table
	q.columnA = q.components[0].columns[q.table.id]
	q.columnB = q.components[1].columns[q.table.id]
	q.columnC = q.components[2].columns[q.table.id]
	q.columnD = q.components[3].columns[q.table.id]
	q.columnE = q.components[4].columns[q.table.id]
	q.columnF = q.components[5].columns[q.table.id]
	q.cursor.index = 0
	q.cursor.maxIndex = int64(q.table.Len() - 1)
}

// Query7 is a query for 7 components.
// Use a [Filter7] to create one.
//
// Queries are one-time use iterators and must be re-created each time before iterating.
//
// See [Query2] for a usage example.
type Query7[A any, B any, C any, D any, E any, F any, G any] struct {
	world      *World
	filter     *filter
	table      *table
	cache      *cacheEntry
	columnA    *column
	columnB    *column
	columnC    *column
	columnD    *column
	columnE    *column
	columnF    *column
	columnG    *column
	relations  []relationID
	tables     []tableID
	components []*componentStorage
	cursor     cursor
	lock       uint8
	rareComp   uint8
}

// GetRelation returns the entity relation target of the component at the given index.
func (q *Query7[A, B, C, D, E, F, G]) GetRelation(index int) Entity {
	return q.components[index].columns[q.table.id].target
}

// Count counts the entities matching this query.
//
// Has some overhead of iterating through archetypes.
// However, this is still much faster than manual counting via iteration.
//
// Does not iterate or close the query.
//
// See [Query2.Count] for an example.
func (q *Query7[A, B, C, D, E, F, G]) Count() int {
	if q.cache == nil {
		return countQuery(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp])
	}
	return countQueryCache(&q.world.storage, q.cache, q.relations)
}

// EntityAt returns the entity at a given index.
//
// The method is particularly useful for random sampling of entities from a query.
// However, performance depends on the number of archetypes in the world and in the query.
// In worlds with many archetypes, it is recommended to use a registered/cached filter.
//
// Do not use this to iterate a query! Use [Query7.Next] instead.
//
// Panics if the index is out of range, as indicated by [Query7.Count].
//
// See [Query2.EntityAt] for an example.
func (q *Query7[A, B, C, D, E, F, G]) EntityAt(index int) Entity {
	if q.cache == nil {
		return entityAt(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp], uint32(index))
	}
	return entityAtCache(&q.world.storage, q.cache, q.relations, uint32(index))
}

// Close closes the Query and unlocks the world.
//
// Automatically called when iteration completes.
// Needs to be called only if breaking out of the query iteration or not iterating at all.
func (q *Query7[A, B, C, D, E, F, G]) Close() {
	q.cursor.archetype = -2
	q.cursor.table = -2
	q.tables = nil
	q.table = nil
	q.cache = nil
	q.columnA = nil
	q.columnB = nil
	q.columnC = nil
	q.columnD = nil
	q.columnE = nil
	q.columnF = nil
	q.columnG = nil
	q.world.unlock(q.lock)
}

func (q *Query7[A, B, C, D, E, F, G]) nextTableOrArchetype() bool {
	if q.cache != nil {
		return q.nextTable(q.cache.tables)
	}
	if q.cursor.archetype >= 0 && q.nextTable(q.tables) {
		return true
	}
	return q.nextArchetype()
}

func (q *Query7[A, B, C, D, E, F, G]) nextArchetype() bool {
	q.tables = nil
	archetypes := q.world.storage.componentIndex[q.rareComp]
	maxArchIndex := int32(len(archetypes) - 1)
	for q.cursor.archetype < maxArchIndex {
		q.cursor.archetype++
		archetype := &q.world.storage.archetypes[archetypes[q.cursor.archetype]]

		if !q.filter.matches(&archetype.mask) {
			continue
		}

		if !archetype.HasRelations() {
			table := &q.world.storage.tables[archetype.tables.tables[0]]
			if table.Len() > 0 {
				q.setTable(0, table)
				return true
			}
			continue
		}

		q.tables = archetype.GetTables(q.relations)
		q.cursor.table = -1
		if q.nextTable(q.tables) {
			return true
		}
	}
	q.Close()
	return false
}

func (q *Query7[A, B, C, D, E, F, G]) nextTable(tables []tableID) bool {
	maxTableIndex := int32(len(tables) - 1)
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		table := &q.world.storage.tables[tables[q.cursor.table]]
		if table.Len() == 0 {
			continue
		}
		if !table.Matches(q.relations) {
			continue
		}
		q.setTable(q.cursor.table, table)
		return true
	}
	if q.cache != nil {
		q.Close()
	}
	return false
}

func (q *Query7[A, B, C, D, E, F, G]) setTable(index int32, table *table) {
	q.cursor.table = index
	q.table = table
	q.columnA = q.components[0].columns[q.table.id]
	q.columnB = q.components[1].columns[q.table.id]
	q.columnC = q.components[2].columns[q.table.id]
	q.columnD = q.components[3].columns[q.table.id]
	q.columnE = q.components[4].columns[q.table.id]
	q.columnF = q.components[5].columns[q.table.id]
	q.columnG = q.components[6].columns[q.table.id]
	q.cursor.index = 0
	q.cursor.maxIndex = int64(q.table.Len() - 1)
}

// Query8 is a query for 8 components.
// Use a [Filter8] to create one.
//
// Queries are one-time use iterators and must be re-created each time before iterating.
//
// See [Query2] for a usage example.
type Query8[A any, B any, C any, D any, E any, F any, G any, H any] struct {
	world      *World
	filter     *filter
	table      *table
	cache      *cacheEntry
	columnA    *column
	columnB    *column
	columnC    *column
	columnD    *column
	columnE    *column
	columnF    *column
	columnG    *column
	columnH    *column
	relations  []relationID
	tables     []tableID
	components []*componentStorage
	cursor     cursor
	lock       uint8
	rareComp   uint8
}

// GetRelation returns the entity relation target of the component at the given index.
func (q *Query8[A, B, C, D, E, F, G, H]) GetRelation(index int) Entity {
	return q.components[index].columns[q.table.id].target
}

// Count counts the entities matching this query.
//
// Has some overhead of iterating through archetypes.
// However, this is still much faster than manual counting via iteration.
//
// Does not iterate or close the query.
//
// See [Query2.Count] for an example.
func (q *Query8[A, B, C, D, E, F, G, H]) Count() int {
	if q.cache == nil {
		return countQuery(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp])
	}
	return countQueryCache(&q.world.storage, q.cache, q.relations)
}

// EntityAt returns the entity at a given index.
//
// The method is particularly useful for random sampling of entities from a query.
// However, performance depends on the number of archetypes in the world and in the query.
// In worlds with many archetypes, it is recommended to use a registered/cached filter.
//
// Do not use this to iterate a query! Use [Query8.Next] instead.
//
// Panics if the index is out of range, as indicated by [Query8.Count].
//
// See [Query2.EntityAt] for an example.
func (q *Query8[A, B, C, D, E, F, G, H]) EntityAt(index int) Entity {
	if q.cache == nil {
		return entityAt(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp], uint32(index))
	}
	return entityAtCache(&q.world.storage, q.cache, q.relations, uint32(index))
}

// Close closes the Query and unlocks the world.
//
// Automatically called when iteration completes.
// Needs to be called only if breaking out of the query iteration or not iterating at all.
func (q *Query8[A, B, C, D, E, F, G, H]) Close() {
	q.cursor.archetype = -2
	q.cursor.table = -2
	q.tables = nil
	q.table = nil
	q.cache = nil
	q.columnA = nil
	q.columnB = nil
	q.columnC = nil
	q.columnD = nil
	q.columnE = nil
	q.columnF = nil
	q.columnG = nil
	q.columnH = nil
	q.world.unlock(q.lock)
}

func (q *Query8[A, B, C, D, E, F, G, H]) nextTableOrArchetype() bool {
	if q.cache != nil {
		return q.nextTable(q.cache.tables)
	}
	if q.cursor.archetype >= 0 && q.nextTable(q.tables) {
		return true
	}
	return q.nextArchetype()
}

func (q *Query8[A, B, C, D, E, F, G, H]) nextArchetype() bool {
	q.tables = nil
	archetypes := q.world.storage.componentIndex[q.rareComp]
	maxArchIndex := int32(len(archetypes) - 1)
	for q.cursor.archetype < maxArchIndex {
		q.cursor.archetype++
		archetype := &q.world.storage.archetypes[archetypes[q.cursor.archetype]]

		if !q.filter.matches(&archetype.mask) {
			continue
		}

		if !archetype.HasRelations() {
			table := &q.world.storage.tables[archetype.tables.tables[0]]
			if table.Len() > 0 {
				q.setTable(0, table)
				return true
			}
			continue
		}

		q.tables = archetype.GetTables(q.relations)
		q.cursor.table = -1
		if q.nextTable(q.tables) {
			return true
		}
	}
	q.Close()
	return false
}

func (q *Query8[A, B, C, D, E, F, G, H]) nextTable(tables []tableID) bool {
	maxTableIndex := int32(len(tables) - 1)
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		table := &q.world.storage.tables[tables[q.cursor.table]]
		if table.Len() == 0 {
			continue
		}
		if !table.Matches(q.relations) {
			continue
		}
		q.setTable(q.cursor.table, table)
		return true
	}
	if q.cache != nil {
		q.Close()
	}
	return false
}

func (q *Query8[A, B, C, D, E, F, G, H]) setTable(index int32, table *table) {
	q.cursor.table = index
	q.table = table
	q.columnA = q.components[0].columns[q.table.id]
	q.columnB = q.components[1].columns[q.table.id]
	q.columnC = q.components[2].columns[q.table.id]
	q.columnD = q.components[3].columns[q.table.id]
	q.columnE = q.components[4].columns[q.table.id]
	q.columnF = q.components[5].columns[q.table.id]
	q.columnG = q.components[6].columns[q.table.id]
	q.columnH = q.components[7].columns[q.table.id]
	q.cursor.index = 0
	q.cursor.maxIndex = int64(q.table.Len() - 1)
}
