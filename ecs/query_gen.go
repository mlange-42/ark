package ecs

// Code generated by go generate; DO NOT EDIT.

import "unsafe"

type cursor struct {
	archetype int32
	table     int32
	index     uintptr
	maxIndex  int64
}

// Query0 is a query for 0 components.
// Use a [Filter0] to create one.
//
// Queries are one-time use iterators and must be re-created each time before iterating.
//
// See [Query2] for a usage example.
type Query0 struct {
	world       *World
	filter      *filter
	table       *table
	cache       *cacheEntry
	relations   []relationID
	tables      []tableID
	components  []*componentStorage
	cursor      cursor
	lock        uint8
	rareComp    uint8
	hasRareComp bool
}

// Count counts the entities matching this query.
//
// Has some overhead of iterating through archetypes.
// However, this is still much faster than manual counting via iteration.
//
// Does not iterate or close the query.
//
// See [Query2.Count] for an example.
func (q *Query0) Count() int {
	if q.cache == nil {
		if q.hasRareComp {
			return countQuery(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp])
		}
		return countQuery(&q.world.storage, q.filter, q.relations, q.world.storage.allArchetypes)
	}
	return countQueryCache(&q.world.storage, q.cache, q.relations)
}

// EntityAt returns the entity at a given index.
//
// The method is particularly useful for random sampling of entities from a query.
// However, performance depends on the number of archetypes in the world and in the query.
// In worlds with many archetypes, it is recommended to use a registered/cached filter.
//
// Do not use this to iterate a query! Use [Query0.Next] instead.
//
// Panics if the index is out of range, as indicated by [Query0.Count].
//
// See [Query2.EntityAt] for an example.
func (q *Query0) EntityAt(index int) Entity {
	if q.cache == nil {
		if q.hasRareComp {
			return entityAt(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp], uint32(index))
		}
		return entityAt(&q.world.storage, q.filter, q.relations, q.world.storage.allArchetypes, uint32(index))
	}
	return entityAtCache(&q.world.storage, q.cache, q.relations, uint32(index))
}

// Close closes the Query and unlocks the world.
//
// Automatically called when iteration completes.
// Needs to be called only if breaking out of the query iteration or not iterating at all.
func (q *Query0) Close() {
	q.cursor.archetype = -2
	q.cursor.table = -2
	q.tables = nil
	q.table = nil
	q.cache = nil
	q.world.unlockSafe(q.lock)
}

// IsClosed reports whether the query was closed.
//
// A query is considered closed after iteration finishes or Close()
// is called manually. Internally, this is represented by the cursor's
// table index being set to a value less than -1.
//
// Closed queries cannot be iterated and should not be reused.
// Create a new query instead.
func (q *Query0) IsClosed() bool {
	return q.cursor.table < -1
}

func (q *Query0) nextTableOrArchetype() bool {
	if q.cache != nil {
		return q.nextTable(q.cache.tables.tables)
	}
	if q.cursor.archetype >= 0 && q.nextTable(q.tables) {
		return true
	}
	return q.nextArchetype()
}

func (q *Query0) nextArchetype() bool {
	q.tables = nil
	var archetypes []archetypeID
	if q.hasRareComp {
		archetypes = q.world.storage.componentIndex[q.rareComp]
	} else {
		archetypes = q.world.storage.allArchetypes
	}
	maxArchIndex := int32(len(archetypes) - 1)
	for q.cursor.archetype < maxArchIndex {
		q.cursor.archetype++
		archetype := &q.world.storage.archetypes[archetypes[q.cursor.archetype]]

		if !q.filter.matches(&archetype.mask) {
			continue
		}

		if !archetype.HasRelations() {
			table := &q.world.storage.tables[archetype.tables.tables[0]]
			if table.len > 0 {
				q.setTable(0, table)
				return true
			}
			continue
		}

		q.tables = archetype.GetTables(q.relations)
		q.cursor.table = -1
		if q.nextTable(q.tables) {
			return true
		}
	}
	q.Close()
	return false
}

func (q *Query0) nextTable(tables []tableID) bool {
	maxTableIndex := int32(len(tables) - 1)
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		table := &q.world.storage.tables[tables[q.cursor.table]]
		if table.len == 0 || !table.Matches(q.relations) {
			continue
		}
		q.setTable(q.cursor.table, table)
		return true
	}
	if q.cache != nil {
		q.Close()
	}
	return false
}

func (q *Query0) setTable(index int32, table *table) {
	q.cursor.table = index
	q.table = table
	q.cursor.index = 0
	q.cursor.maxIndex = int64(q.table.len - 1)
}

// Query1 is a query for 1 components.
// Use a [Filter1] to create one.
//
// Queries are one-time use iterators and must be re-created each time before iterating.
//
// See [Query2] for a usage example.
type Query1[A any] struct {
	world      *World
	filter     *filter
	table      *table
	cache      *cacheEntry
	columnPtrA unsafe.Pointer
	itemSizeA  uintptr
	relations  []relationID
	tables     []tableID
	components []*componentStorage
	cursor     cursor
	lock       uint8
	rareComp   uint8
}

// GetRelation returns the entity relation target of the component at the given index.
func (q *Query1[A]) GetRelation(index int) Entity {
	return q.components[index].columns[q.table.id].target
}

// Count counts the entities matching this query.
//
// Has some overhead of iterating through archetypes.
// However, this is still much faster than manual counting via iteration.
//
// Does not iterate or close the query.
//
// See [Query2.Count] for an example.
func (q *Query1[A]) Count() int {
	if q.cache == nil {
		return countQuery(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp])
	}
	return countQueryCache(&q.world.storage, q.cache, q.relations)
}

// EntityAt returns the entity at a given index.
//
// The method is particularly useful for random sampling of entities from a query.
// However, performance depends on the number of archetypes in the world and in the query.
// In worlds with many archetypes, it is recommended to use a registered/cached filter.
//
// Do not use this to iterate a query! Use [Query1.Next] instead.
//
// Panics if the index is out of range, as indicated by [Query1.Count].
//
// See [Query2.EntityAt] for an example.
func (q *Query1[A]) EntityAt(index int) Entity {
	if q.cache == nil {
		return entityAt(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp], uint32(index))
	}
	return entityAtCache(&q.world.storage, q.cache, q.relations, uint32(index))
}

// Close closes the Query and unlocks the world.
//
// Automatically called when iteration completes.
// Needs to be called only if breaking out of the query iteration or not iterating at all.
func (q *Query1[A]) Close() {
	q.cursor.archetype = -2
	q.cursor.table = -2
	q.tables = nil
	q.table = nil
	q.cache = nil
	q.columnPtrA = unsafe.Pointer(nilDummy)
	q.itemSizeA = 0
	q.world.unlockSafe(q.lock)
}

// IsClosed reports whether the query was closed.
//
// A query is considered closed after iteration finishes or Close()
// is called manually. Internally, this is represented by the cursor's
// table index being set to a value less than -1.
//
// Closed queries cannot be iterated and should not be reused.
// Create a new query instead.
func (q *Query1[A]) IsClosed() bool {
	return q.cursor.table < -1
}

func (q *Query1[A]) nextTableOrArchetype() bool {
	if q.cache != nil {
		return q.nextTable(q.cache.tables.tables)
	}
	if q.cursor.archetype >= 0 && q.nextTable(q.tables) {
		return true
	}
	return q.nextArchetype()
}

func (q *Query1[A]) nextArchetype() bool {
	q.tables = nil
	archetypes := q.world.storage.componentIndex[q.rareComp]
	maxArchIndex := int32(len(archetypes) - 1)
	for q.cursor.archetype < maxArchIndex {
		q.cursor.archetype++
		archetype := &q.world.storage.archetypes[archetypes[q.cursor.archetype]]

		if !q.filter.matches(&archetype.mask) {
			continue
		}

		if !archetype.HasRelations() {
			table := &q.world.storage.tables[archetype.tables.tables[0]]
			if table.len > 0 {
				q.setTable(0, table)
				return true
			}
			continue
		}

		q.tables = archetype.GetTables(q.relations)
		q.cursor.table = -1
		if q.nextTable(q.tables) {
			return true
		}
	}
	q.Close()
	return false
}

func (q *Query1[A]) nextTable(tables []tableID) bool {
	maxTableIndex := int32(len(tables) - 1)
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		table := &q.world.storage.tables[tables[q.cursor.table]]
		if table.len == 0 || !table.Matches(q.relations) {
			continue
		}
		q.setTable(q.cursor.table, table)
		return true
	}
	if q.cache != nil {
		q.Close()
	}
	return false
}

func (q *Query1[A]) setTable(index int32, table *table) {
	q.cursor.table = index
	q.table = table
	columnA := q.components[0].columns[q.table.id]
	q.columnPtrA = columnA.pointer
	q.itemSizeA = columnA.itemSize
	q.cursor.index = 0
	q.cursor.maxIndex = int64(q.table.len - 1)
}

// Query2 is a query for 2 components.
// Use a [Filter2] to create one.
//
// Queries are one-time use iterators and must be re-created each time before iterating.
type Query2[A any, B any] struct {
	world      *World
	filter     *filter
	table      *table
	cache      *cacheEntry
	columnPtrA unsafe.Pointer
	itemSizeA  uintptr
	columnPtrB unsafe.Pointer
	itemSizeB  uintptr
	relations  []relationID
	tables     []tableID
	components []*componentStorage
	cursor     cursor
	lock       uint8
	rareComp   uint8
}

// GetRelation returns the entity relation target of the component at the given index.
func (q *Query2[A, B]) GetRelation(index int) Entity {
	return q.components[index].columns[q.table.id].target
}

// Count counts the entities matching this query.
//
// Has some overhead of iterating through archetypes.
// However, this is still much faster than manual counting via iteration.
//
// Does not iterate or close the query.
func (q *Query2[A, B]) Count() int {
	if q.cache == nil {
		return countQuery(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp])
	}
	return countQueryCache(&q.world.storage, q.cache, q.relations)
}

// EntityAt returns the entity at a given index.
//
// The method is particularly useful for random sampling of entities from a query.
// However, performance depends on the number of archetypes in the world and in the query.
// In worlds with many archetypes, it is recommended to use a registered/cached filter.
//
// Do not use this to iterate a query! Use [Query2.Next] instead.
//
// Panics if the index is out of range, as indicated by [Query2.Count].
func (q *Query2[A, B]) EntityAt(index int) Entity {
	if q.cache == nil {
		return entityAt(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp], uint32(index))
	}
	return entityAtCache(&q.world.storage, q.cache, q.relations, uint32(index))
}

// Close closes the Query and unlocks the world.
//
// Automatically called when iteration completes.
// Needs to be called only if breaking out of the query iteration or not iterating at all.
func (q *Query2[A, B]) Close() {
	q.cursor.archetype = -2
	q.cursor.table = -2
	q.tables = nil
	q.table = nil
	q.cache = nil
	q.columnPtrA = unsafe.Pointer(nilDummy)
	q.itemSizeA = 0
	q.columnPtrB = unsafe.Pointer(nilDummy)
	q.itemSizeB = 0
	q.world.unlockSafe(q.lock)
}

// IsClosed reports whether the query was closed.
//
// A query is considered closed after iteration finishes or Close()
// is called manually. Internally, this is represented by the cursor's
// table index being set to a value less than -1.
//
// Closed queries cannot be iterated and should not be reused.
// Create a new query instead.
func (q *Query2[A, B]) IsClosed() bool {
	return q.cursor.table < -1
}

func (q *Query2[A, B]) nextTableOrArchetype() bool {
	if q.cache != nil {
		return q.nextTable(q.cache.tables.tables)
	}
	if q.cursor.archetype >= 0 && q.nextTable(q.tables) {
		return true
	}
	return q.nextArchetype()
}

func (q *Query2[A, B]) nextArchetype() bool {
	q.tables = nil
	archetypes := q.world.storage.componentIndex[q.rareComp]
	maxArchIndex := int32(len(archetypes) - 1)
	for q.cursor.archetype < maxArchIndex {
		q.cursor.archetype++
		archetype := &q.world.storage.archetypes[archetypes[q.cursor.archetype]]

		if !q.filter.matches(&archetype.mask) {
			continue
		}

		if !archetype.HasRelations() {
			table := &q.world.storage.tables[archetype.tables.tables[0]]
			if table.len > 0 {
				q.setTable(0, table)
				return true
			}
			continue
		}

		q.tables = archetype.GetTables(q.relations)
		q.cursor.table = -1
		if q.nextTable(q.tables) {
			return true
		}
	}
	q.Close()
	return false
}

func (q *Query2[A, B]) nextTable(tables []tableID) bool {
	maxTableIndex := int32(len(tables) - 1)
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		table := &q.world.storage.tables[tables[q.cursor.table]]
		if table.len == 0 || !table.Matches(q.relations) {
			continue
		}
		q.setTable(q.cursor.table, table)
		return true
	}
	if q.cache != nil {
		q.Close()
	}
	return false
}

func (q *Query2[A, B]) setTable(index int32, table *table) {
	q.cursor.table = index
	q.table = table
	columnA := q.components[0].columns[q.table.id]
	q.columnPtrA = columnA.pointer
	q.itemSizeA = columnA.itemSize
	columnB := q.components[1].columns[q.table.id]
	q.columnPtrB = columnB.pointer
	q.itemSizeB = columnB.itemSize
	q.cursor.index = 0
	q.cursor.maxIndex = int64(q.table.len - 1)
}

// Query3 is a query for 3 components.
// Use a [Filter3] to create one.
//
// Queries are one-time use iterators and must be re-created each time before iterating.
//
// See [Query2] for a usage example.
type Query3[A any, B any, C any] struct {
	world      *World
	filter     *filter
	table      *table
	cache      *cacheEntry
	columnPtrA unsafe.Pointer
	itemSizeA  uintptr
	columnPtrB unsafe.Pointer
	itemSizeB  uintptr
	columnPtrC unsafe.Pointer
	itemSizeC  uintptr
	relations  []relationID
	tables     []tableID
	components []*componentStorage
	cursor     cursor
	lock       uint8
	rareComp   uint8
}

// GetRelation returns the entity relation target of the component at the given index.
func (q *Query3[A, B, C]) GetRelation(index int) Entity {
	return q.components[index].columns[q.table.id].target
}

// Count counts the entities matching this query.
//
// Has some overhead of iterating through archetypes.
// However, this is still much faster than manual counting via iteration.
//
// Does not iterate or close the query.
//
// See [Query2.Count] for an example.
func (q *Query3[A, B, C]) Count() int {
	if q.cache == nil {
		return countQuery(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp])
	}
	return countQueryCache(&q.world.storage, q.cache, q.relations)
}

// EntityAt returns the entity at a given index.
//
// The method is particularly useful for random sampling of entities from a query.
// However, performance depends on the number of archetypes in the world and in the query.
// In worlds with many archetypes, it is recommended to use a registered/cached filter.
//
// Do not use this to iterate a query! Use [Query3.Next] instead.
//
// Panics if the index is out of range, as indicated by [Query3.Count].
//
// See [Query2.EntityAt] for an example.
func (q *Query3[A, B, C]) EntityAt(index int) Entity {
	if q.cache == nil {
		return entityAt(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp], uint32(index))
	}
	return entityAtCache(&q.world.storage, q.cache, q.relations, uint32(index))
}

// Close closes the Query and unlocks the world.
//
// Automatically called when iteration completes.
// Needs to be called only if breaking out of the query iteration or not iterating at all.
func (q *Query3[A, B, C]) Close() {
	q.cursor.archetype = -2
	q.cursor.table = -2
	q.tables = nil
	q.table = nil
	q.cache = nil
	q.columnPtrA = unsafe.Pointer(nilDummy)
	q.itemSizeA = 0
	q.columnPtrB = unsafe.Pointer(nilDummy)
	q.itemSizeB = 0
	q.columnPtrC = unsafe.Pointer(nilDummy)
	q.itemSizeC = 0
	q.world.unlockSafe(q.lock)
}

// IsClosed reports whether the query was closed.
//
// A query is considered closed after iteration finishes or Close()
// is called manually. Internally, this is represented by the cursor's
// table index being set to a value less than -1.
//
// Closed queries cannot be iterated and should not be reused.
// Create a new query instead.
func (q *Query3[A, B, C]) IsClosed() bool {
	return q.cursor.table < -1
}

func (q *Query3[A, B, C]) nextTableOrArchetype() bool {
	if q.cache != nil {
		return q.nextTable(q.cache.tables.tables)
	}
	if q.cursor.archetype >= 0 && q.nextTable(q.tables) {
		return true
	}
	return q.nextArchetype()
}

func (q *Query3[A, B, C]) nextArchetype() bool {
	q.tables = nil
	archetypes := q.world.storage.componentIndex[q.rareComp]
	maxArchIndex := int32(len(archetypes) - 1)
	for q.cursor.archetype < maxArchIndex {
		q.cursor.archetype++
		archetype := &q.world.storage.archetypes[archetypes[q.cursor.archetype]]

		if !q.filter.matches(&archetype.mask) {
			continue
		}

		if !archetype.HasRelations() {
			table := &q.world.storage.tables[archetype.tables.tables[0]]
			if table.len > 0 {
				q.setTable(0, table)
				return true
			}
			continue
		}

		q.tables = archetype.GetTables(q.relations)
		q.cursor.table = -1
		if q.nextTable(q.tables) {
			return true
		}
	}
	q.Close()
	return false
}

func (q *Query3[A, B, C]) nextTable(tables []tableID) bool {
	maxTableIndex := int32(len(tables) - 1)
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		table := &q.world.storage.tables[tables[q.cursor.table]]
		if table.len == 0 || !table.Matches(q.relations) {
			continue
		}
		q.setTable(q.cursor.table, table)
		return true
	}
	if q.cache != nil {
		q.Close()
	}
	return false
}

func (q *Query3[A, B, C]) setTable(index int32, table *table) {
	q.cursor.table = index
	q.table = table
	columnA := q.components[0].columns[q.table.id]
	q.columnPtrA = columnA.pointer
	q.itemSizeA = columnA.itemSize
	columnB := q.components[1].columns[q.table.id]
	q.columnPtrB = columnB.pointer
	q.itemSizeB = columnB.itemSize
	columnC := q.components[2].columns[q.table.id]
	q.columnPtrC = columnC.pointer
	q.itemSizeC = columnC.itemSize
	q.cursor.index = 0
	q.cursor.maxIndex = int64(q.table.len - 1)
}

// Query4 is a query for 4 components.
// Use a [Filter4] to create one.
//
// Queries are one-time use iterators and must be re-created each time before iterating.
//
// See [Query2] for a usage example.
type Query4[A any, B any, C any, D any] struct {
	world      *World
	filter     *filter
	table      *table
	cache      *cacheEntry
	columnPtrA unsafe.Pointer
	itemSizeA  uintptr
	columnPtrB unsafe.Pointer
	itemSizeB  uintptr
	columnPtrC unsafe.Pointer
	itemSizeC  uintptr
	columnPtrD unsafe.Pointer
	itemSizeD  uintptr
	relations  []relationID
	tables     []tableID
	components []*componentStorage
	cursor     cursor
	lock       uint8
	rareComp   uint8
}

// GetRelation returns the entity relation target of the component at the given index.
func (q *Query4[A, B, C, D]) GetRelation(index int) Entity {
	return q.components[index].columns[q.table.id].target
}

// Count counts the entities matching this query.
//
// Has some overhead of iterating through archetypes.
// However, this is still much faster than manual counting via iteration.
//
// Does not iterate or close the query.
//
// See [Query2.Count] for an example.
func (q *Query4[A, B, C, D]) Count() int {
	if q.cache == nil {
		return countQuery(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp])
	}
	return countQueryCache(&q.world.storage, q.cache, q.relations)
}

// EntityAt returns the entity at a given index.
//
// The method is particularly useful for random sampling of entities from a query.
// However, performance depends on the number of archetypes in the world and in the query.
// In worlds with many archetypes, it is recommended to use a registered/cached filter.
//
// Do not use this to iterate a query! Use [Query4.Next] instead.
//
// Panics if the index is out of range, as indicated by [Query4.Count].
//
// See [Query2.EntityAt] for an example.
func (q *Query4[A, B, C, D]) EntityAt(index int) Entity {
	if q.cache == nil {
		return entityAt(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp], uint32(index))
	}
	return entityAtCache(&q.world.storage, q.cache, q.relations, uint32(index))
}

// Close closes the Query and unlocks the world.
//
// Automatically called when iteration completes.
// Needs to be called only if breaking out of the query iteration or not iterating at all.
func (q *Query4[A, B, C, D]) Close() {
	q.cursor.archetype = -2
	q.cursor.table = -2
	q.tables = nil
	q.table = nil
	q.cache = nil
	q.columnPtrA = unsafe.Pointer(nilDummy)
	q.itemSizeA = 0
	q.columnPtrB = unsafe.Pointer(nilDummy)
	q.itemSizeB = 0
	q.columnPtrC = unsafe.Pointer(nilDummy)
	q.itemSizeC = 0
	q.columnPtrD = unsafe.Pointer(nilDummy)
	q.itemSizeD = 0
	q.world.unlockSafe(q.lock)
}

// IsClosed reports whether the query was closed.
//
// A query is considered closed after iteration finishes or Close()
// is called manually. Internally, this is represented by the cursor's
// table index being set to a value less than -1.
//
// Closed queries cannot be iterated and should not be reused.
// Create a new query instead.
func (q *Query4[A, B, C, D]) IsClosed() bool {
	return q.cursor.table < -1
}

func (q *Query4[A, B, C, D]) nextTableOrArchetype() bool {
	if q.cache != nil {
		return q.nextTable(q.cache.tables.tables)
	}
	if q.cursor.archetype >= 0 && q.nextTable(q.tables) {
		return true
	}
	return q.nextArchetype()
}

func (q *Query4[A, B, C, D]) nextArchetype() bool {
	q.tables = nil
	archetypes := q.world.storage.componentIndex[q.rareComp]
	maxArchIndex := int32(len(archetypes) - 1)
	for q.cursor.archetype < maxArchIndex {
		q.cursor.archetype++
		archetype := &q.world.storage.archetypes[archetypes[q.cursor.archetype]]

		if !q.filter.matches(&archetype.mask) {
			continue
		}

		if !archetype.HasRelations() {
			table := &q.world.storage.tables[archetype.tables.tables[0]]
			if table.len > 0 {
				q.setTable(0, table)
				return true
			}
			continue
		}

		q.tables = archetype.GetTables(q.relations)
		q.cursor.table = -1
		if q.nextTable(q.tables) {
			return true
		}
	}
	q.Close()
	return false
}

func (q *Query4[A, B, C, D]) nextTable(tables []tableID) bool {
	maxTableIndex := int32(len(tables) - 1)
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		table := &q.world.storage.tables[tables[q.cursor.table]]
		if table.len == 0 || !table.Matches(q.relations) {
			continue
		}
		q.setTable(q.cursor.table, table)
		return true
	}
	if q.cache != nil {
		q.Close()
	}
	return false
}

func (q *Query4[A, B, C, D]) setTable(index int32, table *table) {
	q.cursor.table = index
	q.table = table
	columnA := q.components[0].columns[q.table.id]
	q.columnPtrA = columnA.pointer
	q.itemSizeA = columnA.itemSize
	columnB := q.components[1].columns[q.table.id]
	q.columnPtrB = columnB.pointer
	q.itemSizeB = columnB.itemSize
	columnC := q.components[2].columns[q.table.id]
	q.columnPtrC = columnC.pointer
	q.itemSizeC = columnC.itemSize
	columnD := q.components[3].columns[q.table.id]
	q.columnPtrD = columnD.pointer
	q.itemSizeD = columnD.itemSize
	q.cursor.index = 0
	q.cursor.maxIndex = int64(q.table.len - 1)
}

// Query5 is a query for 5 components.
// Use a [Filter5] to create one.
//
// Queries are one-time use iterators and must be re-created each time before iterating.
//
// See [Query2] for a usage example.
type Query5[A any, B any, C any, D any, E any] struct {
	world      *World
	filter     *filter
	table      *table
	cache      *cacheEntry
	columnPtrA unsafe.Pointer
	itemSizeA  uintptr
	columnPtrB unsafe.Pointer
	itemSizeB  uintptr
	columnPtrC unsafe.Pointer
	itemSizeC  uintptr
	columnPtrD unsafe.Pointer
	itemSizeD  uintptr
	columnPtrE unsafe.Pointer
	itemSizeE  uintptr
	relations  []relationID
	tables     []tableID
	components []*componentStorage
	cursor     cursor
	lock       uint8
	rareComp   uint8
}

// GetRelation returns the entity relation target of the component at the given index.
func (q *Query5[A, B, C, D, E]) GetRelation(index int) Entity {
	return q.components[index].columns[q.table.id].target
}

// Count counts the entities matching this query.
//
// Has some overhead of iterating through archetypes.
// However, this is still much faster than manual counting via iteration.
//
// Does not iterate or close the query.
//
// See [Query2.Count] for an example.
func (q *Query5[A, B, C, D, E]) Count() int {
	if q.cache == nil {
		return countQuery(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp])
	}
	return countQueryCache(&q.world.storage, q.cache, q.relations)
}

// EntityAt returns the entity at a given index.
//
// The method is particularly useful for random sampling of entities from a query.
// However, performance depends on the number of archetypes in the world and in the query.
// In worlds with many archetypes, it is recommended to use a registered/cached filter.
//
// Do not use this to iterate a query! Use [Query5.Next] instead.
//
// Panics if the index is out of range, as indicated by [Query5.Count].
//
// See [Query2.EntityAt] for an example.
func (q *Query5[A, B, C, D, E]) EntityAt(index int) Entity {
	if q.cache == nil {
		return entityAt(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp], uint32(index))
	}
	return entityAtCache(&q.world.storage, q.cache, q.relations, uint32(index))
}

// Close closes the Query and unlocks the world.
//
// Automatically called when iteration completes.
// Needs to be called only if breaking out of the query iteration or not iterating at all.
func (q *Query5[A, B, C, D, E]) Close() {
	q.cursor.archetype = -2
	q.cursor.table = -2
	q.tables = nil
	q.table = nil
	q.cache = nil
	q.columnPtrA = unsafe.Pointer(nilDummy)
	q.itemSizeA = 0
	q.columnPtrB = unsafe.Pointer(nilDummy)
	q.itemSizeB = 0
	q.columnPtrC = unsafe.Pointer(nilDummy)
	q.itemSizeC = 0
	q.columnPtrD = unsafe.Pointer(nilDummy)
	q.itemSizeD = 0
	q.columnPtrE = unsafe.Pointer(nilDummy)
	q.itemSizeE = 0
	q.world.unlockSafe(q.lock)
}

// IsClosed reports whether the query was closed.
//
// A query is considered closed after iteration finishes or Close()
// is called manually. Internally, this is represented by the cursor's
// table index being set to a value less than -1.
//
// Closed queries cannot be iterated and should not be reused.
// Create a new query instead.
func (q *Query5[A, B, C, D, E]) IsClosed() bool {
	return q.cursor.table < -1
}

func (q *Query5[A, B, C, D, E]) nextTableOrArchetype() bool {
	if q.cache != nil {
		return q.nextTable(q.cache.tables.tables)
	}
	if q.cursor.archetype >= 0 && q.nextTable(q.tables) {
		return true
	}
	return q.nextArchetype()
}

func (q *Query5[A, B, C, D, E]) nextArchetype() bool {
	q.tables = nil
	archetypes := q.world.storage.componentIndex[q.rareComp]
	maxArchIndex := int32(len(archetypes) - 1)
	for q.cursor.archetype < maxArchIndex {
		q.cursor.archetype++
		archetype := &q.world.storage.archetypes[archetypes[q.cursor.archetype]]

		if !q.filter.matches(&archetype.mask) {
			continue
		}

		if !archetype.HasRelations() {
			table := &q.world.storage.tables[archetype.tables.tables[0]]
			if table.len > 0 {
				q.setTable(0, table)
				return true
			}
			continue
		}

		q.tables = archetype.GetTables(q.relations)
		q.cursor.table = -1
		if q.nextTable(q.tables) {
			return true
		}
	}
	q.Close()
	return false
}

func (q *Query5[A, B, C, D, E]) nextTable(tables []tableID) bool {
	maxTableIndex := int32(len(tables) - 1)
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		table := &q.world.storage.tables[tables[q.cursor.table]]
		if table.len == 0 || !table.Matches(q.relations) {
			continue
		}
		q.setTable(q.cursor.table, table)
		return true
	}
	if q.cache != nil {
		q.Close()
	}
	return false
}

func (q *Query5[A, B, C, D, E]) setTable(index int32, table *table) {
	q.cursor.table = index
	q.table = table
	columnA := q.components[0].columns[q.table.id]
	q.columnPtrA = columnA.pointer
	q.itemSizeA = columnA.itemSize
	columnB := q.components[1].columns[q.table.id]
	q.columnPtrB = columnB.pointer
	q.itemSizeB = columnB.itemSize
	columnC := q.components[2].columns[q.table.id]
	q.columnPtrC = columnC.pointer
	q.itemSizeC = columnC.itemSize
	columnD := q.components[3].columns[q.table.id]
	q.columnPtrD = columnD.pointer
	q.itemSizeD = columnD.itemSize
	columnE := q.components[4].columns[q.table.id]
	q.columnPtrE = columnE.pointer
	q.itemSizeE = columnE.itemSize
	q.cursor.index = 0
	q.cursor.maxIndex = int64(q.table.len - 1)
}

// Query6 is a query for 6 components.
// Use a [Filter6] to create one.
//
// Queries are one-time use iterators and must be re-created each time before iterating.
//
// See [Query2] for a usage example.
type Query6[A any, B any, C any, D any, E any, F any] struct {
	world      *World
	filter     *filter
	table      *table
	cache      *cacheEntry
	columnPtrA unsafe.Pointer
	itemSizeA  uintptr
	columnPtrB unsafe.Pointer
	itemSizeB  uintptr
	columnPtrC unsafe.Pointer
	itemSizeC  uintptr
	columnPtrD unsafe.Pointer
	itemSizeD  uintptr
	columnPtrE unsafe.Pointer
	itemSizeE  uintptr
	columnPtrF unsafe.Pointer
	itemSizeF  uintptr
	relations  []relationID
	tables     []tableID
	components []*componentStorage
	cursor     cursor
	lock       uint8
	rareComp   uint8
}

// GetRelation returns the entity relation target of the component at the given index.
func (q *Query6[A, B, C, D, E, F]) GetRelation(index int) Entity {
	return q.components[index].columns[q.table.id].target
}

// Count counts the entities matching this query.
//
// Has some overhead of iterating through archetypes.
// However, this is still much faster than manual counting via iteration.
//
// Does not iterate or close the query.
//
// See [Query2.Count] for an example.
func (q *Query6[A, B, C, D, E, F]) Count() int {
	if q.cache == nil {
		return countQuery(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp])
	}
	return countQueryCache(&q.world.storage, q.cache, q.relations)
}

// EntityAt returns the entity at a given index.
//
// The method is particularly useful for random sampling of entities from a query.
// However, performance depends on the number of archetypes in the world and in the query.
// In worlds with many archetypes, it is recommended to use a registered/cached filter.
//
// Do not use this to iterate a query! Use [Query6.Next] instead.
//
// Panics if the index is out of range, as indicated by [Query6.Count].
//
// See [Query2.EntityAt] for an example.
func (q *Query6[A, B, C, D, E, F]) EntityAt(index int) Entity {
	if q.cache == nil {
		return entityAt(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp], uint32(index))
	}
	return entityAtCache(&q.world.storage, q.cache, q.relations, uint32(index))
}

// Close closes the Query and unlocks the world.
//
// Automatically called when iteration completes.
// Needs to be called only if breaking out of the query iteration or not iterating at all.
func (q *Query6[A, B, C, D, E, F]) Close() {
	q.cursor.archetype = -2
	q.cursor.table = -2
	q.tables = nil
	q.table = nil
	q.cache = nil
	q.columnPtrA = unsafe.Pointer(nilDummy)
	q.itemSizeA = 0
	q.columnPtrB = unsafe.Pointer(nilDummy)
	q.itemSizeB = 0
	q.columnPtrC = unsafe.Pointer(nilDummy)
	q.itemSizeC = 0
	q.columnPtrD = unsafe.Pointer(nilDummy)
	q.itemSizeD = 0
	q.columnPtrE = unsafe.Pointer(nilDummy)
	q.itemSizeE = 0
	q.columnPtrF = unsafe.Pointer(nilDummy)
	q.itemSizeF = 0
	q.world.unlockSafe(q.lock)
}

// IsClosed reports whether the query was closed.
//
// A query is considered closed after iteration finishes or Close()
// is called manually. Internally, this is represented by the cursor's
// table index being set to a value less than -1.
//
// Closed queries cannot be iterated and should not be reused.
// Create a new query instead.
func (q *Query6[A, B, C, D, E, F]) IsClosed() bool {
	return q.cursor.table < -1
}

func (q *Query6[A, B, C, D, E, F]) nextTableOrArchetype() bool {
	if q.cache != nil {
		return q.nextTable(q.cache.tables.tables)
	}
	if q.cursor.archetype >= 0 && q.nextTable(q.tables) {
		return true
	}
	return q.nextArchetype()
}

func (q *Query6[A, B, C, D, E, F]) nextArchetype() bool {
	q.tables = nil
	archetypes := q.world.storage.componentIndex[q.rareComp]
	maxArchIndex := int32(len(archetypes) - 1)
	for q.cursor.archetype < maxArchIndex {
		q.cursor.archetype++
		archetype := &q.world.storage.archetypes[archetypes[q.cursor.archetype]]

		if !q.filter.matches(&archetype.mask) {
			continue
		}

		if !archetype.HasRelations() {
			table := &q.world.storage.tables[archetype.tables.tables[0]]
			if table.len > 0 {
				q.setTable(0, table)
				return true
			}
			continue
		}

		q.tables = archetype.GetTables(q.relations)
		q.cursor.table = -1
		if q.nextTable(q.tables) {
			return true
		}
	}
	q.Close()
	return false
}

func (q *Query6[A, B, C, D, E, F]) nextTable(tables []tableID) bool {
	maxTableIndex := int32(len(tables) - 1)
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		table := &q.world.storage.tables[tables[q.cursor.table]]
		if table.len == 0 || !table.Matches(q.relations) {
			continue
		}
		q.setTable(q.cursor.table, table)
		return true
	}
	if q.cache != nil {
		q.Close()
	}
	return false
}

func (q *Query6[A, B, C, D, E, F]) setTable(index int32, table *table) {
	q.cursor.table = index
	q.table = table
	columnA := q.components[0].columns[q.table.id]
	q.columnPtrA = columnA.pointer
	q.itemSizeA = columnA.itemSize
	columnB := q.components[1].columns[q.table.id]
	q.columnPtrB = columnB.pointer
	q.itemSizeB = columnB.itemSize
	columnC := q.components[2].columns[q.table.id]
	q.columnPtrC = columnC.pointer
	q.itemSizeC = columnC.itemSize
	columnD := q.components[3].columns[q.table.id]
	q.columnPtrD = columnD.pointer
	q.itemSizeD = columnD.itemSize
	columnE := q.components[4].columns[q.table.id]
	q.columnPtrE = columnE.pointer
	q.itemSizeE = columnE.itemSize
	columnF := q.components[5].columns[q.table.id]
	q.columnPtrF = columnF.pointer
	q.itemSizeF = columnF.itemSize
	q.cursor.index = 0
	q.cursor.maxIndex = int64(q.table.len - 1)
}

// Query7 is a query for 7 components.
// Use a [Filter7] to create one.
//
// Queries are one-time use iterators and must be re-created each time before iterating.
//
// See [Query2] for a usage example.
type Query7[A any, B any, C any, D any, E any, F any, G any] struct {
	world      *World
	filter     *filter
	table      *table
	cache      *cacheEntry
	columnPtrA unsafe.Pointer
	itemSizeA  uintptr
	columnPtrB unsafe.Pointer
	itemSizeB  uintptr
	columnPtrC unsafe.Pointer
	itemSizeC  uintptr
	columnPtrD unsafe.Pointer
	itemSizeD  uintptr
	columnPtrE unsafe.Pointer
	itemSizeE  uintptr
	columnPtrF unsafe.Pointer
	itemSizeF  uintptr
	columnPtrG unsafe.Pointer
	itemSizeG  uintptr
	relations  []relationID
	tables     []tableID
	components []*componentStorage
	cursor     cursor
	lock       uint8
	rareComp   uint8
}

// GetRelation returns the entity relation target of the component at the given index.
func (q *Query7[A, B, C, D, E, F, G]) GetRelation(index int) Entity {
	return q.components[index].columns[q.table.id].target
}

// Count counts the entities matching this query.
//
// Has some overhead of iterating through archetypes.
// However, this is still much faster than manual counting via iteration.
//
// Does not iterate or close the query.
//
// See [Query2.Count] for an example.
func (q *Query7[A, B, C, D, E, F, G]) Count() int {
	if q.cache == nil {
		return countQuery(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp])
	}
	return countQueryCache(&q.world.storage, q.cache, q.relations)
}

// EntityAt returns the entity at a given index.
//
// The method is particularly useful for random sampling of entities from a query.
// However, performance depends on the number of archetypes in the world and in the query.
// In worlds with many archetypes, it is recommended to use a registered/cached filter.
//
// Do not use this to iterate a query! Use [Query7.Next] instead.
//
// Panics if the index is out of range, as indicated by [Query7.Count].
//
// See [Query2.EntityAt] for an example.
func (q *Query7[A, B, C, D, E, F, G]) EntityAt(index int) Entity {
	if q.cache == nil {
		return entityAt(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp], uint32(index))
	}
	return entityAtCache(&q.world.storage, q.cache, q.relations, uint32(index))
}

// Close closes the Query and unlocks the world.
//
// Automatically called when iteration completes.
// Needs to be called only if breaking out of the query iteration or not iterating at all.
func (q *Query7[A, B, C, D, E, F, G]) Close() {
	q.cursor.archetype = -2
	q.cursor.table = -2
	q.tables = nil
	q.table = nil
	q.cache = nil
	q.columnPtrA = unsafe.Pointer(nilDummy)
	q.itemSizeA = 0
	q.columnPtrB = unsafe.Pointer(nilDummy)
	q.itemSizeB = 0
	q.columnPtrC = unsafe.Pointer(nilDummy)
	q.itemSizeC = 0
	q.columnPtrD = unsafe.Pointer(nilDummy)
	q.itemSizeD = 0
	q.columnPtrE = unsafe.Pointer(nilDummy)
	q.itemSizeE = 0
	q.columnPtrF = unsafe.Pointer(nilDummy)
	q.itemSizeF = 0
	q.columnPtrG = unsafe.Pointer(nilDummy)
	q.itemSizeG = 0
	q.world.unlockSafe(q.lock)
}

// IsClosed reports whether the query was closed.
//
// A query is considered closed after iteration finishes or Close()
// is called manually. Internally, this is represented by the cursor's
// table index being set to a value less than -1.
//
// Closed queries cannot be iterated and should not be reused.
// Create a new query instead.
func (q *Query7[A, B, C, D, E, F, G]) IsClosed() bool {
	return q.cursor.table < -1
}

func (q *Query7[A, B, C, D, E, F, G]) nextTableOrArchetype() bool {
	if q.cache != nil {
		return q.nextTable(q.cache.tables.tables)
	}
	if q.cursor.archetype >= 0 && q.nextTable(q.tables) {
		return true
	}
	return q.nextArchetype()
}

func (q *Query7[A, B, C, D, E, F, G]) nextArchetype() bool {
	q.tables = nil
	archetypes := q.world.storage.componentIndex[q.rareComp]
	maxArchIndex := int32(len(archetypes) - 1)
	for q.cursor.archetype < maxArchIndex {
		q.cursor.archetype++
		archetype := &q.world.storage.archetypes[archetypes[q.cursor.archetype]]

		if !q.filter.matches(&archetype.mask) {
			continue
		}

		if !archetype.HasRelations() {
			table := &q.world.storage.tables[archetype.tables.tables[0]]
			if table.len > 0 {
				q.setTable(0, table)
				return true
			}
			continue
		}

		q.tables = archetype.GetTables(q.relations)
		q.cursor.table = -1
		if q.nextTable(q.tables) {
			return true
		}
	}
	q.Close()
	return false
}

func (q *Query7[A, B, C, D, E, F, G]) nextTable(tables []tableID) bool {
	maxTableIndex := int32(len(tables) - 1)
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		table := &q.world.storage.tables[tables[q.cursor.table]]
		if table.len == 0 || !table.Matches(q.relations) {
			continue
		}
		q.setTable(q.cursor.table, table)
		return true
	}
	if q.cache != nil {
		q.Close()
	}
	return false
}

func (q *Query7[A, B, C, D, E, F, G]) setTable(index int32, table *table) {
	q.cursor.table = index
	q.table = table
	columnA := q.components[0].columns[q.table.id]
	q.columnPtrA = columnA.pointer
	q.itemSizeA = columnA.itemSize
	columnB := q.components[1].columns[q.table.id]
	q.columnPtrB = columnB.pointer
	q.itemSizeB = columnB.itemSize
	columnC := q.components[2].columns[q.table.id]
	q.columnPtrC = columnC.pointer
	q.itemSizeC = columnC.itemSize
	columnD := q.components[3].columns[q.table.id]
	q.columnPtrD = columnD.pointer
	q.itemSizeD = columnD.itemSize
	columnE := q.components[4].columns[q.table.id]
	q.columnPtrE = columnE.pointer
	q.itemSizeE = columnE.itemSize
	columnF := q.components[5].columns[q.table.id]
	q.columnPtrF = columnF.pointer
	q.itemSizeF = columnF.itemSize
	columnG := q.components[6].columns[q.table.id]
	q.columnPtrG = columnG.pointer
	q.itemSizeG = columnG.itemSize
	q.cursor.index = 0
	q.cursor.maxIndex = int64(q.table.len - 1)
}

// Query8 is a query for 8 components.
// Use a [Filter8] to create one.
//
// Queries are one-time use iterators and must be re-created each time before iterating.
//
// See [Query2] for a usage example.
type Query8[A any, B any, C any, D any, E any, F any, G any, H any] struct {
	world      *World
	filter     *filter
	table      *table
	cache      *cacheEntry
	columnPtrA unsafe.Pointer
	itemSizeA  uintptr
	columnPtrB unsafe.Pointer
	itemSizeB  uintptr
	columnPtrC unsafe.Pointer
	itemSizeC  uintptr
	columnPtrD unsafe.Pointer
	itemSizeD  uintptr
	columnPtrE unsafe.Pointer
	itemSizeE  uintptr
	columnPtrF unsafe.Pointer
	itemSizeF  uintptr
	columnPtrG unsafe.Pointer
	itemSizeG  uintptr
	columnPtrH unsafe.Pointer
	itemSizeH  uintptr
	relations  []relationID
	tables     []tableID
	components []*componentStorage
	cursor     cursor
	lock       uint8
	rareComp   uint8
}

// GetRelation returns the entity relation target of the component at the given index.
func (q *Query8[A, B, C, D, E, F, G, H]) GetRelation(index int) Entity {
	return q.components[index].columns[q.table.id].target
}

// Count counts the entities matching this query.
//
// Has some overhead of iterating through archetypes.
// However, this is still much faster than manual counting via iteration.
//
// Does not iterate or close the query.
//
// See [Query2.Count] for an example.
func (q *Query8[A, B, C, D, E, F, G, H]) Count() int {
	if q.cache == nil {
		return countQuery(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp])
	}
	return countQueryCache(&q.world.storage, q.cache, q.relations)
}

// EntityAt returns the entity at a given index.
//
// The method is particularly useful for random sampling of entities from a query.
// However, performance depends on the number of archetypes in the world and in the query.
// In worlds with many archetypes, it is recommended to use a registered/cached filter.
//
// Do not use this to iterate a query! Use [Query8.Next] instead.
//
// Panics if the index is out of range, as indicated by [Query8.Count].
//
// See [Query2.EntityAt] for an example.
func (q *Query8[A, B, C, D, E, F, G, H]) EntityAt(index int) Entity {
	if q.cache == nil {
		return entityAt(&q.world.storage, q.filter, q.relations, q.world.storage.componentIndex[q.rareComp], uint32(index))
	}
	return entityAtCache(&q.world.storage, q.cache, q.relations, uint32(index))
}

// Close closes the Query and unlocks the world.
//
// Automatically called when iteration completes.
// Needs to be called only if breaking out of the query iteration or not iterating at all.
func (q *Query8[A, B, C, D, E, F, G, H]) Close() {
	q.cursor.archetype = -2
	q.cursor.table = -2
	q.tables = nil
	q.table = nil
	q.cache = nil
	q.columnPtrA = unsafe.Pointer(nilDummy)
	q.itemSizeA = 0
	q.columnPtrB = unsafe.Pointer(nilDummy)
	q.itemSizeB = 0
	q.columnPtrC = unsafe.Pointer(nilDummy)
	q.itemSizeC = 0
	q.columnPtrD = unsafe.Pointer(nilDummy)
	q.itemSizeD = 0
	q.columnPtrE = unsafe.Pointer(nilDummy)
	q.itemSizeE = 0
	q.columnPtrF = unsafe.Pointer(nilDummy)
	q.itemSizeF = 0
	q.columnPtrG = unsafe.Pointer(nilDummy)
	q.itemSizeG = 0
	q.columnPtrH = unsafe.Pointer(nilDummy)
	q.itemSizeH = 0
	q.world.unlockSafe(q.lock)
}

// IsClosed reports whether the query was closed.
//
// A query is considered closed after iteration finishes or Close()
// is called manually. Internally, this is represented by the cursor's
// table index being set to a value less than -1.
//
// Closed queries cannot be iterated and should not be reused.
// Create a new query instead.
func (q *Query8[A, B, C, D, E, F, G, H]) IsClosed() bool {
	return q.cursor.table < -1
}

func (q *Query8[A, B, C, D, E, F, G, H]) nextTableOrArchetype() bool {
	if q.cache != nil {
		return q.nextTable(q.cache.tables.tables)
	}
	if q.cursor.archetype >= 0 && q.nextTable(q.tables) {
		return true
	}
	return q.nextArchetype()
}

func (q *Query8[A, B, C, D, E, F, G, H]) nextArchetype() bool {
	q.tables = nil
	archetypes := q.world.storage.componentIndex[q.rareComp]
	maxArchIndex := int32(len(archetypes) - 1)
	for q.cursor.archetype < maxArchIndex {
		q.cursor.archetype++
		archetype := &q.world.storage.archetypes[archetypes[q.cursor.archetype]]

		if !q.filter.matches(&archetype.mask) {
			continue
		}

		if !archetype.HasRelations() {
			table := &q.world.storage.tables[archetype.tables.tables[0]]
			if table.len > 0 {
				q.setTable(0, table)
				return true
			}
			continue
		}

		q.tables = archetype.GetTables(q.relations)
		q.cursor.table = -1
		if q.nextTable(q.tables) {
			return true
		}
	}
	q.Close()
	return false
}

func (q *Query8[A, B, C, D, E, F, G, H]) nextTable(tables []tableID) bool {
	maxTableIndex := int32(len(tables) - 1)
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		table := &q.world.storage.tables[tables[q.cursor.table]]
		if table.len == 0 || !table.Matches(q.relations) {
			continue
		}
		q.setTable(q.cursor.table, table)
		return true
	}
	if q.cache != nil {
		q.Close()
	}
	return false
}

func (q *Query8[A, B, C, D, E, F, G, H]) setTable(index int32, table *table) {
	q.cursor.table = index
	q.table = table
	columnA := q.components[0].columns[q.table.id]
	q.columnPtrA = columnA.pointer
	q.itemSizeA = columnA.itemSize
	columnB := q.components[1].columns[q.table.id]
	q.columnPtrB = columnB.pointer
	q.itemSizeB = columnB.itemSize
	columnC := q.components[2].columns[q.table.id]
	q.columnPtrC = columnC.pointer
	q.itemSizeC = columnC.itemSize
	columnD := q.components[3].columns[q.table.id]
	q.columnPtrD = columnD.pointer
	q.itemSizeD = columnD.itemSize
	columnE := q.components[4].columns[q.table.id]
	q.columnPtrE = columnE.pointer
	q.itemSizeE = columnE.itemSize
	columnF := q.components[5].columns[q.table.id]
	q.columnPtrF = columnF.pointer
	q.itemSizeF = columnF.itemSize
	columnG := q.components[6].columns[q.table.id]
	q.columnPtrG = columnG.pointer
	q.itemSizeG = columnG.itemSize
	columnH := q.components[7].columns[q.table.id]
	q.columnPtrH = columnH.pointer
	q.itemSizeH = columnH.itemSize
	q.cursor.index = 0
	q.cursor.maxIndex = int64(q.table.len - 1)
}
