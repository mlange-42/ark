package ecs

// Code generated by go generate; DO NOT EDIT.

import "unsafe"

// Map1 is a mapper to access 1 components of an entity.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Map2] for a usage example.
type Map1[A any] struct {
	world     *World
	ids       []ID
	storageA  *componentStorage
	relations []RelationID
}

// NewMap1 creates a new [Map1].
func NewMap1[A any](world *World) Map1[A] {
	ids := []ID{
		ComponentID[A](world),
	}
	return Map1[A]{
		world:    world,
		ids:      ids,
		storageA: &world.storage.components[ids[0].id],
	}
}

// NewEntity creates a new entity with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map1[A]) NewEntity(a *A, rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	return m.world.newEntityWith(m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
	}, m.relations)
}

// NewEntityFn creates a new entity with the mapped component and runs a callback instead of using a component for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map1[A]) NewEntityFn(fn func(a *A), rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	entity := m.world.newEntityWith(m.ids, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
		)
	}
	return entity
}

// NewBatch creates a batch of new entities with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map1[A]) NewBatch(count int, a *A, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.newEntitiesWith(count, m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
	}, m.relations)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map1[A]) NewBatchFn(count int, fn func(entity Entity, a *A), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)
	if fn == nil {
		return
	}

	table := &m.world.storage.tables[tableID]
	columnA := m.storageA.columns[tableID]

	lock := m.world.lock()
	for i := range count {
		index := uintptr(start + i)
		fn(
			table.GetEntity(index),
			(*A)(columnA.Get(index)),
		)
	}
	m.world.unlock(lock)
}

// Get returns the mapped components for the given entity.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map1[A]) Get(entity Entity) *A {
	if !m.world.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)

	var a *A

	columnA := m.storageA.columns[index.table]
	if columnA != nil {
		a = (*A)(columnA.Get(row))
	}
	return a
}

// GetUnchecked returns the mapped components for the given entity.
// In contrast to [Map1.Get], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map1[A]) GetUnchecked(entity Entity) *A {
	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)

	var a *A

	columnA := m.storageA.columns[index.table]
	if columnA != nil {
		a = (*A)(columnA.Get(row))
	}
	return a
}

// HasAll return whether the given entity has all mapped components.
//
// Using [Map1.Get] and checking for nil pointer may be faster
// than calling [Map1.HasAll] and [Map1.Get] subsequently.
func (m *Map1[A]) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	index := m.world.storage.entities[entity.id]
	return m.storageA.columns[index.table] != nil
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map1[A]) Add(entity Entity, a *A, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchange(entity, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
	}, m.relations)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map1[A]) AddFn(entity Entity, fn func(a *A), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchange(entity, m.ids, nil, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
		)
	}
}

// Set the mapped components of the given entity to the given values.
//
// Requires the entity to already have all the mapped components.
// This is not a component operation, so it can be performed on a locked world.
func (m *Map1[A]) Set(entity Entity, a *A) {
	if !m.world.Alive(entity) {
		panic("can't set components of a dead entity")
	}
	m.world.storage.checkHasComponent(entity, m.ids[0])

	index := &m.world.storage.entities[entity.id]
	m.storageA.columns[index.table].Set(index.row, unsafe.Pointer(a))
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map1[A]) AddBatch(batch *Batch, a *A, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchangeBatch(batch, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
	}, m.relations, nil)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map1[A]) AddBatchFn(batch *Batch, fn func(entity Entity, a *A), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]
			columnA := m.storageA.columns[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
				)
			}
			m.world.unlock(lock)
		}
	}
	m.world.exchangeBatch(batch, m.ids, nil, nil, m.relations, process)
}

// Remove the mapped components from the given entity.
func (m *Map1[A]) Remove(entity Entity) {
	m.world.exchange(entity, nil, m.ids, nil, nil)
}

// RemoveBatch removes the mapped components from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map1[A]) RemoveBatch(batch *Batch, fn func(entity Entity)) {
	removeBatch(m.world, batch, m.ids, fn)
}

// GetRelation returns the relation target of an entity for the component at the given index.
func (m *Map1[A]) GetRelation(entity Entity, index int) Entity {
	if !m.world.Alive(entity) {
		panic("can't get entity relation target for a dead entity")
	}
	return m.GetRelationUnchecked(entity, index)
}

// GetRelationUnchecked returns the relation target of an entity for the component at the given index.
// In contrast to [Map1.GetRelation], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map1[A]) GetRelationUnchecked(entity Entity, index int) Entity {
	return m.world.storage.getRelation(entity, m.ids[index])
}

// SetRelations sets relation targets for the given entity.
func (m *Map1[A]) SetRelations(entity Entity, rel ...Relation) {
	// alive check is done in World.setRelations
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.setRelations(entity, m.relations)
}

// SetRelationsBatch sets relation targets for all entities matching the given batch filter.
func (m *Map1[A]) SetRelationsBatch(batch *Batch, fn func(entity Entity), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	setRelationsBatch(m.world, batch, fn, m.relations)
}

// Map2 is a mapper to access 2 components of an entity.
//
// Instances should be created during initialization and stored, e.g. in systems.
type Map2[A any, B any] struct {
	world     *World
	ids       []ID
	storageA  *componentStorage
	storageB  *componentStorage
	relations []RelationID
}

// NewMap2 creates a new [Map2].
func NewMap2[A any, B any](world *World) Map2[A, B] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
	}
	return Map2[A, B]{
		world:    world,
		ids:      ids,
		storageA: &world.storage.components[ids[0].id],
		storageB: &world.storage.components[ids[1].id],
	}
}

// NewEntity creates a new entity with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map2[A, B]) NewEntity(a *A, b *B, rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	return m.world.newEntityWith(m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
	}, m.relations)
}

// NewEntityFn creates a new entity with the mapped component and runs a callback instead of using a component for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map2[A, B]) NewEntityFn(fn func(a *A, b *B), rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	entity := m.world.newEntityWith(m.ids, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
		)
	}
	return entity
}

// NewBatch creates a batch of new entities with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map2[A, B]) NewBatch(count int, a *A, b *B, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.newEntitiesWith(count, m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
	}, m.relations)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map2[A, B]) NewBatchFn(count int, fn func(entity Entity, a *A, b *B), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)
	if fn == nil {
		return
	}

	table := &m.world.storage.tables[tableID]
	columnA := m.storageA.columns[tableID]
	columnB := m.storageB.columns[tableID]

	lock := m.world.lock()
	for i := range count {
		index := uintptr(start + i)
		fn(
			table.GetEntity(index),
			(*A)(columnA.Get(index)),
			(*B)(columnB.Get(index)),
		)
	}
	m.world.unlock(lock)
}

// Get returns the mapped components for the given entity.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map2[A, B]) Get(entity Entity) (*A, *B) {
	if !m.world.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)

	var a *A
	var b *B

	columnA := m.storageA.columns[index.table]
	if columnA != nil {
		a = (*A)(columnA.Get(row))
	}
	columnB := m.storageB.columns[index.table]
	if columnB != nil {
		b = (*B)(columnB.Get(row))
	}
	return a, b
}

// GetUnchecked returns the mapped components for the given entity.
// In contrast to [Map2.Get], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map2[A, B]) GetUnchecked(entity Entity) (*A, *B) {
	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)

	var a *A
	var b *B

	columnA := m.storageA.columns[index.table]
	if columnA != nil {
		a = (*A)(columnA.Get(row))
	}
	columnB := m.storageB.columns[index.table]
	if columnB != nil {
		b = (*B)(columnB.Get(row))
	}
	return a, b
}

// HasAll return whether the given entity has all mapped components.
//
// Using [Map2.Get] and checking for nil pointer may be faster
// than calling [Map2.HasAll] and [Map2.Get] subsequently.
func (m *Map2[A, B]) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	index := m.world.storage.entities[entity.id]
	return m.storageA.columns[index.table] != nil &&
		m.storageB.columns[index.table] != nil
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map2[A, B]) Add(entity Entity, a *A, b *B, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchange(entity, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
	}, m.relations)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map2[A, B]) AddFn(entity Entity, fn func(a *A, b *B), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchange(entity, m.ids, nil, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
		)
	}
}

// Set the mapped components of the given entity to the given values.
//
// Requires the entity to already have all the mapped components.
// This is not a component operation, so it can be performed on a locked world.
func (m *Map2[A, B]) Set(entity Entity, a *A, b *B) {
	if !m.world.Alive(entity) {
		panic("can't set components of a dead entity")
	}
	m.world.storage.checkHasComponent(entity, m.ids[0])
	m.world.storage.checkHasComponent(entity, m.ids[1])

	index := &m.world.storage.entities[entity.id]
	m.storageA.columns[index.table].Set(index.row, unsafe.Pointer(a))
	m.storageB.columns[index.table].Set(index.row, unsafe.Pointer(b))
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map2[A, B]) AddBatch(batch *Batch, a *A, b *B, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchangeBatch(batch, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
	}, m.relations, nil)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map2[A, B]) AddBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]
			columnA := m.storageA.columns[tableID]
			columnB := m.storageB.columns[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
				)
			}
			m.world.unlock(lock)
		}
	}
	m.world.exchangeBatch(batch, m.ids, nil, nil, m.relations, process)
}

// Remove the mapped components from the given entity.
func (m *Map2[A, B]) Remove(entity Entity) {
	m.world.exchange(entity, nil, m.ids, nil, nil)
}

// RemoveBatch removes the mapped components from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map2[A, B]) RemoveBatch(batch *Batch, fn func(entity Entity)) {
	removeBatch(m.world, batch, m.ids, fn)
}

// GetRelation returns the relation target of an entity for the component at the given index.
func (m *Map2[A, B]) GetRelation(entity Entity, index int) Entity {
	if !m.world.Alive(entity) {
		panic("can't get entity relation target for a dead entity")
	}
	return m.GetRelationUnchecked(entity, index)
}

// GetRelationUnchecked returns the relation target of an entity for the component at the given index.
// In contrast to [Map2.GetRelation], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map2[A, B]) GetRelationUnchecked(entity Entity, index int) Entity {
	return m.world.storage.getRelation(entity, m.ids[index])
}

// SetRelations sets relation targets for the given entity.
func (m *Map2[A, B]) SetRelations(entity Entity, rel ...Relation) {
	// alive check is done in World.setRelations
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.setRelations(entity, m.relations)
}

// SetRelationsBatch sets relation targets for all entities matching the given batch filter.
func (m *Map2[A, B]) SetRelationsBatch(batch *Batch, fn func(entity Entity), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	setRelationsBatch(m.world, batch, fn, m.relations)
}

// Map3 is a mapper to access 3 components of an entity.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Map2] for a usage example.
type Map3[A any, B any, C any] struct {
	world     *World
	ids       []ID
	storageA  *componentStorage
	storageB  *componentStorage
	storageC  *componentStorage
	relations []RelationID
}

// NewMap3 creates a new [Map3].
func NewMap3[A any, B any, C any](world *World) Map3[A, B, C] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
	}
	return Map3[A, B, C]{
		world:    world,
		ids:      ids,
		storageA: &world.storage.components[ids[0].id],
		storageB: &world.storage.components[ids[1].id],
		storageC: &world.storage.components[ids[2].id],
	}
}

// NewEntity creates a new entity with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map3[A, B, C]) NewEntity(a *A, b *B, c *C, rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	return m.world.newEntityWith(m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
	}, m.relations)
}

// NewEntityFn creates a new entity with the mapped component and runs a callback instead of using a component for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map3[A, B, C]) NewEntityFn(fn func(a *A, b *B, c *C), rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	entity := m.world.newEntityWith(m.ids, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
		)
	}
	return entity
}

// NewBatch creates a batch of new entities with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map3[A, B, C]) NewBatch(count int, a *A, b *B, c *C, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.newEntitiesWith(count, m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
	}, m.relations)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map3[A, B, C]) NewBatchFn(count int, fn func(entity Entity, a *A, b *B, c *C), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)
	if fn == nil {
		return
	}

	table := &m.world.storage.tables[tableID]
	columnA := m.storageA.columns[tableID]
	columnB := m.storageB.columns[tableID]
	columnC := m.storageC.columns[tableID]

	lock := m.world.lock()
	for i := range count {
		index := uintptr(start + i)
		fn(
			table.GetEntity(index),
			(*A)(columnA.Get(index)),
			(*B)(columnB.Get(index)),
			(*C)(columnC.Get(index)),
		)
	}
	m.world.unlock(lock)
}

// Get returns the mapped components for the given entity.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map3[A, B, C]) Get(entity Entity) (*A, *B, *C) {
	if !m.world.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)

	var a *A
	var b *B
	var c *C

	columnA := m.storageA.columns[index.table]
	if columnA != nil {
		a = (*A)(columnA.Get(row))
	}
	columnB := m.storageB.columns[index.table]
	if columnB != nil {
		b = (*B)(columnB.Get(row))
	}
	columnC := m.storageC.columns[index.table]
	if columnC != nil {
		c = (*C)(columnC.Get(row))
	}
	return a, b, c
}

// GetUnchecked returns the mapped components for the given entity.
// In contrast to [Map3.Get], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map3[A, B, C]) GetUnchecked(entity Entity) (*A, *B, *C) {
	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)

	var a *A
	var b *B
	var c *C

	columnA := m.storageA.columns[index.table]
	if columnA != nil {
		a = (*A)(columnA.Get(row))
	}
	columnB := m.storageB.columns[index.table]
	if columnB != nil {
		b = (*B)(columnB.Get(row))
	}
	columnC := m.storageC.columns[index.table]
	if columnC != nil {
		c = (*C)(columnC.Get(row))
	}
	return a, b, c
}

// HasAll return whether the given entity has all mapped components.
//
// Using [Map3.Get] and checking for nil pointer may be faster
// than calling [Map3.HasAll] and [Map3.Get] subsequently.
func (m *Map3[A, B, C]) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	index := m.world.storage.entities[entity.id]
	return m.storageA.columns[index.table] != nil &&
		m.storageB.columns[index.table] != nil &&
		m.storageC.columns[index.table] != nil
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map3[A, B, C]) Add(entity Entity, a *A, b *B, c *C, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchange(entity, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
	}, m.relations)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map3[A, B, C]) AddFn(entity Entity, fn func(a *A, b *B, c *C), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchange(entity, m.ids, nil, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
		)
	}
}

// Set the mapped components of the given entity to the given values.
//
// Requires the entity to already have all the mapped components.
// This is not a component operation, so it can be performed on a locked world.
func (m *Map3[A, B, C]) Set(entity Entity, a *A, b *B, c *C) {
	if !m.world.Alive(entity) {
		panic("can't set components of a dead entity")
	}
	m.world.storage.checkHasComponent(entity, m.ids[0])
	m.world.storage.checkHasComponent(entity, m.ids[1])
	m.world.storage.checkHasComponent(entity, m.ids[2])

	index := &m.world.storage.entities[entity.id]
	m.storageA.columns[index.table].Set(index.row, unsafe.Pointer(a))
	m.storageB.columns[index.table].Set(index.row, unsafe.Pointer(b))
	m.storageC.columns[index.table].Set(index.row, unsafe.Pointer(c))
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map3[A, B, C]) AddBatch(batch *Batch, a *A, b *B, c *C, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchangeBatch(batch, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
	}, m.relations, nil)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map3[A, B, C]) AddBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]
			columnA := m.storageA.columns[tableID]
			columnB := m.storageB.columns[tableID]
			columnC := m.storageC.columns[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
				)
			}
			m.world.unlock(lock)
		}
	}
	m.world.exchangeBatch(batch, m.ids, nil, nil, m.relations, process)
}

// Remove the mapped components from the given entity.
func (m *Map3[A, B, C]) Remove(entity Entity) {
	m.world.exchange(entity, nil, m.ids, nil, nil)
}

// RemoveBatch removes the mapped components from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map3[A, B, C]) RemoveBatch(batch *Batch, fn func(entity Entity)) {
	removeBatch(m.world, batch, m.ids, fn)
}

// GetRelation returns the relation target of an entity for the component at the given index.
func (m *Map3[A, B, C]) GetRelation(entity Entity, index int) Entity {
	if !m.world.Alive(entity) {
		panic("can't get entity relation target for a dead entity")
	}
	return m.GetRelationUnchecked(entity, index)
}

// GetRelationUnchecked returns the relation target of an entity for the component at the given index.
// In contrast to [Map3.GetRelation], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map3[A, B, C]) GetRelationUnchecked(entity Entity, index int) Entity {
	return m.world.storage.getRelation(entity, m.ids[index])
}

// SetRelations sets relation targets for the given entity.
func (m *Map3[A, B, C]) SetRelations(entity Entity, rel ...Relation) {
	// alive check is done in World.setRelations
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.setRelations(entity, m.relations)
}

// SetRelationsBatch sets relation targets for all entities matching the given batch filter.
func (m *Map3[A, B, C]) SetRelationsBatch(batch *Batch, fn func(entity Entity), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	setRelationsBatch(m.world, batch, fn, m.relations)
}

// Map4 is a mapper to access 4 components of an entity.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Map2] for a usage example.
type Map4[A any, B any, C any, D any] struct {
	world     *World
	ids       []ID
	storageA  *componentStorage
	storageB  *componentStorage
	storageC  *componentStorage
	storageD  *componentStorage
	relations []RelationID
}

// NewMap4 creates a new [Map4].
func NewMap4[A any, B any, C any, D any](world *World) Map4[A, B, C, D] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
	}
	return Map4[A, B, C, D]{
		world:    world,
		ids:      ids,
		storageA: &world.storage.components[ids[0].id],
		storageB: &world.storage.components[ids[1].id],
		storageC: &world.storage.components[ids[2].id],
		storageD: &world.storage.components[ids[3].id],
	}
}

// NewEntity creates a new entity with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map4[A, B, C, D]) NewEntity(a *A, b *B, c *C, d *D, rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	return m.world.newEntityWith(m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
	}, m.relations)
}

// NewEntityFn creates a new entity with the mapped component and runs a callback instead of using a component for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map4[A, B, C, D]) NewEntityFn(fn func(a *A, b *B, c *C, d *D), rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	entity := m.world.newEntityWith(m.ids, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
		)
	}
	return entity
}

// NewBatch creates a batch of new entities with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map4[A, B, C, D]) NewBatch(count int, a *A, b *B, c *C, d *D, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.newEntitiesWith(count, m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
	}, m.relations)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map4[A, B, C, D]) NewBatchFn(count int, fn func(entity Entity, a *A, b *B, c *C, d *D), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)
	if fn == nil {
		return
	}

	table := &m.world.storage.tables[tableID]
	columnA := m.storageA.columns[tableID]
	columnB := m.storageB.columns[tableID]
	columnC := m.storageC.columns[tableID]
	columnD := m.storageD.columns[tableID]

	lock := m.world.lock()
	for i := range count {
		index := uintptr(start + i)
		fn(
			table.GetEntity(index),
			(*A)(columnA.Get(index)),
			(*B)(columnB.Get(index)),
			(*C)(columnC.Get(index)),
			(*D)(columnD.Get(index)),
		)
	}
	m.world.unlock(lock)
}

// Get returns the mapped components for the given entity.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map4[A, B, C, D]) Get(entity Entity) (*A, *B, *C, *D) {
	if !m.world.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)

	var a *A
	var b *B
	var c *C
	var d *D

	columnA := m.storageA.columns[index.table]
	if columnA != nil {
		a = (*A)(columnA.Get(row))
	}
	columnB := m.storageB.columns[index.table]
	if columnB != nil {
		b = (*B)(columnB.Get(row))
	}
	columnC := m.storageC.columns[index.table]
	if columnC != nil {
		c = (*C)(columnC.Get(row))
	}
	columnD := m.storageD.columns[index.table]
	if columnD != nil {
		d = (*D)(columnD.Get(row))
	}
	return a, b, c, d
}

// GetUnchecked returns the mapped components for the given entity.
// In contrast to [Map4.Get], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map4[A, B, C, D]) GetUnchecked(entity Entity) (*A, *B, *C, *D) {
	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)

	var a *A
	var b *B
	var c *C
	var d *D

	columnA := m.storageA.columns[index.table]
	if columnA != nil {
		a = (*A)(columnA.Get(row))
	}
	columnB := m.storageB.columns[index.table]
	if columnB != nil {
		b = (*B)(columnB.Get(row))
	}
	columnC := m.storageC.columns[index.table]
	if columnC != nil {
		c = (*C)(columnC.Get(row))
	}
	columnD := m.storageD.columns[index.table]
	if columnD != nil {
		d = (*D)(columnD.Get(row))
	}
	return a, b, c, d
}

// HasAll return whether the given entity has all mapped components.
//
// Using [Map4.Get] and checking for nil pointer may be faster
// than calling [Map4.HasAll] and [Map4.Get] subsequently.
func (m *Map4[A, B, C, D]) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	index := m.world.storage.entities[entity.id]
	return m.storageA.columns[index.table] != nil &&
		m.storageB.columns[index.table] != nil &&
		m.storageC.columns[index.table] != nil &&
		m.storageD.columns[index.table] != nil
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map4[A, B, C, D]) Add(entity Entity, a *A, b *B, c *C, d *D, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchange(entity, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
	}, m.relations)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map4[A, B, C, D]) AddFn(entity Entity, fn func(a *A, b *B, c *C, d *D), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchange(entity, m.ids, nil, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
		)
	}
}

// Set the mapped components of the given entity to the given values.
//
// Requires the entity to already have all the mapped components.
// This is not a component operation, so it can be performed on a locked world.
func (m *Map4[A, B, C, D]) Set(entity Entity, a *A, b *B, c *C, d *D) {
	if !m.world.Alive(entity) {
		panic("can't set components of a dead entity")
	}
	m.world.storage.checkHasComponent(entity, m.ids[0])
	m.world.storage.checkHasComponent(entity, m.ids[1])
	m.world.storage.checkHasComponent(entity, m.ids[2])
	m.world.storage.checkHasComponent(entity, m.ids[3])

	index := &m.world.storage.entities[entity.id]
	m.storageA.columns[index.table].Set(index.row, unsafe.Pointer(a))
	m.storageB.columns[index.table].Set(index.row, unsafe.Pointer(b))
	m.storageC.columns[index.table].Set(index.row, unsafe.Pointer(c))
	m.storageD.columns[index.table].Set(index.row, unsafe.Pointer(d))
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map4[A, B, C, D]) AddBatch(batch *Batch, a *A, b *B, c *C, d *D, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchangeBatch(batch, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
	}, m.relations, nil)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map4[A, B, C, D]) AddBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C, d *D), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]
			columnA := m.storageA.columns[tableID]
			columnB := m.storageB.columns[tableID]
			columnC := m.storageC.columns[tableID]
			columnD := m.storageD.columns[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
					(*D)(columnD.Get(index)),
				)
			}
			m.world.unlock(lock)
		}
	}
	m.world.exchangeBatch(batch, m.ids, nil, nil, m.relations, process)
}

// Remove the mapped components from the given entity.
func (m *Map4[A, B, C, D]) Remove(entity Entity) {
	m.world.exchange(entity, nil, m.ids, nil, nil)
}

// RemoveBatch removes the mapped components from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map4[A, B, C, D]) RemoveBatch(batch *Batch, fn func(entity Entity)) {
	removeBatch(m.world, batch, m.ids, fn)
}

// GetRelation returns the relation target of an entity for the component at the given index.
func (m *Map4[A, B, C, D]) GetRelation(entity Entity, index int) Entity {
	if !m.world.Alive(entity) {
		panic("can't get entity relation target for a dead entity")
	}
	return m.GetRelationUnchecked(entity, index)
}

// GetRelationUnchecked returns the relation target of an entity for the component at the given index.
// In contrast to [Map4.GetRelation], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map4[A, B, C, D]) GetRelationUnchecked(entity Entity, index int) Entity {
	return m.world.storage.getRelation(entity, m.ids[index])
}

// SetRelations sets relation targets for the given entity.
func (m *Map4[A, B, C, D]) SetRelations(entity Entity, rel ...Relation) {
	// alive check is done in World.setRelations
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.setRelations(entity, m.relations)
}

// SetRelationsBatch sets relation targets for all entities matching the given batch filter.
func (m *Map4[A, B, C, D]) SetRelationsBatch(batch *Batch, fn func(entity Entity), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	setRelationsBatch(m.world, batch, fn, m.relations)
}

// Map5 is a mapper to access 5 components of an entity.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Map2] for a usage example.
type Map5[A any, B any, C any, D any, E any] struct {
	world     *World
	ids       []ID
	storageA  *componentStorage
	storageB  *componentStorage
	storageC  *componentStorage
	storageD  *componentStorage
	storageE  *componentStorage
	relations []RelationID
}

// NewMap5 creates a new [Map5].
func NewMap5[A any, B any, C any, D any, E any](world *World) Map5[A, B, C, D, E] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
	}
	return Map5[A, B, C, D, E]{
		world:    world,
		ids:      ids,
		storageA: &world.storage.components[ids[0].id],
		storageB: &world.storage.components[ids[1].id],
		storageC: &world.storage.components[ids[2].id],
		storageD: &world.storage.components[ids[3].id],
		storageE: &world.storage.components[ids[4].id],
	}
}

// NewEntity creates a new entity with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map5[A, B, C, D, E]) NewEntity(a *A, b *B, c *C, d *D, e *E, rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	return m.world.newEntityWith(m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
	}, m.relations)
}

// NewEntityFn creates a new entity with the mapped component and runs a callback instead of using a component for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map5[A, B, C, D, E]) NewEntityFn(fn func(a *A, b *B, c *C, d *D, e *E), rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	entity := m.world.newEntityWith(m.ids, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
		)
	}
	return entity
}

// NewBatch creates a batch of new entities with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map5[A, B, C, D, E]) NewBatch(count int, a *A, b *B, c *C, d *D, e *E, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.newEntitiesWith(count, m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
	}, m.relations)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map5[A, B, C, D, E]) NewBatchFn(count int, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)
	if fn == nil {
		return
	}

	table := &m.world.storage.tables[tableID]
	columnA := m.storageA.columns[tableID]
	columnB := m.storageB.columns[tableID]
	columnC := m.storageC.columns[tableID]
	columnD := m.storageD.columns[tableID]
	columnE := m.storageE.columns[tableID]

	lock := m.world.lock()
	for i := range count {
		index := uintptr(start + i)
		fn(
			table.GetEntity(index),
			(*A)(columnA.Get(index)),
			(*B)(columnB.Get(index)),
			(*C)(columnC.Get(index)),
			(*D)(columnD.Get(index)),
			(*E)(columnE.Get(index)),
		)
	}
	m.world.unlock(lock)
}

// Get returns the mapped components for the given entity.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map5[A, B, C, D, E]) Get(entity Entity) (*A, *B, *C, *D, *E) {
	if !m.world.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)

	var a *A
	var b *B
	var c *C
	var d *D
	var e *E

	columnA := m.storageA.columns[index.table]
	if columnA != nil {
		a = (*A)(columnA.Get(row))
	}
	columnB := m.storageB.columns[index.table]
	if columnB != nil {
		b = (*B)(columnB.Get(row))
	}
	columnC := m.storageC.columns[index.table]
	if columnC != nil {
		c = (*C)(columnC.Get(row))
	}
	columnD := m.storageD.columns[index.table]
	if columnD != nil {
		d = (*D)(columnD.Get(row))
	}
	columnE := m.storageE.columns[index.table]
	if columnE != nil {
		e = (*E)(columnE.Get(row))
	}
	return a, b, c, d, e
}

// GetUnchecked returns the mapped components for the given entity.
// In contrast to [Map5.Get], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map5[A, B, C, D, E]) GetUnchecked(entity Entity) (*A, *B, *C, *D, *E) {
	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)

	var a *A
	var b *B
	var c *C
	var d *D
	var e *E

	columnA := m.storageA.columns[index.table]
	if columnA != nil {
		a = (*A)(columnA.Get(row))
	}
	columnB := m.storageB.columns[index.table]
	if columnB != nil {
		b = (*B)(columnB.Get(row))
	}
	columnC := m.storageC.columns[index.table]
	if columnC != nil {
		c = (*C)(columnC.Get(row))
	}
	columnD := m.storageD.columns[index.table]
	if columnD != nil {
		d = (*D)(columnD.Get(row))
	}
	columnE := m.storageE.columns[index.table]
	if columnE != nil {
		e = (*E)(columnE.Get(row))
	}
	return a, b, c, d, e
}

// HasAll return whether the given entity has all mapped components.
//
// Using [Map5.Get] and checking for nil pointer may be faster
// than calling [Map5.HasAll] and [Map5.Get] subsequently.
func (m *Map5[A, B, C, D, E]) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	index := m.world.storage.entities[entity.id]
	return m.storageA.columns[index.table] != nil &&
		m.storageB.columns[index.table] != nil &&
		m.storageC.columns[index.table] != nil &&
		m.storageD.columns[index.table] != nil &&
		m.storageE.columns[index.table] != nil
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map5[A, B, C, D, E]) Add(entity Entity, a *A, b *B, c *C, d *D, e *E, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchange(entity, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
	}, m.relations)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map5[A, B, C, D, E]) AddFn(entity Entity, fn func(a *A, b *B, c *C, d *D, e *E), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchange(entity, m.ids, nil, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
		)
	}
}

// Set the mapped components of the given entity to the given values.
//
// Requires the entity to already have all the mapped components.
// This is not a component operation, so it can be performed on a locked world.
func (m *Map5[A, B, C, D, E]) Set(entity Entity, a *A, b *B, c *C, d *D, e *E) {
	if !m.world.Alive(entity) {
		panic("can't set components of a dead entity")
	}
	m.world.storage.checkHasComponent(entity, m.ids[0])
	m.world.storage.checkHasComponent(entity, m.ids[1])
	m.world.storage.checkHasComponent(entity, m.ids[2])
	m.world.storage.checkHasComponent(entity, m.ids[3])
	m.world.storage.checkHasComponent(entity, m.ids[4])

	index := &m.world.storage.entities[entity.id]
	m.storageA.columns[index.table].Set(index.row, unsafe.Pointer(a))
	m.storageB.columns[index.table].Set(index.row, unsafe.Pointer(b))
	m.storageC.columns[index.table].Set(index.row, unsafe.Pointer(c))
	m.storageD.columns[index.table].Set(index.row, unsafe.Pointer(d))
	m.storageE.columns[index.table].Set(index.row, unsafe.Pointer(e))
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map5[A, B, C, D, E]) AddBatch(batch *Batch, a *A, b *B, c *C, d *D, e *E, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchangeBatch(batch, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
	}, m.relations, nil)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map5[A, B, C, D, E]) AddBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]
			columnA := m.storageA.columns[tableID]
			columnB := m.storageB.columns[tableID]
			columnC := m.storageC.columns[tableID]
			columnD := m.storageD.columns[tableID]
			columnE := m.storageE.columns[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
					(*D)(columnD.Get(index)),
					(*E)(columnE.Get(index)),
				)
			}
			m.world.unlock(lock)
		}
	}
	m.world.exchangeBatch(batch, m.ids, nil, nil, m.relations, process)
}

// Remove the mapped components from the given entity.
func (m *Map5[A, B, C, D, E]) Remove(entity Entity) {
	m.world.exchange(entity, nil, m.ids, nil, nil)
}

// RemoveBatch removes the mapped components from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map5[A, B, C, D, E]) RemoveBatch(batch *Batch, fn func(entity Entity)) {
	removeBatch(m.world, batch, m.ids, fn)
}

// GetRelation returns the relation target of an entity for the component at the given index.
func (m *Map5[A, B, C, D, E]) GetRelation(entity Entity, index int) Entity {
	if !m.world.Alive(entity) {
		panic("can't get entity relation target for a dead entity")
	}
	return m.GetRelationUnchecked(entity, index)
}

// GetRelationUnchecked returns the relation target of an entity for the component at the given index.
// In contrast to [Map5.GetRelation], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map5[A, B, C, D, E]) GetRelationUnchecked(entity Entity, index int) Entity {
	return m.world.storage.getRelation(entity, m.ids[index])
}

// SetRelations sets relation targets for the given entity.
func (m *Map5[A, B, C, D, E]) SetRelations(entity Entity, rel ...Relation) {
	// alive check is done in World.setRelations
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.setRelations(entity, m.relations)
}

// SetRelationsBatch sets relation targets for all entities matching the given batch filter.
func (m *Map5[A, B, C, D, E]) SetRelationsBatch(batch *Batch, fn func(entity Entity), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	setRelationsBatch(m.world, batch, fn, m.relations)
}

// Map6 is a mapper to access 6 components of an entity.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Map2] for a usage example.
type Map6[A any, B any, C any, D any, E any, F any] struct {
	world     *World
	ids       []ID
	storageA  *componentStorage
	storageB  *componentStorage
	storageC  *componentStorage
	storageD  *componentStorage
	storageE  *componentStorage
	storageF  *componentStorage
	relations []RelationID
}

// NewMap6 creates a new [Map6].
func NewMap6[A any, B any, C any, D any, E any, F any](world *World) Map6[A, B, C, D, E, F] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
		ComponentID[F](world),
	}
	return Map6[A, B, C, D, E, F]{
		world:    world,
		ids:      ids,
		storageA: &world.storage.components[ids[0].id],
		storageB: &world.storage.components[ids[1].id],
		storageC: &world.storage.components[ids[2].id],
		storageD: &world.storage.components[ids[3].id],
		storageE: &world.storage.components[ids[4].id],
		storageF: &world.storage.components[ids[5].id],
	}
}

// NewEntity creates a new entity with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map6[A, B, C, D, E, F]) NewEntity(a *A, b *B, c *C, d *D, e *E, f *F, rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	return m.world.newEntityWith(m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
	}, m.relations)
}

// NewEntityFn creates a new entity with the mapped component and runs a callback instead of using a component for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map6[A, B, C, D, E, F]) NewEntityFn(fn func(a *A, b *B, c *C, d *D, e *E, f *F), rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	entity := m.world.newEntityWith(m.ids, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
		)
	}
	return entity
}

// NewBatch creates a batch of new entities with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map6[A, B, C, D, E, F]) NewBatch(count int, a *A, b *B, c *C, d *D, e *E, f *F, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.newEntitiesWith(count, m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
	}, m.relations)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map6[A, B, C, D, E, F]) NewBatchFn(count int, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)
	if fn == nil {
		return
	}

	table := &m.world.storage.tables[tableID]
	columnA := m.storageA.columns[tableID]
	columnB := m.storageB.columns[tableID]
	columnC := m.storageC.columns[tableID]
	columnD := m.storageD.columns[tableID]
	columnE := m.storageE.columns[tableID]
	columnF := m.storageF.columns[tableID]

	lock := m.world.lock()
	for i := range count {
		index := uintptr(start + i)
		fn(
			table.GetEntity(index),
			(*A)(columnA.Get(index)),
			(*B)(columnB.Get(index)),
			(*C)(columnC.Get(index)),
			(*D)(columnD.Get(index)),
			(*E)(columnE.Get(index)),
			(*F)(columnF.Get(index)),
		)
	}
	m.world.unlock(lock)
}

// Get returns the mapped components for the given entity.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map6[A, B, C, D, E, F]) Get(entity Entity) (*A, *B, *C, *D, *E, *F) {
	if !m.world.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)

	var a *A
	var b *B
	var c *C
	var d *D
	var e *E
	var f *F

	columnA := m.storageA.columns[index.table]
	if columnA != nil {
		a = (*A)(columnA.Get(row))
	}
	columnB := m.storageB.columns[index.table]
	if columnB != nil {
		b = (*B)(columnB.Get(row))
	}
	columnC := m.storageC.columns[index.table]
	if columnC != nil {
		c = (*C)(columnC.Get(row))
	}
	columnD := m.storageD.columns[index.table]
	if columnD != nil {
		d = (*D)(columnD.Get(row))
	}
	columnE := m.storageE.columns[index.table]
	if columnE != nil {
		e = (*E)(columnE.Get(row))
	}
	columnF := m.storageF.columns[index.table]
	if columnF != nil {
		f = (*F)(columnF.Get(row))
	}
	return a, b, c, d, e, f
}

// GetUnchecked returns the mapped components for the given entity.
// In contrast to [Map6.Get], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map6[A, B, C, D, E, F]) GetUnchecked(entity Entity) (*A, *B, *C, *D, *E, *F) {
	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)

	var a *A
	var b *B
	var c *C
	var d *D
	var e *E
	var f *F

	columnA := m.storageA.columns[index.table]
	if columnA != nil {
		a = (*A)(columnA.Get(row))
	}
	columnB := m.storageB.columns[index.table]
	if columnB != nil {
		b = (*B)(columnB.Get(row))
	}
	columnC := m.storageC.columns[index.table]
	if columnC != nil {
		c = (*C)(columnC.Get(row))
	}
	columnD := m.storageD.columns[index.table]
	if columnD != nil {
		d = (*D)(columnD.Get(row))
	}
	columnE := m.storageE.columns[index.table]
	if columnE != nil {
		e = (*E)(columnE.Get(row))
	}
	columnF := m.storageF.columns[index.table]
	if columnF != nil {
		f = (*F)(columnF.Get(row))
	}
	return a, b, c, d, e, f
}

// HasAll return whether the given entity has all mapped components.
//
// Using [Map6.Get] and checking for nil pointer may be faster
// than calling [Map6.HasAll] and [Map6.Get] subsequently.
func (m *Map6[A, B, C, D, E, F]) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	index := m.world.storage.entities[entity.id]
	return m.storageA.columns[index.table] != nil &&
		m.storageB.columns[index.table] != nil &&
		m.storageC.columns[index.table] != nil &&
		m.storageD.columns[index.table] != nil &&
		m.storageE.columns[index.table] != nil &&
		m.storageF.columns[index.table] != nil
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map6[A, B, C, D, E, F]) Add(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchange(entity, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
	}, m.relations)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map6[A, B, C, D, E, F]) AddFn(entity Entity, fn func(a *A, b *B, c *C, d *D, e *E, f *F), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchange(entity, m.ids, nil, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
		)
	}
}

// Set the mapped components of the given entity to the given values.
//
// Requires the entity to already have all the mapped components.
// This is not a component operation, so it can be performed on a locked world.
func (m *Map6[A, B, C, D, E, F]) Set(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F) {
	if !m.world.Alive(entity) {
		panic("can't set components of a dead entity")
	}
	m.world.storage.checkHasComponent(entity, m.ids[0])
	m.world.storage.checkHasComponent(entity, m.ids[1])
	m.world.storage.checkHasComponent(entity, m.ids[2])
	m.world.storage.checkHasComponent(entity, m.ids[3])
	m.world.storage.checkHasComponent(entity, m.ids[4])
	m.world.storage.checkHasComponent(entity, m.ids[5])

	index := &m.world.storage.entities[entity.id]
	m.storageA.columns[index.table].Set(index.row, unsafe.Pointer(a))
	m.storageB.columns[index.table].Set(index.row, unsafe.Pointer(b))
	m.storageC.columns[index.table].Set(index.row, unsafe.Pointer(c))
	m.storageD.columns[index.table].Set(index.row, unsafe.Pointer(d))
	m.storageE.columns[index.table].Set(index.row, unsafe.Pointer(e))
	m.storageF.columns[index.table].Set(index.row, unsafe.Pointer(f))
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map6[A, B, C, D, E, F]) AddBatch(batch *Batch, a *A, b *B, c *C, d *D, e *E, f *F, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchangeBatch(batch, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
	}, m.relations, nil)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map6[A, B, C, D, E, F]) AddBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]
			columnA := m.storageA.columns[tableID]
			columnB := m.storageB.columns[tableID]
			columnC := m.storageC.columns[tableID]
			columnD := m.storageD.columns[tableID]
			columnE := m.storageE.columns[tableID]
			columnF := m.storageF.columns[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
					(*D)(columnD.Get(index)),
					(*E)(columnE.Get(index)),
					(*F)(columnF.Get(index)),
				)
			}
			m.world.unlock(lock)
		}
	}
	m.world.exchangeBatch(batch, m.ids, nil, nil, m.relations, process)
}

// Remove the mapped components from the given entity.
func (m *Map6[A, B, C, D, E, F]) Remove(entity Entity) {
	m.world.exchange(entity, nil, m.ids, nil, nil)
}

// RemoveBatch removes the mapped components from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map6[A, B, C, D, E, F]) RemoveBatch(batch *Batch, fn func(entity Entity)) {
	removeBatch(m.world, batch, m.ids, fn)
}

// GetRelation returns the relation target of an entity for the component at the given index.
func (m *Map6[A, B, C, D, E, F]) GetRelation(entity Entity, index int) Entity {
	if !m.world.Alive(entity) {
		panic("can't get entity relation target for a dead entity")
	}
	return m.GetRelationUnchecked(entity, index)
}

// GetRelationUnchecked returns the relation target of an entity for the component at the given index.
// In contrast to [Map6.GetRelation], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map6[A, B, C, D, E, F]) GetRelationUnchecked(entity Entity, index int) Entity {
	return m.world.storage.getRelation(entity, m.ids[index])
}

// SetRelations sets relation targets for the given entity.
func (m *Map6[A, B, C, D, E, F]) SetRelations(entity Entity, rel ...Relation) {
	// alive check is done in World.setRelations
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.setRelations(entity, m.relations)
}

// SetRelationsBatch sets relation targets for all entities matching the given batch filter.
func (m *Map6[A, B, C, D, E, F]) SetRelationsBatch(batch *Batch, fn func(entity Entity), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	setRelationsBatch(m.world, batch, fn, m.relations)
}

// Map7 is a mapper to access 7 components of an entity.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Map2] for a usage example.
type Map7[A any, B any, C any, D any, E any, F any, G any] struct {
	world     *World
	ids       []ID
	storageA  *componentStorage
	storageB  *componentStorage
	storageC  *componentStorage
	storageD  *componentStorage
	storageE  *componentStorage
	storageF  *componentStorage
	storageG  *componentStorage
	relations []RelationID
}

// NewMap7 creates a new [Map7].
func NewMap7[A any, B any, C any, D any, E any, F any, G any](world *World) Map7[A, B, C, D, E, F, G] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
		ComponentID[F](world),
		ComponentID[G](world),
	}
	return Map7[A, B, C, D, E, F, G]{
		world:    world,
		ids:      ids,
		storageA: &world.storage.components[ids[0].id],
		storageB: &world.storage.components[ids[1].id],
		storageC: &world.storage.components[ids[2].id],
		storageD: &world.storage.components[ids[3].id],
		storageE: &world.storage.components[ids[4].id],
		storageF: &world.storage.components[ids[5].id],
		storageG: &world.storage.components[ids[6].id],
	}
}

// NewEntity creates a new entity with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map7[A, B, C, D, E, F, G]) NewEntity(a *A, b *B, c *C, d *D, e *E, f *F, g *G, rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	return m.world.newEntityWith(m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
	}, m.relations)
}

// NewEntityFn creates a new entity with the mapped component and runs a callback instead of using a component for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map7[A, B, C, D, E, F, G]) NewEntityFn(fn func(a *A, b *B, c *C, d *D, e *E, f *F, g *G), rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	entity := m.world.newEntityWith(m.ids, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
			(*G)(m.storageG.columns[index.table].Get(row)),
		)
	}
	return entity
}

// NewBatch creates a batch of new entities with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map7[A, B, C, D, E, F, G]) NewBatch(count int, a *A, b *B, c *C, d *D, e *E, f *F, g *G, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.newEntitiesWith(count, m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
	}, m.relations)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map7[A, B, C, D, E, F, G]) NewBatchFn(count int, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)
	if fn == nil {
		return
	}

	table := &m.world.storage.tables[tableID]
	columnA := m.storageA.columns[tableID]
	columnB := m.storageB.columns[tableID]
	columnC := m.storageC.columns[tableID]
	columnD := m.storageD.columns[tableID]
	columnE := m.storageE.columns[tableID]
	columnF := m.storageF.columns[tableID]
	columnG := m.storageG.columns[tableID]

	lock := m.world.lock()
	for i := range count {
		index := uintptr(start + i)
		fn(
			table.GetEntity(index),
			(*A)(columnA.Get(index)),
			(*B)(columnB.Get(index)),
			(*C)(columnC.Get(index)),
			(*D)(columnD.Get(index)),
			(*E)(columnE.Get(index)),
			(*F)(columnF.Get(index)),
			(*G)(columnG.Get(index)),
		)
	}
	m.world.unlock(lock)
}

// Get returns the mapped components for the given entity.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map7[A, B, C, D, E, F, G]) Get(entity Entity) (*A, *B, *C, *D, *E, *F, *G) {
	if !m.world.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)

	var a *A
	var b *B
	var c *C
	var d *D
	var e *E
	var f *F
	var g *G

	columnA := m.storageA.columns[index.table]
	if columnA != nil {
		a = (*A)(columnA.Get(row))
	}
	columnB := m.storageB.columns[index.table]
	if columnB != nil {
		b = (*B)(columnB.Get(row))
	}
	columnC := m.storageC.columns[index.table]
	if columnC != nil {
		c = (*C)(columnC.Get(row))
	}
	columnD := m.storageD.columns[index.table]
	if columnD != nil {
		d = (*D)(columnD.Get(row))
	}
	columnE := m.storageE.columns[index.table]
	if columnE != nil {
		e = (*E)(columnE.Get(row))
	}
	columnF := m.storageF.columns[index.table]
	if columnF != nil {
		f = (*F)(columnF.Get(row))
	}
	columnG := m.storageG.columns[index.table]
	if columnG != nil {
		g = (*G)(columnG.Get(row))
	}
	return a, b, c, d, e, f, g
}

// GetUnchecked returns the mapped components for the given entity.
// In contrast to [Map7.Get], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map7[A, B, C, D, E, F, G]) GetUnchecked(entity Entity) (*A, *B, *C, *D, *E, *F, *G) {
	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)

	var a *A
	var b *B
	var c *C
	var d *D
	var e *E
	var f *F
	var g *G

	columnA := m.storageA.columns[index.table]
	if columnA != nil {
		a = (*A)(columnA.Get(row))
	}
	columnB := m.storageB.columns[index.table]
	if columnB != nil {
		b = (*B)(columnB.Get(row))
	}
	columnC := m.storageC.columns[index.table]
	if columnC != nil {
		c = (*C)(columnC.Get(row))
	}
	columnD := m.storageD.columns[index.table]
	if columnD != nil {
		d = (*D)(columnD.Get(row))
	}
	columnE := m.storageE.columns[index.table]
	if columnE != nil {
		e = (*E)(columnE.Get(row))
	}
	columnF := m.storageF.columns[index.table]
	if columnF != nil {
		f = (*F)(columnF.Get(row))
	}
	columnG := m.storageG.columns[index.table]
	if columnG != nil {
		g = (*G)(columnG.Get(row))
	}
	return a, b, c, d, e, f, g
}

// HasAll return whether the given entity has all mapped components.
//
// Using [Map7.Get] and checking for nil pointer may be faster
// than calling [Map7.HasAll] and [Map7.Get] subsequently.
func (m *Map7[A, B, C, D, E, F, G]) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	index := m.world.storage.entities[entity.id]
	return m.storageA.columns[index.table] != nil &&
		m.storageB.columns[index.table] != nil &&
		m.storageC.columns[index.table] != nil &&
		m.storageD.columns[index.table] != nil &&
		m.storageE.columns[index.table] != nil &&
		m.storageF.columns[index.table] != nil &&
		m.storageG.columns[index.table] != nil
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map7[A, B, C, D, E, F, G]) Add(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchange(entity, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
	}, m.relations)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map7[A, B, C, D, E, F, G]) AddFn(entity Entity, fn func(a *A, b *B, c *C, d *D, e *E, f *F, g *G), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchange(entity, m.ids, nil, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
			(*G)(m.storageG.columns[index.table].Get(row)),
		)
	}
}

// Set the mapped components of the given entity to the given values.
//
// Requires the entity to already have all the mapped components.
// This is not a component operation, so it can be performed on a locked world.
func (m *Map7[A, B, C, D, E, F, G]) Set(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G) {
	if !m.world.Alive(entity) {
		panic("can't set components of a dead entity")
	}
	m.world.storage.checkHasComponent(entity, m.ids[0])
	m.world.storage.checkHasComponent(entity, m.ids[1])
	m.world.storage.checkHasComponent(entity, m.ids[2])
	m.world.storage.checkHasComponent(entity, m.ids[3])
	m.world.storage.checkHasComponent(entity, m.ids[4])
	m.world.storage.checkHasComponent(entity, m.ids[5])
	m.world.storage.checkHasComponent(entity, m.ids[6])

	index := &m.world.storage.entities[entity.id]
	m.storageA.columns[index.table].Set(index.row, unsafe.Pointer(a))
	m.storageB.columns[index.table].Set(index.row, unsafe.Pointer(b))
	m.storageC.columns[index.table].Set(index.row, unsafe.Pointer(c))
	m.storageD.columns[index.table].Set(index.row, unsafe.Pointer(d))
	m.storageE.columns[index.table].Set(index.row, unsafe.Pointer(e))
	m.storageF.columns[index.table].Set(index.row, unsafe.Pointer(f))
	m.storageG.columns[index.table].Set(index.row, unsafe.Pointer(g))
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map7[A, B, C, D, E, F, G]) AddBatch(batch *Batch, a *A, b *B, c *C, d *D, e *E, f *F, g *G, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchangeBatch(batch, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
	}, m.relations, nil)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map7[A, B, C, D, E, F, G]) AddBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]
			columnA := m.storageA.columns[tableID]
			columnB := m.storageB.columns[tableID]
			columnC := m.storageC.columns[tableID]
			columnD := m.storageD.columns[tableID]
			columnE := m.storageE.columns[tableID]
			columnF := m.storageF.columns[tableID]
			columnG := m.storageG.columns[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
					(*D)(columnD.Get(index)),
					(*E)(columnE.Get(index)),
					(*F)(columnF.Get(index)),
					(*G)(columnG.Get(index)),
				)
			}
			m.world.unlock(lock)
		}
	}
	m.world.exchangeBatch(batch, m.ids, nil, nil, m.relations, process)
}

// Remove the mapped components from the given entity.
func (m *Map7[A, B, C, D, E, F, G]) Remove(entity Entity) {
	m.world.exchange(entity, nil, m.ids, nil, nil)
}

// RemoveBatch removes the mapped components from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map7[A, B, C, D, E, F, G]) RemoveBatch(batch *Batch, fn func(entity Entity)) {
	removeBatch(m.world, batch, m.ids, fn)
}

// GetRelation returns the relation target of an entity for the component at the given index.
func (m *Map7[A, B, C, D, E, F, G]) GetRelation(entity Entity, index int) Entity {
	if !m.world.Alive(entity) {
		panic("can't get entity relation target for a dead entity")
	}
	return m.GetRelationUnchecked(entity, index)
}

// GetRelationUnchecked returns the relation target of an entity for the component at the given index.
// In contrast to [Map7.GetRelation], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map7[A, B, C, D, E, F, G]) GetRelationUnchecked(entity Entity, index int) Entity {
	return m.world.storage.getRelation(entity, m.ids[index])
}

// SetRelations sets relation targets for the given entity.
func (m *Map7[A, B, C, D, E, F, G]) SetRelations(entity Entity, rel ...Relation) {
	// alive check is done in World.setRelations
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.setRelations(entity, m.relations)
}

// SetRelationsBatch sets relation targets for all entities matching the given batch filter.
func (m *Map7[A, B, C, D, E, F, G]) SetRelationsBatch(batch *Batch, fn func(entity Entity), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	setRelationsBatch(m.world, batch, fn, m.relations)
}

// Map8 is a mapper to access 8 components of an entity.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Map2] for a usage example.
type Map8[A any, B any, C any, D any, E any, F any, G any, H any] struct {
	world     *World
	ids       []ID
	storageA  *componentStorage
	storageB  *componentStorage
	storageC  *componentStorage
	storageD  *componentStorage
	storageE  *componentStorage
	storageF  *componentStorage
	storageG  *componentStorage
	storageH  *componentStorage
	relations []RelationID
}

// NewMap8 creates a new [Map8].
func NewMap8[A any, B any, C any, D any, E any, F any, G any, H any](world *World) Map8[A, B, C, D, E, F, G, H] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
		ComponentID[F](world),
		ComponentID[G](world),
		ComponentID[H](world),
	}
	return Map8[A, B, C, D, E, F, G, H]{
		world:    world,
		ids:      ids,
		storageA: &world.storage.components[ids[0].id],
		storageB: &world.storage.components[ids[1].id],
		storageC: &world.storage.components[ids[2].id],
		storageD: &world.storage.components[ids[3].id],
		storageE: &world.storage.components[ids[4].id],
		storageF: &world.storage.components[ids[5].id],
		storageG: &world.storage.components[ids[6].id],
		storageH: &world.storage.components[ids[7].id],
	}
}

// NewEntity creates a new entity with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map8[A, B, C, D, E, F, G, H]) NewEntity(a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	return m.world.newEntityWith(m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
		unsafe.Pointer(h),
	}, m.relations)
}

// NewEntityFn creates a new entity with the mapped component and runs a callback instead of using a component for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map8[A, B, C, D, E, F, G, H]) NewEntityFn(fn func(a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H), rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	entity := m.world.newEntityWith(m.ids, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
			(*G)(m.storageG.columns[index.table].Get(row)),
			(*H)(m.storageH.columns[index.table].Get(row)),
		)
	}
	return entity
}

// NewBatch creates a batch of new entities with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map8[A, B, C, D, E, F, G, H]) NewBatch(count int, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.newEntitiesWith(count, m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
		unsafe.Pointer(h),
	}, m.relations)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map8[A, B, C, D, E, F, G, H]) NewBatchFn(count int, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)
	if fn == nil {
		return
	}

	table := &m.world.storage.tables[tableID]
	columnA := m.storageA.columns[tableID]
	columnB := m.storageB.columns[tableID]
	columnC := m.storageC.columns[tableID]
	columnD := m.storageD.columns[tableID]
	columnE := m.storageE.columns[tableID]
	columnF := m.storageF.columns[tableID]
	columnG := m.storageG.columns[tableID]
	columnH := m.storageH.columns[tableID]

	lock := m.world.lock()
	for i := range count {
		index := uintptr(start + i)
		fn(
			table.GetEntity(index),
			(*A)(columnA.Get(index)),
			(*B)(columnB.Get(index)),
			(*C)(columnC.Get(index)),
			(*D)(columnD.Get(index)),
			(*E)(columnE.Get(index)),
			(*F)(columnF.Get(index)),
			(*G)(columnG.Get(index)),
			(*H)(columnH.Get(index)),
		)
	}
	m.world.unlock(lock)
}

// Get returns the mapped components for the given entity.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map8[A, B, C, D, E, F, G, H]) Get(entity Entity) (*A, *B, *C, *D, *E, *F, *G, *H) {
	if !m.world.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)

	var a *A
	var b *B
	var c *C
	var d *D
	var e *E
	var f *F
	var g *G
	var h *H

	columnA := m.storageA.columns[index.table]
	if columnA != nil {
		a = (*A)(columnA.Get(row))
	}
	columnB := m.storageB.columns[index.table]
	if columnB != nil {
		b = (*B)(columnB.Get(row))
	}
	columnC := m.storageC.columns[index.table]
	if columnC != nil {
		c = (*C)(columnC.Get(row))
	}
	columnD := m.storageD.columns[index.table]
	if columnD != nil {
		d = (*D)(columnD.Get(row))
	}
	columnE := m.storageE.columns[index.table]
	if columnE != nil {
		e = (*E)(columnE.Get(row))
	}
	columnF := m.storageF.columns[index.table]
	if columnF != nil {
		f = (*F)(columnF.Get(row))
	}
	columnG := m.storageG.columns[index.table]
	if columnG != nil {
		g = (*G)(columnG.Get(row))
	}
	columnH := m.storageH.columns[index.table]
	if columnH != nil {
		h = (*H)(columnH.Get(row))
	}
	return a, b, c, d, e, f, g, h
}

// GetUnchecked returns the mapped components for the given entity.
// In contrast to [Map8.Get], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map8[A, B, C, D, E, F, G, H]) GetUnchecked(entity Entity) (*A, *B, *C, *D, *E, *F, *G, *H) {
	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)

	var a *A
	var b *B
	var c *C
	var d *D
	var e *E
	var f *F
	var g *G
	var h *H

	columnA := m.storageA.columns[index.table]
	if columnA != nil {
		a = (*A)(columnA.Get(row))
	}
	columnB := m.storageB.columns[index.table]
	if columnB != nil {
		b = (*B)(columnB.Get(row))
	}
	columnC := m.storageC.columns[index.table]
	if columnC != nil {
		c = (*C)(columnC.Get(row))
	}
	columnD := m.storageD.columns[index.table]
	if columnD != nil {
		d = (*D)(columnD.Get(row))
	}
	columnE := m.storageE.columns[index.table]
	if columnE != nil {
		e = (*E)(columnE.Get(row))
	}
	columnF := m.storageF.columns[index.table]
	if columnF != nil {
		f = (*F)(columnF.Get(row))
	}
	columnG := m.storageG.columns[index.table]
	if columnG != nil {
		g = (*G)(columnG.Get(row))
	}
	columnH := m.storageH.columns[index.table]
	if columnH != nil {
		h = (*H)(columnH.Get(row))
	}
	return a, b, c, d, e, f, g, h
}

// HasAll return whether the given entity has all mapped components.
//
// Using [Map8.Get] and checking for nil pointer may be faster
// than calling [Map8.HasAll] and [Map8.Get] subsequently.
func (m *Map8[A, B, C, D, E, F, G, H]) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	index := m.world.storage.entities[entity.id]
	return m.storageA.columns[index.table] != nil &&
		m.storageB.columns[index.table] != nil &&
		m.storageC.columns[index.table] != nil &&
		m.storageD.columns[index.table] != nil &&
		m.storageE.columns[index.table] != nil &&
		m.storageF.columns[index.table] != nil &&
		m.storageG.columns[index.table] != nil &&
		m.storageH.columns[index.table] != nil
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map8[A, B, C, D, E, F, G, H]) Add(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchange(entity, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
		unsafe.Pointer(h),
	}, m.relations)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map8[A, B, C, D, E, F, G, H]) AddFn(entity Entity, fn func(a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchange(entity, m.ids, nil, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
			(*G)(m.storageG.columns[index.table].Get(row)),
			(*H)(m.storageH.columns[index.table].Get(row)),
		)
	}
}

// Set the mapped components of the given entity to the given values.
//
// Requires the entity to already have all the mapped components.
// This is not a component operation, so it can be performed on a locked world.
func (m *Map8[A, B, C, D, E, F, G, H]) Set(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H) {
	if !m.world.Alive(entity) {
		panic("can't set components of a dead entity")
	}
	m.world.storage.checkHasComponent(entity, m.ids[0])
	m.world.storage.checkHasComponent(entity, m.ids[1])
	m.world.storage.checkHasComponent(entity, m.ids[2])
	m.world.storage.checkHasComponent(entity, m.ids[3])
	m.world.storage.checkHasComponent(entity, m.ids[4])
	m.world.storage.checkHasComponent(entity, m.ids[5])
	m.world.storage.checkHasComponent(entity, m.ids[6])
	m.world.storage.checkHasComponent(entity, m.ids[7])

	index := &m.world.storage.entities[entity.id]
	m.storageA.columns[index.table].Set(index.row, unsafe.Pointer(a))
	m.storageB.columns[index.table].Set(index.row, unsafe.Pointer(b))
	m.storageC.columns[index.table].Set(index.row, unsafe.Pointer(c))
	m.storageD.columns[index.table].Set(index.row, unsafe.Pointer(d))
	m.storageE.columns[index.table].Set(index.row, unsafe.Pointer(e))
	m.storageF.columns[index.table].Set(index.row, unsafe.Pointer(f))
	m.storageG.columns[index.table].Set(index.row, unsafe.Pointer(g))
	m.storageH.columns[index.table].Set(index.row, unsafe.Pointer(h))
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map8[A, B, C, D, E, F, G, H]) AddBatch(batch *Batch, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchangeBatch(batch, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
		unsafe.Pointer(h),
	}, m.relations, nil)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map8[A, B, C, D, E, F, G, H]) AddBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]
			columnA := m.storageA.columns[tableID]
			columnB := m.storageB.columns[tableID]
			columnC := m.storageC.columns[tableID]
			columnD := m.storageD.columns[tableID]
			columnE := m.storageE.columns[tableID]
			columnF := m.storageF.columns[tableID]
			columnG := m.storageG.columns[tableID]
			columnH := m.storageH.columns[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
					(*D)(columnD.Get(index)),
					(*E)(columnE.Get(index)),
					(*F)(columnF.Get(index)),
					(*G)(columnG.Get(index)),
					(*H)(columnH.Get(index)),
				)
			}
			m.world.unlock(lock)
		}
	}
	m.world.exchangeBatch(batch, m.ids, nil, nil, m.relations, process)
}

// Remove the mapped components from the given entity.
func (m *Map8[A, B, C, D, E, F, G, H]) Remove(entity Entity) {
	m.world.exchange(entity, nil, m.ids, nil, nil)
}

// RemoveBatch removes the mapped components from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map8[A, B, C, D, E, F, G, H]) RemoveBatch(batch *Batch, fn func(entity Entity)) {
	removeBatch(m.world, batch, m.ids, fn)
}

// GetRelation returns the relation target of an entity for the component at the given index.
func (m *Map8[A, B, C, D, E, F, G, H]) GetRelation(entity Entity, index int) Entity {
	if !m.world.Alive(entity) {
		panic("can't get entity relation target for a dead entity")
	}
	return m.GetRelationUnchecked(entity, index)
}

// GetRelationUnchecked returns the relation target of an entity for the component at the given index.
// In contrast to [Map8.GetRelation], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map8[A, B, C, D, E, F, G, H]) GetRelationUnchecked(entity Entity, index int) Entity {
	return m.world.storage.getRelation(entity, m.ids[index])
}

// SetRelations sets relation targets for the given entity.
func (m *Map8[A, B, C, D, E, F, G, H]) SetRelations(entity Entity, rel ...Relation) {
	// alive check is done in World.setRelations
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.setRelations(entity, m.relations)
}

// SetRelationsBatch sets relation targets for all entities matching the given batch filter.
func (m *Map8[A, B, C, D, E, F, G, H]) SetRelationsBatch(batch *Batch, fn func(entity Entity), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	setRelationsBatch(m.world, batch, fn, m.relations)
}

// Map9 is a mapper to access 9 components of an entity.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Map2] for a usage example.
type Map9[A any, B any, C any, D any, E any, F any, G any, H any, I any] struct {
	world     *World
	ids       []ID
	storageA  *componentStorage
	storageB  *componentStorage
	storageC  *componentStorage
	storageD  *componentStorage
	storageE  *componentStorage
	storageF  *componentStorage
	storageG  *componentStorage
	storageH  *componentStorage
	storageI  *componentStorage
	relations []RelationID
}

// NewMap9 creates a new [Map9].
func NewMap9[A any, B any, C any, D any, E any, F any, G any, H any, I any](world *World) Map9[A, B, C, D, E, F, G, H, I] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
		ComponentID[F](world),
		ComponentID[G](world),
		ComponentID[H](world),
		ComponentID[I](world),
	}
	return Map9[A, B, C, D, E, F, G, H, I]{
		world:    world,
		ids:      ids,
		storageA: &world.storage.components[ids[0].id],
		storageB: &world.storage.components[ids[1].id],
		storageC: &world.storage.components[ids[2].id],
		storageD: &world.storage.components[ids[3].id],
		storageE: &world.storage.components[ids[4].id],
		storageF: &world.storage.components[ids[5].id],
		storageG: &world.storage.components[ids[6].id],
		storageH: &world.storage.components[ids[7].id],
		storageI: &world.storage.components[ids[8].id],
	}
}

// NewEntity creates a new entity with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map9[A, B, C, D, E, F, G, H, I]) NewEntity(a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	return m.world.newEntityWith(m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
		unsafe.Pointer(h),
		unsafe.Pointer(i),
	}, m.relations)
}

// NewEntityFn creates a new entity with the mapped component and runs a callback instead of using a component for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map9[A, B, C, D, E, F, G, H, I]) NewEntityFn(fn func(a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I), rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	entity := m.world.newEntityWith(m.ids, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
			(*G)(m.storageG.columns[index.table].Get(row)),
			(*H)(m.storageH.columns[index.table].Get(row)),
			(*I)(m.storageI.columns[index.table].Get(row)),
		)
	}
	return entity
}

// NewBatch creates a batch of new entities with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map9[A, B, C, D, E, F, G, H, I]) NewBatch(count int, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.newEntitiesWith(count, m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
		unsafe.Pointer(h),
		unsafe.Pointer(i),
	}, m.relations)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map9[A, B, C, D, E, F, G, H, I]) NewBatchFn(count int, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)
	if fn == nil {
		return
	}

	table := &m.world.storage.tables[tableID]
	columnA := m.storageA.columns[tableID]
	columnB := m.storageB.columns[tableID]
	columnC := m.storageC.columns[tableID]
	columnD := m.storageD.columns[tableID]
	columnE := m.storageE.columns[tableID]
	columnF := m.storageF.columns[tableID]
	columnG := m.storageG.columns[tableID]
	columnH := m.storageH.columns[tableID]
	columnI := m.storageI.columns[tableID]

	lock := m.world.lock()
	for i := range count {
		index := uintptr(start + i)
		fn(
			table.GetEntity(index),
			(*A)(columnA.Get(index)),
			(*B)(columnB.Get(index)),
			(*C)(columnC.Get(index)),
			(*D)(columnD.Get(index)),
			(*E)(columnE.Get(index)),
			(*F)(columnF.Get(index)),
			(*G)(columnG.Get(index)),
			(*H)(columnH.Get(index)),
			(*I)(columnI.Get(index)),
		)
	}
	m.world.unlock(lock)
}

// Get returns the mapped components for the given entity.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map9[A, B, C, D, E, F, G, H, I]) Get(entity Entity) (*A, *B, *C, *D, *E, *F, *G, *H, *I) {
	if !m.world.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)

	var a *A
	var b *B
	var c *C
	var d *D
	var e *E
	var f *F
	var g *G
	var h *H
	var i *I

	columnA := m.storageA.columns[index.table]
	if columnA != nil {
		a = (*A)(columnA.Get(row))
	}
	columnB := m.storageB.columns[index.table]
	if columnB != nil {
		b = (*B)(columnB.Get(row))
	}
	columnC := m.storageC.columns[index.table]
	if columnC != nil {
		c = (*C)(columnC.Get(row))
	}
	columnD := m.storageD.columns[index.table]
	if columnD != nil {
		d = (*D)(columnD.Get(row))
	}
	columnE := m.storageE.columns[index.table]
	if columnE != nil {
		e = (*E)(columnE.Get(row))
	}
	columnF := m.storageF.columns[index.table]
	if columnF != nil {
		f = (*F)(columnF.Get(row))
	}
	columnG := m.storageG.columns[index.table]
	if columnG != nil {
		g = (*G)(columnG.Get(row))
	}
	columnH := m.storageH.columns[index.table]
	if columnH != nil {
		h = (*H)(columnH.Get(row))
	}
	columnI := m.storageI.columns[index.table]
	if columnI != nil {
		i = (*I)(columnI.Get(row))
	}
	return a, b, c, d, e, f, g, h, i
}

// GetUnchecked returns the mapped components for the given entity.
// In contrast to [Map9.Get], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map9[A, B, C, D, E, F, G, H, I]) GetUnchecked(entity Entity) (*A, *B, *C, *D, *E, *F, *G, *H, *I) {
	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)

	var a *A
	var b *B
	var c *C
	var d *D
	var e *E
	var f *F
	var g *G
	var h *H
	var i *I

	columnA := m.storageA.columns[index.table]
	if columnA != nil {
		a = (*A)(columnA.Get(row))
	}
	columnB := m.storageB.columns[index.table]
	if columnB != nil {
		b = (*B)(columnB.Get(row))
	}
	columnC := m.storageC.columns[index.table]
	if columnC != nil {
		c = (*C)(columnC.Get(row))
	}
	columnD := m.storageD.columns[index.table]
	if columnD != nil {
		d = (*D)(columnD.Get(row))
	}
	columnE := m.storageE.columns[index.table]
	if columnE != nil {
		e = (*E)(columnE.Get(row))
	}
	columnF := m.storageF.columns[index.table]
	if columnF != nil {
		f = (*F)(columnF.Get(row))
	}
	columnG := m.storageG.columns[index.table]
	if columnG != nil {
		g = (*G)(columnG.Get(row))
	}
	columnH := m.storageH.columns[index.table]
	if columnH != nil {
		h = (*H)(columnH.Get(row))
	}
	columnI := m.storageI.columns[index.table]
	if columnI != nil {
		i = (*I)(columnI.Get(row))
	}
	return a, b, c, d, e, f, g, h, i
}

// HasAll return whether the given entity has all mapped components.
//
// Using [Map9.Get] and checking for nil pointer may be faster
// than calling [Map9.HasAll] and [Map9.Get] subsequently.
func (m *Map9[A, B, C, D, E, F, G, H, I]) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	index := m.world.storage.entities[entity.id]
	return m.storageA.columns[index.table] != nil &&
		m.storageB.columns[index.table] != nil &&
		m.storageC.columns[index.table] != nil &&
		m.storageD.columns[index.table] != nil &&
		m.storageE.columns[index.table] != nil &&
		m.storageF.columns[index.table] != nil &&
		m.storageG.columns[index.table] != nil &&
		m.storageH.columns[index.table] != nil &&
		m.storageI.columns[index.table] != nil
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map9[A, B, C, D, E, F, G, H, I]) Add(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchange(entity, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
		unsafe.Pointer(h),
		unsafe.Pointer(i),
	}, m.relations)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map9[A, B, C, D, E, F, G, H, I]) AddFn(entity Entity, fn func(a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchange(entity, m.ids, nil, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
			(*G)(m.storageG.columns[index.table].Get(row)),
			(*H)(m.storageH.columns[index.table].Get(row)),
			(*I)(m.storageI.columns[index.table].Get(row)),
		)
	}
}

// Set the mapped components of the given entity to the given values.
//
// Requires the entity to already have all the mapped components.
// This is not a component operation, so it can be performed on a locked world.
func (m *Map9[A, B, C, D, E, F, G, H, I]) Set(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I) {
	if !m.world.Alive(entity) {
		panic("can't set components of a dead entity")
	}
	m.world.storage.checkHasComponent(entity, m.ids[0])
	m.world.storage.checkHasComponent(entity, m.ids[1])
	m.world.storage.checkHasComponent(entity, m.ids[2])
	m.world.storage.checkHasComponent(entity, m.ids[3])
	m.world.storage.checkHasComponent(entity, m.ids[4])
	m.world.storage.checkHasComponent(entity, m.ids[5])
	m.world.storage.checkHasComponent(entity, m.ids[6])
	m.world.storage.checkHasComponent(entity, m.ids[7])
	m.world.storage.checkHasComponent(entity, m.ids[8])

	index := &m.world.storage.entities[entity.id]
	m.storageA.columns[index.table].Set(index.row, unsafe.Pointer(a))
	m.storageB.columns[index.table].Set(index.row, unsafe.Pointer(b))
	m.storageC.columns[index.table].Set(index.row, unsafe.Pointer(c))
	m.storageD.columns[index.table].Set(index.row, unsafe.Pointer(d))
	m.storageE.columns[index.table].Set(index.row, unsafe.Pointer(e))
	m.storageF.columns[index.table].Set(index.row, unsafe.Pointer(f))
	m.storageG.columns[index.table].Set(index.row, unsafe.Pointer(g))
	m.storageH.columns[index.table].Set(index.row, unsafe.Pointer(h))
	m.storageI.columns[index.table].Set(index.row, unsafe.Pointer(i))
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map9[A, B, C, D, E, F, G, H, I]) AddBatch(batch *Batch, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchangeBatch(batch, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
		unsafe.Pointer(h),
		unsafe.Pointer(i),
	}, m.relations, nil)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map9[A, B, C, D, E, F, G, H, I]) AddBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]
			columnA := m.storageA.columns[tableID]
			columnB := m.storageB.columns[tableID]
			columnC := m.storageC.columns[tableID]
			columnD := m.storageD.columns[tableID]
			columnE := m.storageE.columns[tableID]
			columnF := m.storageF.columns[tableID]
			columnG := m.storageG.columns[tableID]
			columnH := m.storageH.columns[tableID]
			columnI := m.storageI.columns[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
					(*D)(columnD.Get(index)),
					(*E)(columnE.Get(index)),
					(*F)(columnF.Get(index)),
					(*G)(columnG.Get(index)),
					(*H)(columnH.Get(index)),
					(*I)(columnI.Get(index)),
				)
			}
			m.world.unlock(lock)
		}
	}
	m.world.exchangeBatch(batch, m.ids, nil, nil, m.relations, process)
}

// Remove the mapped components from the given entity.
func (m *Map9[A, B, C, D, E, F, G, H, I]) Remove(entity Entity) {
	m.world.exchange(entity, nil, m.ids, nil, nil)
}

// RemoveBatch removes the mapped components from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map9[A, B, C, D, E, F, G, H, I]) RemoveBatch(batch *Batch, fn func(entity Entity)) {
	removeBatch(m.world, batch, m.ids, fn)
}

// GetRelation returns the relation target of an entity for the component at the given index.
func (m *Map9[A, B, C, D, E, F, G, H, I]) GetRelation(entity Entity, index int) Entity {
	if !m.world.Alive(entity) {
		panic("can't get entity relation target for a dead entity")
	}
	return m.GetRelationUnchecked(entity, index)
}

// GetRelationUnchecked returns the relation target of an entity for the component at the given index.
// In contrast to [Map9.GetRelation], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map9[A, B, C, D, E, F, G, H, I]) GetRelationUnchecked(entity Entity, index int) Entity {
	return m.world.storage.getRelation(entity, m.ids[index])
}

// SetRelations sets relation targets for the given entity.
func (m *Map9[A, B, C, D, E, F, G, H, I]) SetRelations(entity Entity, rel ...Relation) {
	// alive check is done in World.setRelations
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.setRelations(entity, m.relations)
}

// SetRelationsBatch sets relation targets for all entities matching the given batch filter.
func (m *Map9[A, B, C, D, E, F, G, H, I]) SetRelationsBatch(batch *Batch, fn func(entity Entity), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	setRelationsBatch(m.world, batch, fn, m.relations)
}

// Map10 is a mapper to access 10 components of an entity.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Map2] for a usage example.
type Map10[A any, B any, C any, D any, E any, F any, G any, H any, I any, J any] struct {
	world     *World
	ids       []ID
	storageA  *componentStorage
	storageB  *componentStorage
	storageC  *componentStorage
	storageD  *componentStorage
	storageE  *componentStorage
	storageF  *componentStorage
	storageG  *componentStorage
	storageH  *componentStorage
	storageI  *componentStorage
	storageJ  *componentStorage
	relations []RelationID
}

// NewMap10 creates a new [Map10].
func NewMap10[A any, B any, C any, D any, E any, F any, G any, H any, I any, J any](world *World) Map10[A, B, C, D, E, F, G, H, I, J] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
		ComponentID[F](world),
		ComponentID[G](world),
		ComponentID[H](world),
		ComponentID[I](world),
		ComponentID[J](world),
	}
	return Map10[A, B, C, D, E, F, G, H, I, J]{
		world:    world,
		ids:      ids,
		storageA: &world.storage.components[ids[0].id],
		storageB: &world.storage.components[ids[1].id],
		storageC: &world.storage.components[ids[2].id],
		storageD: &world.storage.components[ids[3].id],
		storageE: &world.storage.components[ids[4].id],
		storageF: &world.storage.components[ids[5].id],
		storageG: &world.storage.components[ids[6].id],
		storageH: &world.storage.components[ids[7].id],
		storageI: &world.storage.components[ids[8].id],
		storageJ: &world.storage.components[ids[9].id],
	}
}

// NewEntity creates a new entity with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) NewEntity(a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	return m.world.newEntityWith(m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
		unsafe.Pointer(h),
		unsafe.Pointer(i),
		unsafe.Pointer(j),
	}, m.relations)
}

// NewEntityFn creates a new entity with the mapped component and runs a callback instead of using a component for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) NewEntityFn(fn func(a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J), rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	entity := m.world.newEntityWith(m.ids, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
			(*G)(m.storageG.columns[index.table].Get(row)),
			(*H)(m.storageH.columns[index.table].Get(row)),
			(*I)(m.storageI.columns[index.table].Get(row)),
			(*J)(m.storageJ.columns[index.table].Get(row)),
		)
	}
	return entity
}

// NewBatch creates a batch of new entities with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) NewBatch(count int, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.newEntitiesWith(count, m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
		unsafe.Pointer(h),
		unsafe.Pointer(i),
		unsafe.Pointer(j),
	}, m.relations)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) NewBatchFn(count int, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)
	if fn == nil {
		return
	}

	table := &m.world.storage.tables[tableID]
	columnA := m.storageA.columns[tableID]
	columnB := m.storageB.columns[tableID]
	columnC := m.storageC.columns[tableID]
	columnD := m.storageD.columns[tableID]
	columnE := m.storageE.columns[tableID]
	columnF := m.storageF.columns[tableID]
	columnG := m.storageG.columns[tableID]
	columnH := m.storageH.columns[tableID]
	columnI := m.storageI.columns[tableID]
	columnJ := m.storageJ.columns[tableID]

	lock := m.world.lock()
	for i := range count {
		index := uintptr(start + i)
		fn(
			table.GetEntity(index),
			(*A)(columnA.Get(index)),
			(*B)(columnB.Get(index)),
			(*C)(columnC.Get(index)),
			(*D)(columnD.Get(index)),
			(*E)(columnE.Get(index)),
			(*F)(columnF.Get(index)),
			(*G)(columnG.Get(index)),
			(*H)(columnH.Get(index)),
			(*I)(columnI.Get(index)),
			(*J)(columnJ.Get(index)),
		)
	}
	m.world.unlock(lock)
}

// Get returns the mapped components for the given entity.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) Get(entity Entity) (*A, *B, *C, *D, *E, *F, *G, *H, *I, *J) {
	if !m.world.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)

	var a *A
	var b *B
	var c *C
	var d *D
	var e *E
	var f *F
	var g *G
	var h *H
	var i *I
	var j *J

	columnA := m.storageA.columns[index.table]
	if columnA != nil {
		a = (*A)(columnA.Get(row))
	}
	columnB := m.storageB.columns[index.table]
	if columnB != nil {
		b = (*B)(columnB.Get(row))
	}
	columnC := m.storageC.columns[index.table]
	if columnC != nil {
		c = (*C)(columnC.Get(row))
	}
	columnD := m.storageD.columns[index.table]
	if columnD != nil {
		d = (*D)(columnD.Get(row))
	}
	columnE := m.storageE.columns[index.table]
	if columnE != nil {
		e = (*E)(columnE.Get(row))
	}
	columnF := m.storageF.columns[index.table]
	if columnF != nil {
		f = (*F)(columnF.Get(row))
	}
	columnG := m.storageG.columns[index.table]
	if columnG != nil {
		g = (*G)(columnG.Get(row))
	}
	columnH := m.storageH.columns[index.table]
	if columnH != nil {
		h = (*H)(columnH.Get(row))
	}
	columnI := m.storageI.columns[index.table]
	if columnI != nil {
		i = (*I)(columnI.Get(row))
	}
	columnJ := m.storageJ.columns[index.table]
	if columnJ != nil {
		j = (*J)(columnJ.Get(row))
	}
	return a, b, c, d, e, f, g, h, i, j
}

// GetUnchecked returns the mapped components for the given entity.
// In contrast to [Map10.Get], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) GetUnchecked(entity Entity) (*A, *B, *C, *D, *E, *F, *G, *H, *I, *J) {
	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)

	var a *A
	var b *B
	var c *C
	var d *D
	var e *E
	var f *F
	var g *G
	var h *H
	var i *I
	var j *J

	columnA := m.storageA.columns[index.table]
	if columnA != nil {
		a = (*A)(columnA.Get(row))
	}
	columnB := m.storageB.columns[index.table]
	if columnB != nil {
		b = (*B)(columnB.Get(row))
	}
	columnC := m.storageC.columns[index.table]
	if columnC != nil {
		c = (*C)(columnC.Get(row))
	}
	columnD := m.storageD.columns[index.table]
	if columnD != nil {
		d = (*D)(columnD.Get(row))
	}
	columnE := m.storageE.columns[index.table]
	if columnE != nil {
		e = (*E)(columnE.Get(row))
	}
	columnF := m.storageF.columns[index.table]
	if columnF != nil {
		f = (*F)(columnF.Get(row))
	}
	columnG := m.storageG.columns[index.table]
	if columnG != nil {
		g = (*G)(columnG.Get(row))
	}
	columnH := m.storageH.columns[index.table]
	if columnH != nil {
		h = (*H)(columnH.Get(row))
	}
	columnI := m.storageI.columns[index.table]
	if columnI != nil {
		i = (*I)(columnI.Get(row))
	}
	columnJ := m.storageJ.columns[index.table]
	if columnJ != nil {
		j = (*J)(columnJ.Get(row))
	}
	return a, b, c, d, e, f, g, h, i, j
}

// HasAll return whether the given entity has all mapped components.
//
// Using [Map10.Get] and checking for nil pointer may be faster
// than calling [Map10.HasAll] and [Map10.Get] subsequently.
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	index := m.world.storage.entities[entity.id]
	return m.storageA.columns[index.table] != nil &&
		m.storageB.columns[index.table] != nil &&
		m.storageC.columns[index.table] != nil &&
		m.storageD.columns[index.table] != nil &&
		m.storageE.columns[index.table] != nil &&
		m.storageF.columns[index.table] != nil &&
		m.storageG.columns[index.table] != nil &&
		m.storageH.columns[index.table] != nil &&
		m.storageI.columns[index.table] != nil &&
		m.storageJ.columns[index.table] != nil
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) Add(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchange(entity, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
		unsafe.Pointer(h),
		unsafe.Pointer(i),
		unsafe.Pointer(j),
	}, m.relations)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) AddFn(entity Entity, fn func(a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchange(entity, m.ids, nil, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
			(*G)(m.storageG.columns[index.table].Get(row)),
			(*H)(m.storageH.columns[index.table].Get(row)),
			(*I)(m.storageI.columns[index.table].Get(row)),
			(*J)(m.storageJ.columns[index.table].Get(row)),
		)
	}
}

// Set the mapped components of the given entity to the given values.
//
// Requires the entity to already have all the mapped components.
// This is not a component operation, so it can be performed on a locked world.
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) Set(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J) {
	if !m.world.Alive(entity) {
		panic("can't set components of a dead entity")
	}
	m.world.storage.checkHasComponent(entity, m.ids[0])
	m.world.storage.checkHasComponent(entity, m.ids[1])
	m.world.storage.checkHasComponent(entity, m.ids[2])
	m.world.storage.checkHasComponent(entity, m.ids[3])
	m.world.storage.checkHasComponent(entity, m.ids[4])
	m.world.storage.checkHasComponent(entity, m.ids[5])
	m.world.storage.checkHasComponent(entity, m.ids[6])
	m.world.storage.checkHasComponent(entity, m.ids[7])
	m.world.storage.checkHasComponent(entity, m.ids[8])
	m.world.storage.checkHasComponent(entity, m.ids[9])

	index := &m.world.storage.entities[entity.id]
	m.storageA.columns[index.table].Set(index.row, unsafe.Pointer(a))
	m.storageB.columns[index.table].Set(index.row, unsafe.Pointer(b))
	m.storageC.columns[index.table].Set(index.row, unsafe.Pointer(c))
	m.storageD.columns[index.table].Set(index.row, unsafe.Pointer(d))
	m.storageE.columns[index.table].Set(index.row, unsafe.Pointer(e))
	m.storageF.columns[index.table].Set(index.row, unsafe.Pointer(f))
	m.storageG.columns[index.table].Set(index.row, unsafe.Pointer(g))
	m.storageH.columns[index.table].Set(index.row, unsafe.Pointer(h))
	m.storageI.columns[index.table].Set(index.row, unsafe.Pointer(i))
	m.storageJ.columns[index.table].Set(index.row, unsafe.Pointer(j))
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) AddBatch(batch *Batch, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchangeBatch(batch, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
		unsafe.Pointer(h),
		unsafe.Pointer(i),
		unsafe.Pointer(j),
	}, m.relations, nil)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) AddBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]
			columnA := m.storageA.columns[tableID]
			columnB := m.storageB.columns[tableID]
			columnC := m.storageC.columns[tableID]
			columnD := m.storageD.columns[tableID]
			columnE := m.storageE.columns[tableID]
			columnF := m.storageF.columns[tableID]
			columnG := m.storageG.columns[tableID]
			columnH := m.storageH.columns[tableID]
			columnI := m.storageI.columns[tableID]
			columnJ := m.storageJ.columns[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
					(*D)(columnD.Get(index)),
					(*E)(columnE.Get(index)),
					(*F)(columnF.Get(index)),
					(*G)(columnG.Get(index)),
					(*H)(columnH.Get(index)),
					(*I)(columnI.Get(index)),
					(*J)(columnJ.Get(index)),
				)
			}
			m.world.unlock(lock)
		}
	}
	m.world.exchangeBatch(batch, m.ids, nil, nil, m.relations, process)
}

// Remove the mapped components from the given entity.
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) Remove(entity Entity) {
	m.world.exchange(entity, nil, m.ids, nil, nil)
}

// RemoveBatch removes the mapped components from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) RemoveBatch(batch *Batch, fn func(entity Entity)) {
	removeBatch(m.world, batch, m.ids, fn)
}

// GetRelation returns the relation target of an entity for the component at the given index.
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) GetRelation(entity Entity, index int) Entity {
	if !m.world.Alive(entity) {
		panic("can't get entity relation target for a dead entity")
	}
	return m.GetRelationUnchecked(entity, index)
}

// GetRelationUnchecked returns the relation target of an entity for the component at the given index.
// In contrast to [Map10.GetRelation], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) GetRelationUnchecked(entity Entity, index int) Entity {
	return m.world.storage.getRelation(entity, m.ids[index])
}

// SetRelations sets relation targets for the given entity.
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) SetRelations(entity Entity, rel ...Relation) {
	// alive check is done in World.setRelations
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.setRelations(entity, m.relations)
}

// SetRelationsBatch sets relation targets for all entities matching the given batch filter.
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) SetRelationsBatch(batch *Batch, fn func(entity Entity), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	setRelationsBatch(m.world, batch, fn, m.relations)
}

// Map11 is a mapper to access 11 components of an entity.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Map2] for a usage example.
type Map11[A any, B any, C any, D any, E any, F any, G any, H any, I any, J any, K any] struct {
	world     *World
	ids       []ID
	storageA  *componentStorage
	storageB  *componentStorage
	storageC  *componentStorage
	storageD  *componentStorage
	storageE  *componentStorage
	storageF  *componentStorage
	storageG  *componentStorage
	storageH  *componentStorage
	storageI  *componentStorage
	storageJ  *componentStorage
	storageK  *componentStorage
	relations []RelationID
}

// NewMap11 creates a new [Map11].
func NewMap11[A any, B any, C any, D any, E any, F any, G any, H any, I any, J any, K any](world *World) Map11[A, B, C, D, E, F, G, H, I, J, K] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
		ComponentID[F](world),
		ComponentID[G](world),
		ComponentID[H](world),
		ComponentID[I](world),
		ComponentID[J](world),
		ComponentID[K](world),
	}
	return Map11[A, B, C, D, E, F, G, H, I, J, K]{
		world:    world,
		ids:      ids,
		storageA: &world.storage.components[ids[0].id],
		storageB: &world.storage.components[ids[1].id],
		storageC: &world.storage.components[ids[2].id],
		storageD: &world.storage.components[ids[3].id],
		storageE: &world.storage.components[ids[4].id],
		storageF: &world.storage.components[ids[5].id],
		storageG: &world.storage.components[ids[6].id],
		storageH: &world.storage.components[ids[7].id],
		storageI: &world.storage.components[ids[8].id],
		storageJ: &world.storage.components[ids[9].id],
		storageK: &world.storage.components[ids[10].id],
	}
}

// NewEntity creates a new entity with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) NewEntity(a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K, rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	return m.world.newEntityWith(m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
		unsafe.Pointer(h),
		unsafe.Pointer(i),
		unsafe.Pointer(j),
		unsafe.Pointer(k),
	}, m.relations)
}

// NewEntityFn creates a new entity with the mapped component and runs a callback instead of using a component for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) NewEntityFn(fn func(a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K), rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	entity := m.world.newEntityWith(m.ids, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
			(*G)(m.storageG.columns[index.table].Get(row)),
			(*H)(m.storageH.columns[index.table].Get(row)),
			(*I)(m.storageI.columns[index.table].Get(row)),
			(*J)(m.storageJ.columns[index.table].Get(row)),
			(*K)(m.storageK.columns[index.table].Get(row)),
		)
	}
	return entity
}

// NewBatch creates a batch of new entities with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) NewBatch(count int, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.newEntitiesWith(count, m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
		unsafe.Pointer(h),
		unsafe.Pointer(i),
		unsafe.Pointer(j),
		unsafe.Pointer(k),
	}, m.relations)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) NewBatchFn(count int, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)
	if fn == nil {
		return
	}

	table := &m.world.storage.tables[tableID]
	columnA := m.storageA.columns[tableID]
	columnB := m.storageB.columns[tableID]
	columnC := m.storageC.columns[tableID]
	columnD := m.storageD.columns[tableID]
	columnE := m.storageE.columns[tableID]
	columnF := m.storageF.columns[tableID]
	columnG := m.storageG.columns[tableID]
	columnH := m.storageH.columns[tableID]
	columnI := m.storageI.columns[tableID]
	columnJ := m.storageJ.columns[tableID]
	columnK := m.storageK.columns[tableID]

	lock := m.world.lock()
	for i := range count {
		index := uintptr(start + i)
		fn(
			table.GetEntity(index),
			(*A)(columnA.Get(index)),
			(*B)(columnB.Get(index)),
			(*C)(columnC.Get(index)),
			(*D)(columnD.Get(index)),
			(*E)(columnE.Get(index)),
			(*F)(columnF.Get(index)),
			(*G)(columnG.Get(index)),
			(*H)(columnH.Get(index)),
			(*I)(columnI.Get(index)),
			(*J)(columnJ.Get(index)),
			(*K)(columnK.Get(index)),
		)
	}
	m.world.unlock(lock)
}

// Get returns the mapped components for the given entity.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) Get(entity Entity) (*A, *B, *C, *D, *E, *F, *G, *H, *I, *J, *K) {
	if !m.world.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)

	var a *A
	var b *B
	var c *C
	var d *D
	var e *E
	var f *F
	var g *G
	var h *H
	var i *I
	var j *J
	var k *K

	columnA := m.storageA.columns[index.table]
	if columnA != nil {
		a = (*A)(columnA.Get(row))
	}
	columnB := m.storageB.columns[index.table]
	if columnB != nil {
		b = (*B)(columnB.Get(row))
	}
	columnC := m.storageC.columns[index.table]
	if columnC != nil {
		c = (*C)(columnC.Get(row))
	}
	columnD := m.storageD.columns[index.table]
	if columnD != nil {
		d = (*D)(columnD.Get(row))
	}
	columnE := m.storageE.columns[index.table]
	if columnE != nil {
		e = (*E)(columnE.Get(row))
	}
	columnF := m.storageF.columns[index.table]
	if columnF != nil {
		f = (*F)(columnF.Get(row))
	}
	columnG := m.storageG.columns[index.table]
	if columnG != nil {
		g = (*G)(columnG.Get(row))
	}
	columnH := m.storageH.columns[index.table]
	if columnH != nil {
		h = (*H)(columnH.Get(row))
	}
	columnI := m.storageI.columns[index.table]
	if columnI != nil {
		i = (*I)(columnI.Get(row))
	}
	columnJ := m.storageJ.columns[index.table]
	if columnJ != nil {
		j = (*J)(columnJ.Get(row))
	}
	columnK := m.storageK.columns[index.table]
	if columnK != nil {
		k = (*K)(columnK.Get(row))
	}
	return a, b, c, d, e, f, g, h, i, j, k
}

// GetUnchecked returns the mapped components for the given entity.
// In contrast to [Map11.Get], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) GetUnchecked(entity Entity) (*A, *B, *C, *D, *E, *F, *G, *H, *I, *J, *K) {
	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)

	var a *A
	var b *B
	var c *C
	var d *D
	var e *E
	var f *F
	var g *G
	var h *H
	var i *I
	var j *J
	var k *K

	columnA := m.storageA.columns[index.table]
	if columnA != nil {
		a = (*A)(columnA.Get(row))
	}
	columnB := m.storageB.columns[index.table]
	if columnB != nil {
		b = (*B)(columnB.Get(row))
	}
	columnC := m.storageC.columns[index.table]
	if columnC != nil {
		c = (*C)(columnC.Get(row))
	}
	columnD := m.storageD.columns[index.table]
	if columnD != nil {
		d = (*D)(columnD.Get(row))
	}
	columnE := m.storageE.columns[index.table]
	if columnE != nil {
		e = (*E)(columnE.Get(row))
	}
	columnF := m.storageF.columns[index.table]
	if columnF != nil {
		f = (*F)(columnF.Get(row))
	}
	columnG := m.storageG.columns[index.table]
	if columnG != nil {
		g = (*G)(columnG.Get(row))
	}
	columnH := m.storageH.columns[index.table]
	if columnH != nil {
		h = (*H)(columnH.Get(row))
	}
	columnI := m.storageI.columns[index.table]
	if columnI != nil {
		i = (*I)(columnI.Get(row))
	}
	columnJ := m.storageJ.columns[index.table]
	if columnJ != nil {
		j = (*J)(columnJ.Get(row))
	}
	columnK := m.storageK.columns[index.table]
	if columnK != nil {
		k = (*K)(columnK.Get(row))
	}
	return a, b, c, d, e, f, g, h, i, j, k
}

// HasAll return whether the given entity has all mapped components.
//
// Using [Map11.Get] and checking for nil pointer may be faster
// than calling [Map11.HasAll] and [Map11.Get] subsequently.
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	index := m.world.storage.entities[entity.id]
	return m.storageA.columns[index.table] != nil &&
		m.storageB.columns[index.table] != nil &&
		m.storageC.columns[index.table] != nil &&
		m.storageD.columns[index.table] != nil &&
		m.storageE.columns[index.table] != nil &&
		m.storageF.columns[index.table] != nil &&
		m.storageG.columns[index.table] != nil &&
		m.storageH.columns[index.table] != nil &&
		m.storageI.columns[index.table] != nil &&
		m.storageJ.columns[index.table] != nil &&
		m.storageK.columns[index.table] != nil
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) Add(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchange(entity, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
		unsafe.Pointer(h),
		unsafe.Pointer(i),
		unsafe.Pointer(j),
		unsafe.Pointer(k),
	}, m.relations)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) AddFn(entity Entity, fn func(a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchange(entity, m.ids, nil, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
			(*G)(m.storageG.columns[index.table].Get(row)),
			(*H)(m.storageH.columns[index.table].Get(row)),
			(*I)(m.storageI.columns[index.table].Get(row)),
			(*J)(m.storageJ.columns[index.table].Get(row)),
			(*K)(m.storageK.columns[index.table].Get(row)),
		)
	}
}

// Set the mapped components of the given entity to the given values.
//
// Requires the entity to already have all the mapped components.
// This is not a component operation, so it can be performed on a locked world.
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) Set(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K) {
	if !m.world.Alive(entity) {
		panic("can't set components of a dead entity")
	}
	m.world.storage.checkHasComponent(entity, m.ids[0])
	m.world.storage.checkHasComponent(entity, m.ids[1])
	m.world.storage.checkHasComponent(entity, m.ids[2])
	m.world.storage.checkHasComponent(entity, m.ids[3])
	m.world.storage.checkHasComponent(entity, m.ids[4])
	m.world.storage.checkHasComponent(entity, m.ids[5])
	m.world.storage.checkHasComponent(entity, m.ids[6])
	m.world.storage.checkHasComponent(entity, m.ids[7])
	m.world.storage.checkHasComponent(entity, m.ids[8])
	m.world.storage.checkHasComponent(entity, m.ids[9])
	m.world.storage.checkHasComponent(entity, m.ids[10])

	index := &m.world.storage.entities[entity.id]
	m.storageA.columns[index.table].Set(index.row, unsafe.Pointer(a))
	m.storageB.columns[index.table].Set(index.row, unsafe.Pointer(b))
	m.storageC.columns[index.table].Set(index.row, unsafe.Pointer(c))
	m.storageD.columns[index.table].Set(index.row, unsafe.Pointer(d))
	m.storageE.columns[index.table].Set(index.row, unsafe.Pointer(e))
	m.storageF.columns[index.table].Set(index.row, unsafe.Pointer(f))
	m.storageG.columns[index.table].Set(index.row, unsafe.Pointer(g))
	m.storageH.columns[index.table].Set(index.row, unsafe.Pointer(h))
	m.storageI.columns[index.table].Set(index.row, unsafe.Pointer(i))
	m.storageJ.columns[index.table].Set(index.row, unsafe.Pointer(j))
	m.storageK.columns[index.table].Set(index.row, unsafe.Pointer(k))
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) AddBatch(batch *Batch, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchangeBatch(batch, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
		unsafe.Pointer(h),
		unsafe.Pointer(i),
		unsafe.Pointer(j),
		unsafe.Pointer(k),
	}, m.relations, nil)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) AddBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]
			columnA := m.storageA.columns[tableID]
			columnB := m.storageB.columns[tableID]
			columnC := m.storageC.columns[tableID]
			columnD := m.storageD.columns[tableID]
			columnE := m.storageE.columns[tableID]
			columnF := m.storageF.columns[tableID]
			columnG := m.storageG.columns[tableID]
			columnH := m.storageH.columns[tableID]
			columnI := m.storageI.columns[tableID]
			columnJ := m.storageJ.columns[tableID]
			columnK := m.storageK.columns[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
					(*D)(columnD.Get(index)),
					(*E)(columnE.Get(index)),
					(*F)(columnF.Get(index)),
					(*G)(columnG.Get(index)),
					(*H)(columnH.Get(index)),
					(*I)(columnI.Get(index)),
					(*J)(columnJ.Get(index)),
					(*K)(columnK.Get(index)),
				)
			}
			m.world.unlock(lock)
		}
	}
	m.world.exchangeBatch(batch, m.ids, nil, nil, m.relations, process)
}

// Remove the mapped components from the given entity.
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) Remove(entity Entity) {
	m.world.exchange(entity, nil, m.ids, nil, nil)
}

// RemoveBatch removes the mapped components from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) RemoveBatch(batch *Batch, fn func(entity Entity)) {
	removeBatch(m.world, batch, m.ids, fn)
}

// GetRelation returns the relation target of an entity for the component at the given index.
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) GetRelation(entity Entity, index int) Entity {
	if !m.world.Alive(entity) {
		panic("can't get entity relation target for a dead entity")
	}
	return m.GetRelationUnchecked(entity, index)
}

// GetRelationUnchecked returns the relation target of an entity for the component at the given index.
// In contrast to [Map11.GetRelation], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) GetRelationUnchecked(entity Entity, index int) Entity {
	return m.world.storage.getRelation(entity, m.ids[index])
}

// SetRelations sets relation targets for the given entity.
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) SetRelations(entity Entity, rel ...Relation) {
	// alive check is done in World.setRelations
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.setRelations(entity, m.relations)
}

// SetRelationsBatch sets relation targets for all entities matching the given batch filter.
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) SetRelationsBatch(batch *Batch, fn func(entity Entity), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	setRelationsBatch(m.world, batch, fn, m.relations)
}

// Map12 is a mapper to access 12 components of an entity.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Map2] for a usage example.
type Map12[A any, B any, C any, D any, E any, F any, G any, H any, I any, J any, K any, L any] struct {
	world     *World
	ids       []ID
	storageA  *componentStorage
	storageB  *componentStorage
	storageC  *componentStorage
	storageD  *componentStorage
	storageE  *componentStorage
	storageF  *componentStorage
	storageG  *componentStorage
	storageH  *componentStorage
	storageI  *componentStorage
	storageJ  *componentStorage
	storageK  *componentStorage
	storageL  *componentStorage
	relations []RelationID
}

// NewMap12 creates a new [Map12].
func NewMap12[A any, B any, C any, D any, E any, F any, G any, H any, I any, J any, K any, L any](world *World) Map12[A, B, C, D, E, F, G, H, I, J, K, L] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
		ComponentID[F](world),
		ComponentID[G](world),
		ComponentID[H](world),
		ComponentID[I](world),
		ComponentID[J](world),
		ComponentID[K](world),
		ComponentID[L](world),
	}
	return Map12[A, B, C, D, E, F, G, H, I, J, K, L]{
		world:    world,
		ids:      ids,
		storageA: &world.storage.components[ids[0].id],
		storageB: &world.storage.components[ids[1].id],
		storageC: &world.storage.components[ids[2].id],
		storageD: &world.storage.components[ids[3].id],
		storageE: &world.storage.components[ids[4].id],
		storageF: &world.storage.components[ids[5].id],
		storageG: &world.storage.components[ids[6].id],
		storageH: &world.storage.components[ids[7].id],
		storageI: &world.storage.components[ids[8].id],
		storageJ: &world.storage.components[ids[9].id],
		storageK: &world.storage.components[ids[10].id],
		storageL: &world.storage.components[ids[11].id],
	}
}

// NewEntity creates a new entity with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) NewEntity(a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K, l *L, rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	return m.world.newEntityWith(m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
		unsafe.Pointer(h),
		unsafe.Pointer(i),
		unsafe.Pointer(j),
		unsafe.Pointer(k),
		unsafe.Pointer(l),
	}, m.relations)
}

// NewEntityFn creates a new entity with the mapped component and runs a callback instead of using a component for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) NewEntityFn(fn func(a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K, l *L), rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	entity := m.world.newEntityWith(m.ids, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
			(*G)(m.storageG.columns[index.table].Get(row)),
			(*H)(m.storageH.columns[index.table].Get(row)),
			(*I)(m.storageI.columns[index.table].Get(row)),
			(*J)(m.storageJ.columns[index.table].Get(row)),
			(*K)(m.storageK.columns[index.table].Get(row)),
			(*L)(m.storageL.columns[index.table].Get(row)),
		)
	}
	return entity
}

// NewBatch creates a batch of new entities with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) NewBatch(count int, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K, l *L, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.newEntitiesWith(count, m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
		unsafe.Pointer(h),
		unsafe.Pointer(i),
		unsafe.Pointer(j),
		unsafe.Pointer(k),
		unsafe.Pointer(l),
	}, m.relations)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) NewBatchFn(count int, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K, l *L), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)
	if fn == nil {
		return
	}

	table := &m.world.storage.tables[tableID]
	columnA := m.storageA.columns[tableID]
	columnB := m.storageB.columns[tableID]
	columnC := m.storageC.columns[tableID]
	columnD := m.storageD.columns[tableID]
	columnE := m.storageE.columns[tableID]
	columnF := m.storageF.columns[tableID]
	columnG := m.storageG.columns[tableID]
	columnH := m.storageH.columns[tableID]
	columnI := m.storageI.columns[tableID]
	columnJ := m.storageJ.columns[tableID]
	columnK := m.storageK.columns[tableID]
	columnL := m.storageL.columns[tableID]

	lock := m.world.lock()
	for i := range count {
		index := uintptr(start + i)
		fn(
			table.GetEntity(index),
			(*A)(columnA.Get(index)),
			(*B)(columnB.Get(index)),
			(*C)(columnC.Get(index)),
			(*D)(columnD.Get(index)),
			(*E)(columnE.Get(index)),
			(*F)(columnF.Get(index)),
			(*G)(columnG.Get(index)),
			(*H)(columnH.Get(index)),
			(*I)(columnI.Get(index)),
			(*J)(columnJ.Get(index)),
			(*K)(columnK.Get(index)),
			(*L)(columnL.Get(index)),
		)
	}
	m.world.unlock(lock)
}

// Get returns the mapped components for the given entity.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) Get(entity Entity) (*A, *B, *C, *D, *E, *F, *G, *H, *I, *J, *K, *L) {
	if !m.world.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)

	var a *A
	var b *B
	var c *C
	var d *D
	var e *E
	var f *F
	var g *G
	var h *H
	var i *I
	var j *J
	var k *K
	var l *L

	columnA := m.storageA.columns[index.table]
	if columnA != nil {
		a = (*A)(columnA.Get(row))
	}
	columnB := m.storageB.columns[index.table]
	if columnB != nil {
		b = (*B)(columnB.Get(row))
	}
	columnC := m.storageC.columns[index.table]
	if columnC != nil {
		c = (*C)(columnC.Get(row))
	}
	columnD := m.storageD.columns[index.table]
	if columnD != nil {
		d = (*D)(columnD.Get(row))
	}
	columnE := m.storageE.columns[index.table]
	if columnE != nil {
		e = (*E)(columnE.Get(row))
	}
	columnF := m.storageF.columns[index.table]
	if columnF != nil {
		f = (*F)(columnF.Get(row))
	}
	columnG := m.storageG.columns[index.table]
	if columnG != nil {
		g = (*G)(columnG.Get(row))
	}
	columnH := m.storageH.columns[index.table]
	if columnH != nil {
		h = (*H)(columnH.Get(row))
	}
	columnI := m.storageI.columns[index.table]
	if columnI != nil {
		i = (*I)(columnI.Get(row))
	}
	columnJ := m.storageJ.columns[index.table]
	if columnJ != nil {
		j = (*J)(columnJ.Get(row))
	}
	columnK := m.storageK.columns[index.table]
	if columnK != nil {
		k = (*K)(columnK.Get(row))
	}
	columnL := m.storageL.columns[index.table]
	if columnL != nil {
		l = (*L)(columnL.Get(row))
	}
	return a, b, c, d, e, f, g, h, i, j, k, l
}

// GetUnchecked returns the mapped components for the given entity.
// In contrast to [Map12.Get], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) GetUnchecked(entity Entity) (*A, *B, *C, *D, *E, *F, *G, *H, *I, *J, *K, *L) {
	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)

	var a *A
	var b *B
	var c *C
	var d *D
	var e *E
	var f *F
	var g *G
	var h *H
	var i *I
	var j *J
	var k *K
	var l *L

	columnA := m.storageA.columns[index.table]
	if columnA != nil {
		a = (*A)(columnA.Get(row))
	}
	columnB := m.storageB.columns[index.table]
	if columnB != nil {
		b = (*B)(columnB.Get(row))
	}
	columnC := m.storageC.columns[index.table]
	if columnC != nil {
		c = (*C)(columnC.Get(row))
	}
	columnD := m.storageD.columns[index.table]
	if columnD != nil {
		d = (*D)(columnD.Get(row))
	}
	columnE := m.storageE.columns[index.table]
	if columnE != nil {
		e = (*E)(columnE.Get(row))
	}
	columnF := m.storageF.columns[index.table]
	if columnF != nil {
		f = (*F)(columnF.Get(row))
	}
	columnG := m.storageG.columns[index.table]
	if columnG != nil {
		g = (*G)(columnG.Get(row))
	}
	columnH := m.storageH.columns[index.table]
	if columnH != nil {
		h = (*H)(columnH.Get(row))
	}
	columnI := m.storageI.columns[index.table]
	if columnI != nil {
		i = (*I)(columnI.Get(row))
	}
	columnJ := m.storageJ.columns[index.table]
	if columnJ != nil {
		j = (*J)(columnJ.Get(row))
	}
	columnK := m.storageK.columns[index.table]
	if columnK != nil {
		k = (*K)(columnK.Get(row))
	}
	columnL := m.storageL.columns[index.table]
	if columnL != nil {
		l = (*L)(columnL.Get(row))
	}
	return a, b, c, d, e, f, g, h, i, j, k, l
}

// HasAll return whether the given entity has all mapped components.
//
// Using [Map12.Get] and checking for nil pointer may be faster
// than calling [Map12.HasAll] and [Map12.Get] subsequently.
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	index := m.world.storage.entities[entity.id]
	return m.storageA.columns[index.table] != nil &&
		m.storageB.columns[index.table] != nil &&
		m.storageC.columns[index.table] != nil &&
		m.storageD.columns[index.table] != nil &&
		m.storageE.columns[index.table] != nil &&
		m.storageF.columns[index.table] != nil &&
		m.storageG.columns[index.table] != nil &&
		m.storageH.columns[index.table] != nil &&
		m.storageI.columns[index.table] != nil &&
		m.storageJ.columns[index.table] != nil &&
		m.storageK.columns[index.table] != nil &&
		m.storageL.columns[index.table] != nil
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) Add(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K, l *L, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchange(entity, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
		unsafe.Pointer(h),
		unsafe.Pointer(i),
		unsafe.Pointer(j),
		unsafe.Pointer(k),
		unsafe.Pointer(l),
	}, m.relations)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) AddFn(entity Entity, fn func(a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K, l *L), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchange(entity, m.ids, nil, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
			(*G)(m.storageG.columns[index.table].Get(row)),
			(*H)(m.storageH.columns[index.table].Get(row)),
			(*I)(m.storageI.columns[index.table].Get(row)),
			(*J)(m.storageJ.columns[index.table].Get(row)),
			(*K)(m.storageK.columns[index.table].Get(row)),
			(*L)(m.storageL.columns[index.table].Get(row)),
		)
	}
}

// Set the mapped components of the given entity to the given values.
//
// Requires the entity to already have all the mapped components.
// This is not a component operation, so it can be performed on a locked world.
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) Set(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K, l *L) {
	if !m.world.Alive(entity) {
		panic("can't set components of a dead entity")
	}
	m.world.storage.checkHasComponent(entity, m.ids[0])
	m.world.storage.checkHasComponent(entity, m.ids[1])
	m.world.storage.checkHasComponent(entity, m.ids[2])
	m.world.storage.checkHasComponent(entity, m.ids[3])
	m.world.storage.checkHasComponent(entity, m.ids[4])
	m.world.storage.checkHasComponent(entity, m.ids[5])
	m.world.storage.checkHasComponent(entity, m.ids[6])
	m.world.storage.checkHasComponent(entity, m.ids[7])
	m.world.storage.checkHasComponent(entity, m.ids[8])
	m.world.storage.checkHasComponent(entity, m.ids[9])
	m.world.storage.checkHasComponent(entity, m.ids[10])
	m.world.storage.checkHasComponent(entity, m.ids[11])

	index := &m.world.storage.entities[entity.id]
	m.storageA.columns[index.table].Set(index.row, unsafe.Pointer(a))
	m.storageB.columns[index.table].Set(index.row, unsafe.Pointer(b))
	m.storageC.columns[index.table].Set(index.row, unsafe.Pointer(c))
	m.storageD.columns[index.table].Set(index.row, unsafe.Pointer(d))
	m.storageE.columns[index.table].Set(index.row, unsafe.Pointer(e))
	m.storageF.columns[index.table].Set(index.row, unsafe.Pointer(f))
	m.storageG.columns[index.table].Set(index.row, unsafe.Pointer(g))
	m.storageH.columns[index.table].Set(index.row, unsafe.Pointer(h))
	m.storageI.columns[index.table].Set(index.row, unsafe.Pointer(i))
	m.storageJ.columns[index.table].Set(index.row, unsafe.Pointer(j))
	m.storageK.columns[index.table].Set(index.row, unsafe.Pointer(k))
	m.storageL.columns[index.table].Set(index.row, unsafe.Pointer(l))
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) AddBatch(batch *Batch, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K, l *L, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.exchangeBatch(batch, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
		unsafe.Pointer(h),
		unsafe.Pointer(i),
		unsafe.Pointer(j),
		unsafe.Pointer(k),
		unsafe.Pointer(l),
	}, m.relations, nil)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) AddBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K, l *L), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]
			columnA := m.storageA.columns[tableID]
			columnB := m.storageB.columns[tableID]
			columnC := m.storageC.columns[tableID]
			columnD := m.storageD.columns[tableID]
			columnE := m.storageE.columns[tableID]
			columnF := m.storageF.columns[tableID]
			columnG := m.storageG.columns[tableID]
			columnH := m.storageH.columns[tableID]
			columnI := m.storageI.columns[tableID]
			columnJ := m.storageJ.columns[tableID]
			columnK := m.storageK.columns[tableID]
			columnL := m.storageL.columns[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
					(*D)(columnD.Get(index)),
					(*E)(columnE.Get(index)),
					(*F)(columnF.Get(index)),
					(*G)(columnG.Get(index)),
					(*H)(columnH.Get(index)),
					(*I)(columnI.Get(index)),
					(*J)(columnJ.Get(index)),
					(*K)(columnK.Get(index)),
					(*L)(columnL.Get(index)),
				)
			}
			m.world.unlock(lock)
		}
	}
	m.world.exchangeBatch(batch, m.ids, nil, nil, m.relations, process)
}

// Remove the mapped components from the given entity.
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) Remove(entity Entity) {
	m.world.exchange(entity, nil, m.ids, nil, nil)
}

// RemoveBatch removes the mapped components from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) RemoveBatch(batch *Batch, fn func(entity Entity)) {
	removeBatch(m.world, batch, m.ids, fn)
}

// GetRelation returns the relation target of an entity for the component at the given index.
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) GetRelation(entity Entity, index int) Entity {
	if !m.world.Alive(entity) {
		panic("can't get entity relation target for a dead entity")
	}
	return m.GetRelationUnchecked(entity, index)
}

// GetRelationUnchecked returns the relation target of an entity for the component at the given index.
// In contrast to [Map12.GetRelation], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) GetRelationUnchecked(entity Entity, index int) Entity {
	return m.world.storage.getRelation(entity, m.ids[index])
}

// SetRelations sets relation targets for the given entity.
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) SetRelations(entity Entity, rel ...Relation) {
	// alive check is done in World.setRelations
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	m.world.setRelations(entity, m.relations)
}

// SetRelationsBatch sets relation targets for all entities matching the given batch filter.
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) SetRelationsBatch(batch *Batch, fn func(entity Entity), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, m.relations, 0)
	setRelationsBatch(m.world, batch, fn, m.relations)
}
