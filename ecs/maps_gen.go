package ecs

// Code generated by go generate; DO NOT EDIT.

// Map1 is a mapper to access 1 components of an entity.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Map2] for a usage example.
type Map1[A any] struct {
	mask      bitMask
	ids       []ID
	relations []relationID
	world     *World
	storageA  *componentStorage
}

// New creates a new [Map1]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
//
// See [Map2.New] for an example.
func (_ *Map1[A]) New(world *World) *Map1[A] {
	return NewMap1[A](world)
}

// NewMap1 creates a new [Map1].
func NewMap1[A any](world *World) *Map1[A] {
	ids := []ID{
		ComponentID[A](world),
	}
	return &Map1[A]{
		world:    world,
		ids:      ids,
		mask:     newMask(ids...),
		storageA: &world.storage.components[ids[0].id],
	}
}

// NewEntity creates a new entity with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (m *Map1[A]) NewEntity(a *A, rel ...Relation) Entity {
	return m.NewEntityFn(func(pa *A) {
		*pa = *a
	}, rel...)
}

// NewEntityFn creates a new entity with the mapped component and runs a callback instead of using a component for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map1[A]) NewEntityFn(fn func(*A), rel ...Relation) Entity {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	entity, mask := m.world.newEntity(m.ids, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
		)
	}
	m.world.storage.observers.FireCreateEntityIfHas(entity, mask)
	if len(rel) > 0 {
		m.world.storage.observers.FireCreateEntityRelIfHas(entity, mask)
	}
	return entity
}

// NewBatch creates a batch of new entities with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (m *Map1[A]) NewBatch(count int, a *A, rel ...Relation) {
	m.NewBatchFn(count, func(_ Entity, pa *A) {
		*pa = *a
	}, rel...)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map1[A]) NewBatchFn(count int, fn func(Entity, *A), rel ...Relation) {
	m.world.checkLocked()
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)

	hasCreateObs := m.world.storage.observers.HasObservers(OnCreateEntity)
	hasRelObs := len(rel) > 0 && m.world.storage.observers.HasObservers(OnAddRelations)
	shouldLock := hasCreateObs || hasRelObs || fn != nil
	var lock uint8
	if shouldLock {
		lock = m.world.lock()
	}

	if fn != nil {
		table := &m.world.storage.tables[tableID]
		columnA := m.storageA.columns[tableID]
		for i := range count {
			index := uintptr(start + i)
			fn(
				table.GetEntity(index),
				(*A)(columnA.Get(index)),
			)
		}
	}

	if hasCreateObs {
		table := &m.world.storage.tables[tableID]
		earlyOut := true
		for i := range count {
			index := uintptr(start + i)
			if !m.world.storage.observers.FireCreateEntity(table.GetEntity(index), &m.mask, earlyOut) {
				break
			}
			earlyOut = false
		}
	}
	if hasRelObs {
		table := &m.world.storage.tables[tableID]
		earlyOut := true
		for i := range count {
			index := uintptr(start + i)
			if !m.world.storage.observers.FireCreateEntityRel(table.GetEntity(index), &m.mask, earlyOut) {
				break
			}
			earlyOut = false
		}
	}

	if shouldLock {
		m.world.unlock(lock)
	}
}

// Get returns the mapped components for the given entity.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map1[A]) Get(entity Entity) *A {
	if !m.world.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	index := &m.world.storage.entities[entity.id]
	return get[A](m.storageA, index)
}

// GetUnchecked returns the mapped components for the given entity.
// In contrast to [Map1.Get], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map1[A]) GetUnchecked(entity Entity) *A {
	index := &m.world.storage.entities[entity.id]
	return get[A](m.storageA, index)
}

// HasAll return whether the given entity has all mapped components.
//
// Using [Map1.Get] and checking for nil pointer may be faster
// than calling [Map1.HasAll] and [Map1.Get] subsequently.
func (m *Map1[A]) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	index := m.world.storage.entities[entity.id]
	return m.storageA.columns[index.table] != nil
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map1[A]) Add(entity Entity, a *A, rel ...Relation) {
	m.AddFn(entity, func(pa *A) {
		*pa = *a
	}, rel...)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map1[A]) AddFn(entity Entity, fn func(*A), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	oldMask, newMask := m.world.add(entity, m.ids, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
		)
	}
	m.world.storage.observers.FireAddIfHas(OnAddComponents, entity, oldMask, newMask)
	if len(rel) > 0 {
		m.world.storage.observers.FireAddIfHas(OnAddRelations, entity, oldMask, newMask)
	}
}

// Set the mapped components of the given entity to the given values.
// Requires the entity to already have all the mapped components.
//
// Triggers an OnSetComponents event, which is not the case when assigning by
// pointer dereference or assigning to fields. This can be used to notify observers
// about component updates.
//
// This is not a component operation, so it can be performed on a locked world.
func (m *Map1[A]) Set(entity Entity, a *A) {
	if !m.world.Alive(entity) {
		panic("can't set components of a dead entity")
	}
	m.world.storage.checkHasComponent(entity, m.ids[0])

	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)
	*(*A)(m.storageA.columns[index.table].Get(row)) = *a

	if m.world.storage.observers.HasObservers(OnSetComponents) {
		newMask := &m.world.storage.archetypes[m.world.storage.tables[index.table].archetype].mask
		m.world.storage.observers.FireSet(entity, &m.mask, newMask)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map1[A]) AddBatch(batch Batch, a *A, rel ...Relation) {
	m.AddBatchFn(batch, func(_ Entity, pa *A) {
		*pa = *a
	}, rel...)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map1[A]) AddBatchFn(batch Batch, fn func(Entity, *A), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)

	var process func(tableID tableID, start, len uint32)
	if fn != nil {
		process = func(tableID tableID, start, len uint32) {
			table := &m.world.storage.tables[tableID]
			columnA := m.storageA.columns[tableID]

			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
				)
			}
		}
	}
	m.world.exchangeBatch(&batch, m.ids, nil, m.relations, process)
}

// Remove the mapped components from the given entity.
func (m *Map1[A]) Remove(entity Entity) {
	m.world.remove(entity, m.ids)
}

// RemoveBatch removes the mapped components from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map1[A]) RemoveBatch(batch Batch, fn func(entity Entity)) {
	removeBatch(m.world, &batch, m.ids, fn)
}

// GetRelation returns the relation target of an entity for the component at the given index.
func (m *Map1[A]) GetRelation(entity Entity, index int) Entity {
	if !m.world.Alive(entity) {
		panic("can't get entity relation target for a dead entity")
	}
	return m.GetRelationUnchecked(entity, index)
}

// GetRelationUnchecked returns the relation target of an entity for the component at the given index.
// In contrast to [Map1.GetRelation], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map1[A]) GetRelationUnchecked(entity Entity, index int) Entity {
	return m.world.storage.getRelation(entity, m.ids[index])
}

// SetRelations sets relation targets for the given entity.
func (m *Map1[A]) SetRelations(entity Entity, rel ...Relation) {
	// alive check is done in World.setRelations
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	m.world.setRelations(entity, m.relations)
}

// SetRelationsBatch sets relation targets for all entities matching the given batch filter.
func (m *Map1[A]) SetRelationsBatch(batch Batch, fn func(entity Entity), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	setRelationsBatch(m.world, &batch, fn, m.relations)
}

// Map2 is a mapper to access 2 components of an entity.
//
// Instances should be created during initialization and stored, e.g. in systems.
type Map2[A any, B any] struct {
	mask      bitMask
	ids       []ID
	relations []relationID
	world     *World
	storageA  *componentStorage
	storageB  *componentStorage
}

// New creates a new [Map2]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
func (_ *Map2[A, B]) New(world *World) *Map2[A, B] {
	return NewMap2[A, B](world)
}

// NewMap2 creates a new [Map2].
func NewMap2[A any, B any](world *World) *Map2[A, B] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
	}
	return &Map2[A, B]{
		world:    world,
		ids:      ids,
		mask:     newMask(ids...),
		storageA: &world.storage.components[ids[0].id],
		storageB: &world.storage.components[ids[1].id],
	}
}

// NewEntity creates a new entity with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (m *Map2[A, B]) NewEntity(a *A, b *B, rel ...Relation) Entity {
	return m.NewEntityFn(func(pa *A, pb *B) {
		*pa = *a
		*pb = *b
	}, rel...)
}

// NewEntityFn creates a new entity with the mapped component and runs a callback instead of using a component for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map2[A, B]) NewEntityFn(fn func(*A, *B), rel ...Relation) Entity {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	entity, mask := m.world.newEntity(m.ids, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
		)
	}
	m.world.storage.observers.FireCreateEntityIfHas(entity, mask)
	if len(rel) > 0 {
		m.world.storage.observers.FireCreateEntityRelIfHas(entity, mask)
	}
	return entity
}

// NewBatch creates a batch of new entities with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (m *Map2[A, B]) NewBatch(count int, a *A, b *B, rel ...Relation) {
	m.NewBatchFn(count, func(_ Entity, pa *A, pb *B) {
		*pa = *a
		*pb = *b
	}, rel...)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map2[A, B]) NewBatchFn(count int, fn func(Entity, *A, *B), rel ...Relation) {
	m.world.checkLocked()
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)

	hasCreateObs := m.world.storage.observers.HasObservers(OnCreateEntity)
	hasRelObs := len(rel) > 0 && m.world.storage.observers.HasObservers(OnAddRelations)
	shouldLock := hasCreateObs || hasRelObs || fn != nil
	var lock uint8
	if shouldLock {
		lock = m.world.lock()
	}

	if fn != nil {
		table := &m.world.storage.tables[tableID]
		columnA := m.storageA.columns[tableID]
		columnB := m.storageB.columns[tableID]
		for i := range count {
			index := uintptr(start + i)
			fn(
				table.GetEntity(index),
				(*A)(columnA.Get(index)),
				(*B)(columnB.Get(index)),
			)
		}
	}

	if hasCreateObs {
		table := &m.world.storage.tables[tableID]
		earlyOut := true
		for i := range count {
			index := uintptr(start + i)
			if !m.world.storage.observers.FireCreateEntity(table.GetEntity(index), &m.mask, earlyOut) {
				break
			}
			earlyOut = false
		}
	}
	if hasRelObs {
		table := &m.world.storage.tables[tableID]
		earlyOut := true
		for i := range count {
			index := uintptr(start + i)
			if !m.world.storage.observers.FireCreateEntityRel(table.GetEntity(index), &m.mask, earlyOut) {
				break
			}
			earlyOut = false
		}
	}

	if shouldLock {
		m.world.unlock(lock)
	}
}

// Get returns the mapped components for the given entity.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map2[A, B]) Get(entity Entity) (*A, *B) {
	if !m.world.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	index := &m.world.storage.entities[entity.id]
	return get[A](m.storageA, index), get[B](m.storageB, index)
}

// GetUnchecked returns the mapped components for the given entity.
// In contrast to [Map2.Get], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map2[A, B]) GetUnchecked(entity Entity) (*A, *B) {
	index := &m.world.storage.entities[entity.id]
	return get[A](m.storageA, index), get[B](m.storageB, index)
}

// HasAll return whether the given entity has all mapped components.
//
// Using [Map2.Get] and checking for nil pointer may be faster
// than calling [Map2.HasAll] and [Map2.Get] subsequently.
func (m *Map2[A, B]) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	index := m.world.storage.entities[entity.id]
	return m.storageA.columns[index.table] != nil &&
		m.storageB.columns[index.table] != nil
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map2[A, B]) Add(entity Entity, a *A, b *B, rel ...Relation) {
	m.AddFn(entity, func(pa *A, pb *B) {
		*pa = *a
		*pb = *b
	}, rel...)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map2[A, B]) AddFn(entity Entity, fn func(*A, *B), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	oldMask, newMask := m.world.add(entity, m.ids, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
		)
	}
	m.world.storage.observers.FireAddIfHas(OnAddComponents, entity, oldMask, newMask)
	if len(rel) > 0 {
		m.world.storage.observers.FireAddIfHas(OnAddRelations, entity, oldMask, newMask)
	}
}

// Set the mapped components of the given entity to the given values.
// Requires the entity to already have all the mapped components.
//
// Triggers an OnSetComponents event, which is not the case when assigning by
// pointer dereference or assigning to fields. This can be used to notify observers
// about component updates.
//
// This is not a component operation, so it can be performed on a locked world.
func (m *Map2[A, B]) Set(entity Entity, a *A, b *B) {
	if !m.world.Alive(entity) {
		panic("can't set components of a dead entity")
	}
	m.world.storage.checkHasComponent(entity, m.ids[0])
	m.world.storage.checkHasComponent(entity, m.ids[1])

	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)
	*(*A)(m.storageA.columns[index.table].Get(row)) = *a
	*(*B)(m.storageB.columns[index.table].Get(row)) = *b

	if m.world.storage.observers.HasObservers(OnSetComponents) {
		newMask := &m.world.storage.archetypes[m.world.storage.tables[index.table].archetype].mask
		m.world.storage.observers.FireSet(entity, &m.mask, newMask)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map2[A, B]) AddBatch(batch Batch, a *A, b *B, rel ...Relation) {
	m.AddBatchFn(batch, func(_ Entity, pa *A, pb *B) {
		*pa = *a
		*pb = *b
	}, rel...)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map2[A, B]) AddBatchFn(batch Batch, fn func(Entity, *A, *B), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)

	var process func(tableID tableID, start, len uint32)
	if fn != nil {
		process = func(tableID tableID, start, len uint32) {
			table := &m.world.storage.tables[tableID]
			columnA := m.storageA.columns[tableID]
			columnB := m.storageB.columns[tableID]

			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
				)
			}
		}
	}
	m.world.exchangeBatch(&batch, m.ids, nil, m.relations, process)
}

// Remove the mapped components from the given entity.
func (m *Map2[A, B]) Remove(entity Entity) {
	m.world.remove(entity, m.ids)
}

// RemoveBatch removes the mapped components from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map2[A, B]) RemoveBatch(batch Batch, fn func(entity Entity)) {
	removeBatch(m.world, &batch, m.ids, fn)
}

// GetRelation returns the relation target of an entity for the component at the given index.
func (m *Map2[A, B]) GetRelation(entity Entity, index int) Entity {
	if !m.world.Alive(entity) {
		panic("can't get entity relation target for a dead entity")
	}
	return m.GetRelationUnchecked(entity, index)
}

// GetRelationUnchecked returns the relation target of an entity for the component at the given index.
// In contrast to [Map2.GetRelation], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map2[A, B]) GetRelationUnchecked(entity Entity, index int) Entity {
	return m.world.storage.getRelation(entity, m.ids[index])
}

// SetRelations sets relation targets for the given entity.
func (m *Map2[A, B]) SetRelations(entity Entity, rel ...Relation) {
	// alive check is done in World.setRelations
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	m.world.setRelations(entity, m.relations)
}

// SetRelationsBatch sets relation targets for all entities matching the given batch filter.
func (m *Map2[A, B]) SetRelationsBatch(batch Batch, fn func(entity Entity), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	setRelationsBatch(m.world, &batch, fn, m.relations)
}

// Map3 is a mapper to access 3 components of an entity.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Map2] for a usage example.
type Map3[A any, B any, C any] struct {
	mask      bitMask
	ids       []ID
	relations []relationID
	world     *World
	storageA  *componentStorage
	storageB  *componentStorage
	storageC  *componentStorage
}

// New creates a new [Map3]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
//
// See [Map2.New] for an example.
func (_ *Map3[A, B, C]) New(world *World) *Map3[A, B, C] {
	return NewMap3[A, B, C](world)
}

// NewMap3 creates a new [Map3].
func NewMap3[A any, B any, C any](world *World) *Map3[A, B, C] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
	}
	return &Map3[A, B, C]{
		world:    world,
		ids:      ids,
		mask:     newMask(ids...),
		storageA: &world.storage.components[ids[0].id],
		storageB: &world.storage.components[ids[1].id],
		storageC: &world.storage.components[ids[2].id],
	}
}

// NewEntity creates a new entity with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (m *Map3[A, B, C]) NewEntity(a *A, b *B, c *C, rel ...Relation) Entity {
	return m.NewEntityFn(func(pa *A, pb *B, pc *C) {
		*pa = *a
		*pb = *b
		*pc = *c
	}, rel...)
}

// NewEntityFn creates a new entity with the mapped component and runs a callback instead of using a component for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map3[A, B, C]) NewEntityFn(fn func(*A, *B, *C), rel ...Relation) Entity {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	entity, mask := m.world.newEntity(m.ids, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
		)
	}
	m.world.storage.observers.FireCreateEntityIfHas(entity, mask)
	if len(rel) > 0 {
		m.world.storage.observers.FireCreateEntityRelIfHas(entity, mask)
	}
	return entity
}

// NewBatch creates a batch of new entities with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (m *Map3[A, B, C]) NewBatch(count int, a *A, b *B, c *C, rel ...Relation) {
	m.NewBatchFn(count, func(_ Entity, pa *A, pb *B, pc *C) {
		*pa = *a
		*pb = *b
		*pc = *c
	}, rel...)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map3[A, B, C]) NewBatchFn(count int, fn func(Entity, *A, *B, *C), rel ...Relation) {
	m.world.checkLocked()
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)

	hasCreateObs := m.world.storage.observers.HasObservers(OnCreateEntity)
	hasRelObs := len(rel) > 0 && m.world.storage.observers.HasObservers(OnAddRelations)
	shouldLock := hasCreateObs || hasRelObs || fn != nil
	var lock uint8
	if shouldLock {
		lock = m.world.lock()
	}

	if fn != nil {
		table := &m.world.storage.tables[tableID]
		columnA := m.storageA.columns[tableID]
		columnB := m.storageB.columns[tableID]
		columnC := m.storageC.columns[tableID]
		for i := range count {
			index := uintptr(start + i)
			fn(
				table.GetEntity(index),
				(*A)(columnA.Get(index)),
				(*B)(columnB.Get(index)),
				(*C)(columnC.Get(index)),
			)
		}
	}

	if hasCreateObs {
		table := &m.world.storage.tables[tableID]
		earlyOut := true
		for i := range count {
			index := uintptr(start + i)
			if !m.world.storage.observers.FireCreateEntity(table.GetEntity(index), &m.mask, earlyOut) {
				break
			}
			earlyOut = false
		}
	}
	if hasRelObs {
		table := &m.world.storage.tables[tableID]
		earlyOut := true
		for i := range count {
			index := uintptr(start + i)
			if !m.world.storage.observers.FireCreateEntityRel(table.GetEntity(index), &m.mask, earlyOut) {
				break
			}
			earlyOut = false
		}
	}

	if shouldLock {
		m.world.unlock(lock)
	}
}

// Get returns the mapped components for the given entity.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map3[A, B, C]) Get(entity Entity) (*A, *B, *C) {
	if !m.world.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	index := &m.world.storage.entities[entity.id]
	return get[A](m.storageA, index), get[B](m.storageB, index), get[C](m.storageC, index)
}

// GetUnchecked returns the mapped components for the given entity.
// In contrast to [Map3.Get], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map3[A, B, C]) GetUnchecked(entity Entity) (*A, *B, *C) {
	index := &m.world.storage.entities[entity.id]
	return get[A](m.storageA, index), get[B](m.storageB, index), get[C](m.storageC, index)
}

// HasAll return whether the given entity has all mapped components.
//
// Using [Map3.Get] and checking for nil pointer may be faster
// than calling [Map3.HasAll] and [Map3.Get] subsequently.
func (m *Map3[A, B, C]) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	index := m.world.storage.entities[entity.id]
	return m.storageA.columns[index.table] != nil &&
		m.storageB.columns[index.table] != nil &&
		m.storageC.columns[index.table] != nil
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map3[A, B, C]) Add(entity Entity, a *A, b *B, c *C, rel ...Relation) {
	m.AddFn(entity, func(pa *A, pb *B, pc *C) {
		*pa = *a
		*pb = *b
		*pc = *c
	}, rel...)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map3[A, B, C]) AddFn(entity Entity, fn func(*A, *B, *C), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	oldMask, newMask := m.world.add(entity, m.ids, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
		)
	}
	m.world.storage.observers.FireAddIfHas(OnAddComponents, entity, oldMask, newMask)
	if len(rel) > 0 {
		m.world.storage.observers.FireAddIfHas(OnAddRelations, entity, oldMask, newMask)
	}
}

// Set the mapped components of the given entity to the given values.
// Requires the entity to already have all the mapped components.
//
// Triggers an OnSetComponents event, which is not the case when assigning by
// pointer dereference or assigning to fields. This can be used to notify observers
// about component updates.
//
// This is not a component operation, so it can be performed on a locked world.
func (m *Map3[A, B, C]) Set(entity Entity, a *A, b *B, c *C) {
	if !m.world.Alive(entity) {
		panic("can't set components of a dead entity")
	}
	m.world.storage.checkHasComponent(entity, m.ids[0])
	m.world.storage.checkHasComponent(entity, m.ids[1])
	m.world.storage.checkHasComponent(entity, m.ids[2])

	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)
	*(*A)(m.storageA.columns[index.table].Get(row)) = *a
	*(*B)(m.storageB.columns[index.table].Get(row)) = *b
	*(*C)(m.storageC.columns[index.table].Get(row)) = *c

	if m.world.storage.observers.HasObservers(OnSetComponents) {
		newMask := &m.world.storage.archetypes[m.world.storage.tables[index.table].archetype].mask
		m.world.storage.observers.FireSet(entity, &m.mask, newMask)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map3[A, B, C]) AddBatch(batch Batch, a *A, b *B, c *C, rel ...Relation) {
	m.AddBatchFn(batch, func(_ Entity, pa *A, pb *B, pc *C) {
		*pa = *a
		*pb = *b
		*pc = *c
	}, rel...)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map3[A, B, C]) AddBatchFn(batch Batch, fn func(Entity, *A, *B, *C), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)

	var process func(tableID tableID, start, len uint32)
	if fn != nil {
		process = func(tableID tableID, start, len uint32) {
			table := &m.world.storage.tables[tableID]
			columnA := m.storageA.columns[tableID]
			columnB := m.storageB.columns[tableID]
			columnC := m.storageC.columns[tableID]

			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
				)
			}
		}
	}
	m.world.exchangeBatch(&batch, m.ids, nil, m.relations, process)
}

// Remove the mapped components from the given entity.
func (m *Map3[A, B, C]) Remove(entity Entity) {
	m.world.remove(entity, m.ids)
}

// RemoveBatch removes the mapped components from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map3[A, B, C]) RemoveBatch(batch Batch, fn func(entity Entity)) {
	removeBatch(m.world, &batch, m.ids, fn)
}

// GetRelation returns the relation target of an entity for the component at the given index.
func (m *Map3[A, B, C]) GetRelation(entity Entity, index int) Entity {
	if !m.world.Alive(entity) {
		panic("can't get entity relation target for a dead entity")
	}
	return m.GetRelationUnchecked(entity, index)
}

// GetRelationUnchecked returns the relation target of an entity for the component at the given index.
// In contrast to [Map3.GetRelation], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map3[A, B, C]) GetRelationUnchecked(entity Entity, index int) Entity {
	return m.world.storage.getRelation(entity, m.ids[index])
}

// SetRelations sets relation targets for the given entity.
func (m *Map3[A, B, C]) SetRelations(entity Entity, rel ...Relation) {
	// alive check is done in World.setRelations
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	m.world.setRelations(entity, m.relations)
}

// SetRelationsBatch sets relation targets for all entities matching the given batch filter.
func (m *Map3[A, B, C]) SetRelationsBatch(batch Batch, fn func(entity Entity), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	setRelationsBatch(m.world, &batch, fn, m.relations)
}

// Map4 is a mapper to access 4 components of an entity.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Map2] for a usage example.
type Map4[A any, B any, C any, D any] struct {
	mask      bitMask
	ids       []ID
	relations []relationID
	world     *World
	storageA  *componentStorage
	storageB  *componentStorage
	storageC  *componentStorage
	storageD  *componentStorage
}

// New creates a new [Map4]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
//
// See [Map2.New] for an example.
func (_ *Map4[A, B, C, D]) New(world *World) *Map4[A, B, C, D] {
	return NewMap4[A, B, C, D](world)
}

// NewMap4 creates a new [Map4].
func NewMap4[A any, B any, C any, D any](world *World) *Map4[A, B, C, D] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
	}
	return &Map4[A, B, C, D]{
		world:    world,
		ids:      ids,
		mask:     newMask(ids...),
		storageA: &world.storage.components[ids[0].id],
		storageB: &world.storage.components[ids[1].id],
		storageC: &world.storage.components[ids[2].id],
		storageD: &world.storage.components[ids[3].id],
	}
}

// NewEntity creates a new entity with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (m *Map4[A, B, C, D]) NewEntity(a *A, b *B, c *C, d *D, rel ...Relation) Entity {
	return m.NewEntityFn(func(pa *A, pb *B, pc *C, pd *D) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
	}, rel...)
}

// NewEntityFn creates a new entity with the mapped component and runs a callback instead of using a component for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map4[A, B, C, D]) NewEntityFn(fn func(*A, *B, *C, *D), rel ...Relation) Entity {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	entity, mask := m.world.newEntity(m.ids, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
		)
	}
	m.world.storage.observers.FireCreateEntityIfHas(entity, mask)
	if len(rel) > 0 {
		m.world.storage.observers.FireCreateEntityRelIfHas(entity, mask)
	}
	return entity
}

// NewBatch creates a batch of new entities with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (m *Map4[A, B, C, D]) NewBatch(count int, a *A, b *B, c *C, d *D, rel ...Relation) {
	m.NewBatchFn(count, func(_ Entity, pa *A, pb *B, pc *C, pd *D) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
	}, rel...)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map4[A, B, C, D]) NewBatchFn(count int, fn func(Entity, *A, *B, *C, *D), rel ...Relation) {
	m.world.checkLocked()
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)

	hasCreateObs := m.world.storage.observers.HasObservers(OnCreateEntity)
	hasRelObs := len(rel) > 0 && m.world.storage.observers.HasObservers(OnAddRelations)
	shouldLock := hasCreateObs || hasRelObs || fn != nil
	var lock uint8
	if shouldLock {
		lock = m.world.lock()
	}

	if fn != nil {
		table := &m.world.storage.tables[tableID]
		columnA := m.storageA.columns[tableID]
		columnB := m.storageB.columns[tableID]
		columnC := m.storageC.columns[tableID]
		columnD := m.storageD.columns[tableID]
		for i := range count {
			index := uintptr(start + i)
			fn(
				table.GetEntity(index),
				(*A)(columnA.Get(index)),
				(*B)(columnB.Get(index)),
				(*C)(columnC.Get(index)),
				(*D)(columnD.Get(index)),
			)
		}
	}

	if hasCreateObs {
		table := &m.world.storage.tables[tableID]
		earlyOut := true
		for i := range count {
			index := uintptr(start + i)
			if !m.world.storage.observers.FireCreateEntity(table.GetEntity(index), &m.mask, earlyOut) {
				break
			}
			earlyOut = false
		}
	}
	if hasRelObs {
		table := &m.world.storage.tables[tableID]
		earlyOut := true
		for i := range count {
			index := uintptr(start + i)
			if !m.world.storage.observers.FireCreateEntityRel(table.GetEntity(index), &m.mask, earlyOut) {
				break
			}
			earlyOut = false
		}
	}

	if shouldLock {
		m.world.unlock(lock)
	}
}

// Get returns the mapped components for the given entity.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map4[A, B, C, D]) Get(entity Entity) (*A, *B, *C, *D) {
	if !m.world.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	index := &m.world.storage.entities[entity.id]
	return get[A](m.storageA, index), get[B](m.storageB, index), get[C](m.storageC, index), get[D](m.storageD, index)
}

// GetUnchecked returns the mapped components for the given entity.
// In contrast to [Map4.Get], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map4[A, B, C, D]) GetUnchecked(entity Entity) (*A, *B, *C, *D) {
	index := &m.world.storage.entities[entity.id]
	return get[A](m.storageA, index), get[B](m.storageB, index), get[C](m.storageC, index), get[D](m.storageD, index)
}

// HasAll return whether the given entity has all mapped components.
//
// Using [Map4.Get] and checking for nil pointer may be faster
// than calling [Map4.HasAll] and [Map4.Get] subsequently.
func (m *Map4[A, B, C, D]) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	index := m.world.storage.entities[entity.id]
	return m.storageA.columns[index.table] != nil &&
		m.storageB.columns[index.table] != nil &&
		m.storageC.columns[index.table] != nil &&
		m.storageD.columns[index.table] != nil
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map4[A, B, C, D]) Add(entity Entity, a *A, b *B, c *C, d *D, rel ...Relation) {
	m.AddFn(entity, func(pa *A, pb *B, pc *C, pd *D) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
	}, rel...)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map4[A, B, C, D]) AddFn(entity Entity, fn func(*A, *B, *C, *D), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	oldMask, newMask := m.world.add(entity, m.ids, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
		)
	}
	m.world.storage.observers.FireAddIfHas(OnAddComponents, entity, oldMask, newMask)
	if len(rel) > 0 {
		m.world.storage.observers.FireAddIfHas(OnAddRelations, entity, oldMask, newMask)
	}
}

// Set the mapped components of the given entity to the given values.
// Requires the entity to already have all the mapped components.
//
// Triggers an OnSetComponents event, which is not the case when assigning by
// pointer dereference or assigning to fields. This can be used to notify observers
// about component updates.
//
// This is not a component operation, so it can be performed on a locked world.
func (m *Map4[A, B, C, D]) Set(entity Entity, a *A, b *B, c *C, d *D) {
	if !m.world.Alive(entity) {
		panic("can't set components of a dead entity")
	}
	m.world.storage.checkHasComponent(entity, m.ids[0])
	m.world.storage.checkHasComponent(entity, m.ids[1])
	m.world.storage.checkHasComponent(entity, m.ids[2])
	m.world.storage.checkHasComponent(entity, m.ids[3])

	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)
	*(*A)(m.storageA.columns[index.table].Get(row)) = *a
	*(*B)(m.storageB.columns[index.table].Get(row)) = *b
	*(*C)(m.storageC.columns[index.table].Get(row)) = *c
	*(*D)(m.storageD.columns[index.table].Get(row)) = *d

	if m.world.storage.observers.HasObservers(OnSetComponents) {
		newMask := &m.world.storage.archetypes[m.world.storage.tables[index.table].archetype].mask
		m.world.storage.observers.FireSet(entity, &m.mask, newMask)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map4[A, B, C, D]) AddBatch(batch Batch, a *A, b *B, c *C, d *D, rel ...Relation) {
	m.AddBatchFn(batch, func(_ Entity, pa *A, pb *B, pc *C, pd *D) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
	}, rel...)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map4[A, B, C, D]) AddBatchFn(batch Batch, fn func(Entity, *A, *B, *C, *D), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)

	var process func(tableID tableID, start, len uint32)
	if fn != nil {
		process = func(tableID tableID, start, len uint32) {
			table := &m.world.storage.tables[tableID]
			columnA := m.storageA.columns[tableID]
			columnB := m.storageB.columns[tableID]
			columnC := m.storageC.columns[tableID]
			columnD := m.storageD.columns[tableID]

			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
					(*D)(columnD.Get(index)),
				)
			}
		}
	}
	m.world.exchangeBatch(&batch, m.ids, nil, m.relations, process)
}

// Remove the mapped components from the given entity.
func (m *Map4[A, B, C, D]) Remove(entity Entity) {
	m.world.remove(entity, m.ids)
}

// RemoveBatch removes the mapped components from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map4[A, B, C, D]) RemoveBatch(batch Batch, fn func(entity Entity)) {
	removeBatch(m.world, &batch, m.ids, fn)
}

// GetRelation returns the relation target of an entity for the component at the given index.
func (m *Map4[A, B, C, D]) GetRelation(entity Entity, index int) Entity {
	if !m.world.Alive(entity) {
		panic("can't get entity relation target for a dead entity")
	}
	return m.GetRelationUnchecked(entity, index)
}

// GetRelationUnchecked returns the relation target of an entity for the component at the given index.
// In contrast to [Map4.GetRelation], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map4[A, B, C, D]) GetRelationUnchecked(entity Entity, index int) Entity {
	return m.world.storage.getRelation(entity, m.ids[index])
}

// SetRelations sets relation targets for the given entity.
func (m *Map4[A, B, C, D]) SetRelations(entity Entity, rel ...Relation) {
	// alive check is done in World.setRelations
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	m.world.setRelations(entity, m.relations)
}

// SetRelationsBatch sets relation targets for all entities matching the given batch filter.
func (m *Map4[A, B, C, D]) SetRelationsBatch(batch Batch, fn func(entity Entity), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	setRelationsBatch(m.world, &batch, fn, m.relations)
}

// Map5 is a mapper to access 5 components of an entity.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Map2] for a usage example.
type Map5[A any, B any, C any, D any, E any] struct {
	mask      bitMask
	ids       []ID
	relations []relationID
	world     *World
	storageA  *componentStorage
	storageB  *componentStorage
	storageC  *componentStorage
	storageD  *componentStorage
	storageE  *componentStorage
}

// New creates a new [Map5]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
//
// See [Map2.New] for an example.
func (_ *Map5[A, B, C, D, E]) New(world *World) *Map5[A, B, C, D, E] {
	return NewMap5[A, B, C, D, E](world)
}

// NewMap5 creates a new [Map5].
func NewMap5[A any, B any, C any, D any, E any](world *World) *Map5[A, B, C, D, E] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
	}
	return &Map5[A, B, C, D, E]{
		world:    world,
		ids:      ids,
		mask:     newMask(ids...),
		storageA: &world.storage.components[ids[0].id],
		storageB: &world.storage.components[ids[1].id],
		storageC: &world.storage.components[ids[2].id],
		storageD: &world.storage.components[ids[3].id],
		storageE: &world.storage.components[ids[4].id],
	}
}

// NewEntity creates a new entity with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (m *Map5[A, B, C, D, E]) NewEntity(a *A, b *B, c *C, d *D, e *E, rel ...Relation) Entity {
	return m.NewEntityFn(func(pa *A, pb *B, pc *C, pd *D, pe *E) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
	}, rel...)
}

// NewEntityFn creates a new entity with the mapped component and runs a callback instead of using a component for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map5[A, B, C, D, E]) NewEntityFn(fn func(*A, *B, *C, *D, *E), rel ...Relation) Entity {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	entity, mask := m.world.newEntity(m.ids, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
		)
	}
	m.world.storage.observers.FireCreateEntityIfHas(entity, mask)
	if len(rel) > 0 {
		m.world.storage.observers.FireCreateEntityRelIfHas(entity, mask)
	}
	return entity
}

// NewBatch creates a batch of new entities with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (m *Map5[A, B, C, D, E]) NewBatch(count int, a *A, b *B, c *C, d *D, e *E, rel ...Relation) {
	m.NewBatchFn(count, func(_ Entity, pa *A, pb *B, pc *C, pd *D, pe *E) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
	}, rel...)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map5[A, B, C, D, E]) NewBatchFn(count int, fn func(Entity, *A, *B, *C, *D, *E), rel ...Relation) {
	m.world.checkLocked()
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)

	hasCreateObs := m.world.storage.observers.HasObservers(OnCreateEntity)
	hasRelObs := len(rel) > 0 && m.world.storage.observers.HasObservers(OnAddRelations)
	shouldLock := hasCreateObs || hasRelObs || fn != nil
	var lock uint8
	if shouldLock {
		lock = m.world.lock()
	}

	if fn != nil {
		table := &m.world.storage.tables[tableID]
		columnA := m.storageA.columns[tableID]
		columnB := m.storageB.columns[tableID]
		columnC := m.storageC.columns[tableID]
		columnD := m.storageD.columns[tableID]
		columnE := m.storageE.columns[tableID]
		for i := range count {
			index := uintptr(start + i)
			fn(
				table.GetEntity(index),
				(*A)(columnA.Get(index)),
				(*B)(columnB.Get(index)),
				(*C)(columnC.Get(index)),
				(*D)(columnD.Get(index)),
				(*E)(columnE.Get(index)),
			)
		}
	}

	if hasCreateObs {
		table := &m.world.storage.tables[tableID]
		earlyOut := true
		for i := range count {
			index := uintptr(start + i)
			if !m.world.storage.observers.FireCreateEntity(table.GetEntity(index), &m.mask, earlyOut) {
				break
			}
			earlyOut = false
		}
	}
	if hasRelObs {
		table := &m.world.storage.tables[tableID]
		earlyOut := true
		for i := range count {
			index := uintptr(start + i)
			if !m.world.storage.observers.FireCreateEntityRel(table.GetEntity(index), &m.mask, earlyOut) {
				break
			}
			earlyOut = false
		}
	}

	if shouldLock {
		m.world.unlock(lock)
	}
}

// Get returns the mapped components for the given entity.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map5[A, B, C, D, E]) Get(entity Entity) (*A, *B, *C, *D, *E) {
	if !m.world.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	index := &m.world.storage.entities[entity.id]
	return get[A](m.storageA, index), get[B](m.storageB, index), get[C](m.storageC, index), get[D](m.storageD, index), get[E](m.storageE, index)
}

// GetUnchecked returns the mapped components for the given entity.
// In contrast to [Map5.Get], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map5[A, B, C, D, E]) GetUnchecked(entity Entity) (*A, *B, *C, *D, *E) {
	index := &m.world.storage.entities[entity.id]
	return get[A](m.storageA, index), get[B](m.storageB, index), get[C](m.storageC, index), get[D](m.storageD, index), get[E](m.storageE, index)
}

// HasAll return whether the given entity has all mapped components.
//
// Using [Map5.Get] and checking for nil pointer may be faster
// than calling [Map5.HasAll] and [Map5.Get] subsequently.
func (m *Map5[A, B, C, D, E]) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	index := m.world.storage.entities[entity.id]
	return m.storageA.columns[index.table] != nil &&
		m.storageB.columns[index.table] != nil &&
		m.storageC.columns[index.table] != nil &&
		m.storageD.columns[index.table] != nil &&
		m.storageE.columns[index.table] != nil
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map5[A, B, C, D, E]) Add(entity Entity, a *A, b *B, c *C, d *D, e *E, rel ...Relation) {
	m.AddFn(entity, func(pa *A, pb *B, pc *C, pd *D, pe *E) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
	}, rel...)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map5[A, B, C, D, E]) AddFn(entity Entity, fn func(*A, *B, *C, *D, *E), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	oldMask, newMask := m.world.add(entity, m.ids, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
		)
	}
	m.world.storage.observers.FireAddIfHas(OnAddComponents, entity, oldMask, newMask)
	if len(rel) > 0 {
		m.world.storage.observers.FireAddIfHas(OnAddRelations, entity, oldMask, newMask)
	}
}

// Set the mapped components of the given entity to the given values.
// Requires the entity to already have all the mapped components.
//
// Triggers an OnSetComponents event, which is not the case when assigning by
// pointer dereference or assigning to fields. This can be used to notify observers
// about component updates.
//
// This is not a component operation, so it can be performed on a locked world.
func (m *Map5[A, B, C, D, E]) Set(entity Entity, a *A, b *B, c *C, d *D, e *E) {
	if !m.world.Alive(entity) {
		panic("can't set components of a dead entity")
	}
	m.world.storage.checkHasComponent(entity, m.ids[0])
	m.world.storage.checkHasComponent(entity, m.ids[1])
	m.world.storage.checkHasComponent(entity, m.ids[2])
	m.world.storage.checkHasComponent(entity, m.ids[3])
	m.world.storage.checkHasComponent(entity, m.ids[4])

	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)
	*(*A)(m.storageA.columns[index.table].Get(row)) = *a
	*(*B)(m.storageB.columns[index.table].Get(row)) = *b
	*(*C)(m.storageC.columns[index.table].Get(row)) = *c
	*(*D)(m.storageD.columns[index.table].Get(row)) = *d
	*(*E)(m.storageE.columns[index.table].Get(row)) = *e

	if m.world.storage.observers.HasObservers(OnSetComponents) {
		newMask := &m.world.storage.archetypes[m.world.storage.tables[index.table].archetype].mask
		m.world.storage.observers.FireSet(entity, &m.mask, newMask)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map5[A, B, C, D, E]) AddBatch(batch Batch, a *A, b *B, c *C, d *D, e *E, rel ...Relation) {
	m.AddBatchFn(batch, func(_ Entity, pa *A, pb *B, pc *C, pd *D, pe *E) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
	}, rel...)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map5[A, B, C, D, E]) AddBatchFn(batch Batch, fn func(Entity, *A, *B, *C, *D, *E), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)

	var process func(tableID tableID, start, len uint32)
	if fn != nil {
		process = func(tableID tableID, start, len uint32) {
			table := &m.world.storage.tables[tableID]
			columnA := m.storageA.columns[tableID]
			columnB := m.storageB.columns[tableID]
			columnC := m.storageC.columns[tableID]
			columnD := m.storageD.columns[tableID]
			columnE := m.storageE.columns[tableID]

			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
					(*D)(columnD.Get(index)),
					(*E)(columnE.Get(index)),
				)
			}
		}
	}
	m.world.exchangeBatch(&batch, m.ids, nil, m.relations, process)
}

// Remove the mapped components from the given entity.
func (m *Map5[A, B, C, D, E]) Remove(entity Entity) {
	m.world.remove(entity, m.ids)
}

// RemoveBatch removes the mapped components from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map5[A, B, C, D, E]) RemoveBatch(batch Batch, fn func(entity Entity)) {
	removeBatch(m.world, &batch, m.ids, fn)
}

// GetRelation returns the relation target of an entity for the component at the given index.
func (m *Map5[A, B, C, D, E]) GetRelation(entity Entity, index int) Entity {
	if !m.world.Alive(entity) {
		panic("can't get entity relation target for a dead entity")
	}
	return m.GetRelationUnchecked(entity, index)
}

// GetRelationUnchecked returns the relation target of an entity for the component at the given index.
// In contrast to [Map5.GetRelation], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map5[A, B, C, D, E]) GetRelationUnchecked(entity Entity, index int) Entity {
	return m.world.storage.getRelation(entity, m.ids[index])
}

// SetRelations sets relation targets for the given entity.
func (m *Map5[A, B, C, D, E]) SetRelations(entity Entity, rel ...Relation) {
	// alive check is done in World.setRelations
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	m.world.setRelations(entity, m.relations)
}

// SetRelationsBatch sets relation targets for all entities matching the given batch filter.
func (m *Map5[A, B, C, D, E]) SetRelationsBatch(batch Batch, fn func(entity Entity), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	setRelationsBatch(m.world, &batch, fn, m.relations)
}

// Map6 is a mapper to access 6 components of an entity.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Map2] for a usage example.
type Map6[A any, B any, C any, D any, E any, F any] struct {
	mask      bitMask
	ids       []ID
	relations []relationID
	world     *World
	storageA  *componentStorage
	storageB  *componentStorage
	storageC  *componentStorage
	storageD  *componentStorage
	storageE  *componentStorage
	storageF  *componentStorage
}

// New creates a new [Map6]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
//
// See [Map2.New] for an example.
func (_ *Map6[A, B, C, D, E, F]) New(world *World) *Map6[A, B, C, D, E, F] {
	return NewMap6[A, B, C, D, E, F](world)
}

// NewMap6 creates a new [Map6].
func NewMap6[A any, B any, C any, D any, E any, F any](world *World) *Map6[A, B, C, D, E, F] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
		ComponentID[F](world),
	}
	return &Map6[A, B, C, D, E, F]{
		world:    world,
		ids:      ids,
		mask:     newMask(ids...),
		storageA: &world.storage.components[ids[0].id],
		storageB: &world.storage.components[ids[1].id],
		storageC: &world.storage.components[ids[2].id],
		storageD: &world.storage.components[ids[3].id],
		storageE: &world.storage.components[ids[4].id],
		storageF: &world.storage.components[ids[5].id],
	}
}

// NewEntity creates a new entity with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (m *Map6[A, B, C, D, E, F]) NewEntity(a *A, b *B, c *C, d *D, e *E, f *F, rel ...Relation) Entity {
	return m.NewEntityFn(func(pa *A, pb *B, pc *C, pd *D, pe *E, pf *F) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
	}, rel...)
}

// NewEntityFn creates a new entity with the mapped component and runs a callback instead of using a component for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map6[A, B, C, D, E, F]) NewEntityFn(fn func(*A, *B, *C, *D, *E, *F), rel ...Relation) Entity {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	entity, mask := m.world.newEntity(m.ids, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
		)
	}
	m.world.storage.observers.FireCreateEntityIfHas(entity, mask)
	if len(rel) > 0 {
		m.world.storage.observers.FireCreateEntityRelIfHas(entity, mask)
	}
	return entity
}

// NewBatch creates a batch of new entities with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (m *Map6[A, B, C, D, E, F]) NewBatch(count int, a *A, b *B, c *C, d *D, e *E, f *F, rel ...Relation) {
	m.NewBatchFn(count, func(_ Entity, pa *A, pb *B, pc *C, pd *D, pe *E, pf *F) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
	}, rel...)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map6[A, B, C, D, E, F]) NewBatchFn(count int, fn func(Entity, *A, *B, *C, *D, *E, *F), rel ...Relation) {
	m.world.checkLocked()
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)

	hasCreateObs := m.world.storage.observers.HasObservers(OnCreateEntity)
	hasRelObs := len(rel) > 0 && m.world.storage.observers.HasObservers(OnAddRelations)
	shouldLock := hasCreateObs || hasRelObs || fn != nil
	var lock uint8
	if shouldLock {
		lock = m.world.lock()
	}

	if fn != nil {
		table := &m.world.storage.tables[tableID]
		columnA := m.storageA.columns[tableID]
		columnB := m.storageB.columns[tableID]
		columnC := m.storageC.columns[tableID]
		columnD := m.storageD.columns[tableID]
		columnE := m.storageE.columns[tableID]
		columnF := m.storageF.columns[tableID]
		for i := range count {
			index := uintptr(start + i)
			fn(
				table.GetEntity(index),
				(*A)(columnA.Get(index)),
				(*B)(columnB.Get(index)),
				(*C)(columnC.Get(index)),
				(*D)(columnD.Get(index)),
				(*E)(columnE.Get(index)),
				(*F)(columnF.Get(index)),
			)
		}
	}

	if hasCreateObs {
		table := &m.world.storage.tables[tableID]
		earlyOut := true
		for i := range count {
			index := uintptr(start + i)
			if !m.world.storage.observers.FireCreateEntity(table.GetEntity(index), &m.mask, earlyOut) {
				break
			}
			earlyOut = false
		}
	}
	if hasRelObs {
		table := &m.world.storage.tables[tableID]
		earlyOut := true
		for i := range count {
			index := uintptr(start + i)
			if !m.world.storage.observers.FireCreateEntityRel(table.GetEntity(index), &m.mask, earlyOut) {
				break
			}
			earlyOut = false
		}
	}

	if shouldLock {
		m.world.unlock(lock)
	}
}

// Get returns the mapped components for the given entity.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map6[A, B, C, D, E, F]) Get(entity Entity) (*A, *B, *C, *D, *E, *F) {
	if !m.world.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	index := &m.world.storage.entities[entity.id]
	return get[A](m.storageA, index), get[B](m.storageB, index), get[C](m.storageC, index), get[D](m.storageD, index), get[E](m.storageE, index), get[F](m.storageF, index)
}

// GetUnchecked returns the mapped components for the given entity.
// In contrast to [Map6.Get], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map6[A, B, C, D, E, F]) GetUnchecked(entity Entity) (*A, *B, *C, *D, *E, *F) {
	index := &m.world.storage.entities[entity.id]
	return get[A](m.storageA, index), get[B](m.storageB, index), get[C](m.storageC, index), get[D](m.storageD, index), get[E](m.storageE, index), get[F](m.storageF, index)
}

// HasAll return whether the given entity has all mapped components.
//
// Using [Map6.Get] and checking for nil pointer may be faster
// than calling [Map6.HasAll] and [Map6.Get] subsequently.
func (m *Map6[A, B, C, D, E, F]) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	index := m.world.storage.entities[entity.id]
	return m.storageA.columns[index.table] != nil &&
		m.storageB.columns[index.table] != nil &&
		m.storageC.columns[index.table] != nil &&
		m.storageD.columns[index.table] != nil &&
		m.storageE.columns[index.table] != nil &&
		m.storageF.columns[index.table] != nil
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map6[A, B, C, D, E, F]) Add(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, rel ...Relation) {
	m.AddFn(entity, func(pa *A, pb *B, pc *C, pd *D, pe *E, pf *F) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
	}, rel...)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map6[A, B, C, D, E, F]) AddFn(entity Entity, fn func(*A, *B, *C, *D, *E, *F), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	oldMask, newMask := m.world.add(entity, m.ids, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
		)
	}
	m.world.storage.observers.FireAddIfHas(OnAddComponents, entity, oldMask, newMask)
	if len(rel) > 0 {
		m.world.storage.observers.FireAddIfHas(OnAddRelations, entity, oldMask, newMask)
	}
}

// Set the mapped components of the given entity to the given values.
// Requires the entity to already have all the mapped components.
//
// Triggers an OnSetComponents event, which is not the case when assigning by
// pointer dereference or assigning to fields. This can be used to notify observers
// about component updates.
//
// This is not a component operation, so it can be performed on a locked world.
func (m *Map6[A, B, C, D, E, F]) Set(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F) {
	if !m.world.Alive(entity) {
		panic("can't set components of a dead entity")
	}
	m.world.storage.checkHasComponent(entity, m.ids[0])
	m.world.storage.checkHasComponent(entity, m.ids[1])
	m.world.storage.checkHasComponent(entity, m.ids[2])
	m.world.storage.checkHasComponent(entity, m.ids[3])
	m.world.storage.checkHasComponent(entity, m.ids[4])
	m.world.storage.checkHasComponent(entity, m.ids[5])

	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)
	*(*A)(m.storageA.columns[index.table].Get(row)) = *a
	*(*B)(m.storageB.columns[index.table].Get(row)) = *b
	*(*C)(m.storageC.columns[index.table].Get(row)) = *c
	*(*D)(m.storageD.columns[index.table].Get(row)) = *d
	*(*E)(m.storageE.columns[index.table].Get(row)) = *e
	*(*F)(m.storageF.columns[index.table].Get(row)) = *f

	if m.world.storage.observers.HasObservers(OnSetComponents) {
		newMask := &m.world.storage.archetypes[m.world.storage.tables[index.table].archetype].mask
		m.world.storage.observers.FireSet(entity, &m.mask, newMask)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map6[A, B, C, D, E, F]) AddBatch(batch Batch, a *A, b *B, c *C, d *D, e *E, f *F, rel ...Relation) {
	m.AddBatchFn(batch, func(_ Entity, pa *A, pb *B, pc *C, pd *D, pe *E, pf *F) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
	}, rel...)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map6[A, B, C, D, E, F]) AddBatchFn(batch Batch, fn func(Entity, *A, *B, *C, *D, *E, *F), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)

	var process func(tableID tableID, start, len uint32)
	if fn != nil {
		process = func(tableID tableID, start, len uint32) {
			table := &m.world.storage.tables[tableID]
			columnA := m.storageA.columns[tableID]
			columnB := m.storageB.columns[tableID]
			columnC := m.storageC.columns[tableID]
			columnD := m.storageD.columns[tableID]
			columnE := m.storageE.columns[tableID]
			columnF := m.storageF.columns[tableID]

			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
					(*D)(columnD.Get(index)),
					(*E)(columnE.Get(index)),
					(*F)(columnF.Get(index)),
				)
			}
		}
	}
	m.world.exchangeBatch(&batch, m.ids, nil, m.relations, process)
}

// Remove the mapped components from the given entity.
func (m *Map6[A, B, C, D, E, F]) Remove(entity Entity) {
	m.world.remove(entity, m.ids)
}

// RemoveBatch removes the mapped components from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map6[A, B, C, D, E, F]) RemoveBatch(batch Batch, fn func(entity Entity)) {
	removeBatch(m.world, &batch, m.ids, fn)
}

// GetRelation returns the relation target of an entity for the component at the given index.
func (m *Map6[A, B, C, D, E, F]) GetRelation(entity Entity, index int) Entity {
	if !m.world.Alive(entity) {
		panic("can't get entity relation target for a dead entity")
	}
	return m.GetRelationUnchecked(entity, index)
}

// GetRelationUnchecked returns the relation target of an entity for the component at the given index.
// In contrast to [Map6.GetRelation], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map6[A, B, C, D, E, F]) GetRelationUnchecked(entity Entity, index int) Entity {
	return m.world.storage.getRelation(entity, m.ids[index])
}

// SetRelations sets relation targets for the given entity.
func (m *Map6[A, B, C, D, E, F]) SetRelations(entity Entity, rel ...Relation) {
	// alive check is done in World.setRelations
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	m.world.setRelations(entity, m.relations)
}

// SetRelationsBatch sets relation targets for all entities matching the given batch filter.
func (m *Map6[A, B, C, D, E, F]) SetRelationsBatch(batch Batch, fn func(entity Entity), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	setRelationsBatch(m.world, &batch, fn, m.relations)
}

// Map7 is a mapper to access 7 components of an entity.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Map2] for a usage example.
type Map7[A any, B any, C any, D any, E any, F any, G any] struct {
	mask      bitMask
	ids       []ID
	relations []relationID
	world     *World
	storageA  *componentStorage
	storageB  *componentStorage
	storageC  *componentStorage
	storageD  *componentStorage
	storageE  *componentStorage
	storageF  *componentStorage
	storageG  *componentStorage
}

// New creates a new [Map7]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
//
// See [Map2.New] for an example.
func (_ *Map7[A, B, C, D, E, F, G]) New(world *World) *Map7[A, B, C, D, E, F, G] {
	return NewMap7[A, B, C, D, E, F, G](world)
}

// NewMap7 creates a new [Map7].
func NewMap7[A any, B any, C any, D any, E any, F any, G any](world *World) *Map7[A, B, C, D, E, F, G] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
		ComponentID[F](world),
		ComponentID[G](world),
	}
	return &Map7[A, B, C, D, E, F, G]{
		world:    world,
		ids:      ids,
		mask:     newMask(ids...),
		storageA: &world.storage.components[ids[0].id],
		storageB: &world.storage.components[ids[1].id],
		storageC: &world.storage.components[ids[2].id],
		storageD: &world.storage.components[ids[3].id],
		storageE: &world.storage.components[ids[4].id],
		storageF: &world.storage.components[ids[5].id],
		storageG: &world.storage.components[ids[6].id],
	}
}

// NewEntity creates a new entity with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (m *Map7[A, B, C, D, E, F, G]) NewEntity(a *A, b *B, c *C, d *D, e *E, f *F, g *G, rel ...Relation) Entity {
	return m.NewEntityFn(func(pa *A, pb *B, pc *C, pd *D, pe *E, pf *F, pg *G) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
		*pg = *g
	}, rel...)
}

// NewEntityFn creates a new entity with the mapped component and runs a callback instead of using a component for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map7[A, B, C, D, E, F, G]) NewEntityFn(fn func(*A, *B, *C, *D, *E, *F, *G), rel ...Relation) Entity {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	entity, mask := m.world.newEntity(m.ids, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
			(*G)(m.storageG.columns[index.table].Get(row)),
		)
	}
	m.world.storage.observers.FireCreateEntityIfHas(entity, mask)
	if len(rel) > 0 {
		m.world.storage.observers.FireCreateEntityRelIfHas(entity, mask)
	}
	return entity
}

// NewBatch creates a batch of new entities with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (m *Map7[A, B, C, D, E, F, G]) NewBatch(count int, a *A, b *B, c *C, d *D, e *E, f *F, g *G, rel ...Relation) {
	m.NewBatchFn(count, func(_ Entity, pa *A, pb *B, pc *C, pd *D, pe *E, pf *F, pg *G) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
		*pg = *g
	}, rel...)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map7[A, B, C, D, E, F, G]) NewBatchFn(count int, fn func(Entity, *A, *B, *C, *D, *E, *F, *G), rel ...Relation) {
	m.world.checkLocked()
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)

	hasCreateObs := m.world.storage.observers.HasObservers(OnCreateEntity)
	hasRelObs := len(rel) > 0 && m.world.storage.observers.HasObservers(OnAddRelations)
	shouldLock := hasCreateObs || hasRelObs || fn != nil
	var lock uint8
	if shouldLock {
		lock = m.world.lock()
	}

	if fn != nil {
		table := &m.world.storage.tables[tableID]
		columnA := m.storageA.columns[tableID]
		columnB := m.storageB.columns[tableID]
		columnC := m.storageC.columns[tableID]
		columnD := m.storageD.columns[tableID]
		columnE := m.storageE.columns[tableID]
		columnF := m.storageF.columns[tableID]
		columnG := m.storageG.columns[tableID]
		for i := range count {
			index := uintptr(start + i)
			fn(
				table.GetEntity(index),
				(*A)(columnA.Get(index)),
				(*B)(columnB.Get(index)),
				(*C)(columnC.Get(index)),
				(*D)(columnD.Get(index)),
				(*E)(columnE.Get(index)),
				(*F)(columnF.Get(index)),
				(*G)(columnG.Get(index)),
			)
		}
	}

	if hasCreateObs {
		table := &m.world.storage.tables[tableID]
		earlyOut := true
		for i := range count {
			index := uintptr(start + i)
			if !m.world.storage.observers.FireCreateEntity(table.GetEntity(index), &m.mask, earlyOut) {
				break
			}
			earlyOut = false
		}
	}
	if hasRelObs {
		table := &m.world.storage.tables[tableID]
		earlyOut := true
		for i := range count {
			index := uintptr(start + i)
			if !m.world.storage.observers.FireCreateEntityRel(table.GetEntity(index), &m.mask, earlyOut) {
				break
			}
			earlyOut = false
		}
	}

	if shouldLock {
		m.world.unlock(lock)
	}
}

// Get returns the mapped components for the given entity.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map7[A, B, C, D, E, F, G]) Get(entity Entity) (*A, *B, *C, *D, *E, *F, *G) {
	if !m.world.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	index := &m.world.storage.entities[entity.id]
	return get[A](m.storageA, index), get[B](m.storageB, index), get[C](m.storageC, index), get[D](m.storageD, index), get[E](m.storageE, index), get[F](m.storageF, index), get[G](m.storageG, index)
}

// GetUnchecked returns the mapped components for the given entity.
// In contrast to [Map7.Get], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map7[A, B, C, D, E, F, G]) GetUnchecked(entity Entity) (*A, *B, *C, *D, *E, *F, *G) {
	index := &m.world.storage.entities[entity.id]
	return get[A](m.storageA, index), get[B](m.storageB, index), get[C](m.storageC, index), get[D](m.storageD, index), get[E](m.storageE, index), get[F](m.storageF, index), get[G](m.storageG, index)
}

// HasAll return whether the given entity has all mapped components.
//
// Using [Map7.Get] and checking for nil pointer may be faster
// than calling [Map7.HasAll] and [Map7.Get] subsequently.
func (m *Map7[A, B, C, D, E, F, G]) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	index := m.world.storage.entities[entity.id]
	return m.storageA.columns[index.table] != nil &&
		m.storageB.columns[index.table] != nil &&
		m.storageC.columns[index.table] != nil &&
		m.storageD.columns[index.table] != nil &&
		m.storageE.columns[index.table] != nil &&
		m.storageF.columns[index.table] != nil &&
		m.storageG.columns[index.table] != nil
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map7[A, B, C, D, E, F, G]) Add(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, rel ...Relation) {
	m.AddFn(entity, func(pa *A, pb *B, pc *C, pd *D, pe *E, pf *F, pg *G) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
		*pg = *g
	}, rel...)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map7[A, B, C, D, E, F, G]) AddFn(entity Entity, fn func(*A, *B, *C, *D, *E, *F, *G), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	oldMask, newMask := m.world.add(entity, m.ids, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
			(*G)(m.storageG.columns[index.table].Get(row)),
		)
	}
	m.world.storage.observers.FireAddIfHas(OnAddComponents, entity, oldMask, newMask)
	if len(rel) > 0 {
		m.world.storage.observers.FireAddIfHas(OnAddRelations, entity, oldMask, newMask)
	}
}

// Set the mapped components of the given entity to the given values.
// Requires the entity to already have all the mapped components.
//
// Triggers an OnSetComponents event, which is not the case when assigning by
// pointer dereference or assigning to fields. This can be used to notify observers
// about component updates.
//
// This is not a component operation, so it can be performed on a locked world.
func (m *Map7[A, B, C, D, E, F, G]) Set(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G) {
	if !m.world.Alive(entity) {
		panic("can't set components of a dead entity")
	}
	m.world.storage.checkHasComponent(entity, m.ids[0])
	m.world.storage.checkHasComponent(entity, m.ids[1])
	m.world.storage.checkHasComponent(entity, m.ids[2])
	m.world.storage.checkHasComponent(entity, m.ids[3])
	m.world.storage.checkHasComponent(entity, m.ids[4])
	m.world.storage.checkHasComponent(entity, m.ids[5])
	m.world.storage.checkHasComponent(entity, m.ids[6])

	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)
	*(*A)(m.storageA.columns[index.table].Get(row)) = *a
	*(*B)(m.storageB.columns[index.table].Get(row)) = *b
	*(*C)(m.storageC.columns[index.table].Get(row)) = *c
	*(*D)(m.storageD.columns[index.table].Get(row)) = *d
	*(*E)(m.storageE.columns[index.table].Get(row)) = *e
	*(*F)(m.storageF.columns[index.table].Get(row)) = *f
	*(*G)(m.storageG.columns[index.table].Get(row)) = *g

	if m.world.storage.observers.HasObservers(OnSetComponents) {
		newMask := &m.world.storage.archetypes[m.world.storage.tables[index.table].archetype].mask
		m.world.storage.observers.FireSet(entity, &m.mask, newMask)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map7[A, B, C, D, E, F, G]) AddBatch(batch Batch, a *A, b *B, c *C, d *D, e *E, f *F, g *G, rel ...Relation) {
	m.AddBatchFn(batch, func(_ Entity, pa *A, pb *B, pc *C, pd *D, pe *E, pf *F, pg *G) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
		*pg = *g
	}, rel...)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map7[A, B, C, D, E, F, G]) AddBatchFn(batch Batch, fn func(Entity, *A, *B, *C, *D, *E, *F, *G), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)

	var process func(tableID tableID, start, len uint32)
	if fn != nil {
		process = func(tableID tableID, start, len uint32) {
			table := &m.world.storage.tables[tableID]
			columnA := m.storageA.columns[tableID]
			columnB := m.storageB.columns[tableID]
			columnC := m.storageC.columns[tableID]
			columnD := m.storageD.columns[tableID]
			columnE := m.storageE.columns[tableID]
			columnF := m.storageF.columns[tableID]
			columnG := m.storageG.columns[tableID]

			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
					(*D)(columnD.Get(index)),
					(*E)(columnE.Get(index)),
					(*F)(columnF.Get(index)),
					(*G)(columnG.Get(index)),
				)
			}
		}
	}
	m.world.exchangeBatch(&batch, m.ids, nil, m.relations, process)
}

// Remove the mapped components from the given entity.
func (m *Map7[A, B, C, D, E, F, G]) Remove(entity Entity) {
	m.world.remove(entity, m.ids)
}

// RemoveBatch removes the mapped components from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map7[A, B, C, D, E, F, G]) RemoveBatch(batch Batch, fn func(entity Entity)) {
	removeBatch(m.world, &batch, m.ids, fn)
}

// GetRelation returns the relation target of an entity for the component at the given index.
func (m *Map7[A, B, C, D, E, F, G]) GetRelation(entity Entity, index int) Entity {
	if !m.world.Alive(entity) {
		panic("can't get entity relation target for a dead entity")
	}
	return m.GetRelationUnchecked(entity, index)
}

// GetRelationUnchecked returns the relation target of an entity for the component at the given index.
// In contrast to [Map7.GetRelation], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map7[A, B, C, D, E, F, G]) GetRelationUnchecked(entity Entity, index int) Entity {
	return m.world.storage.getRelation(entity, m.ids[index])
}

// SetRelations sets relation targets for the given entity.
func (m *Map7[A, B, C, D, E, F, G]) SetRelations(entity Entity, rel ...Relation) {
	// alive check is done in World.setRelations
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	m.world.setRelations(entity, m.relations)
}

// SetRelationsBatch sets relation targets for all entities matching the given batch filter.
func (m *Map7[A, B, C, D, E, F, G]) SetRelationsBatch(batch Batch, fn func(entity Entity), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	setRelationsBatch(m.world, &batch, fn, m.relations)
}

// Map8 is a mapper to access 8 components of an entity.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Map2] for a usage example.
type Map8[A any, B any, C any, D any, E any, F any, G any, H any] struct {
	mask      bitMask
	ids       []ID
	relations []relationID
	world     *World
	storageA  *componentStorage
	storageB  *componentStorage
	storageC  *componentStorage
	storageD  *componentStorage
	storageE  *componentStorage
	storageF  *componentStorage
	storageG  *componentStorage
	storageH  *componentStorage
}

// New creates a new [Map8]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
//
// See [Map2.New] for an example.
func (_ *Map8[A, B, C, D, E, F, G, H]) New(world *World) *Map8[A, B, C, D, E, F, G, H] {
	return NewMap8[A, B, C, D, E, F, G, H](world)
}

// NewMap8 creates a new [Map8].
func NewMap8[A any, B any, C any, D any, E any, F any, G any, H any](world *World) *Map8[A, B, C, D, E, F, G, H] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
		ComponentID[F](world),
		ComponentID[G](world),
		ComponentID[H](world),
	}
	return &Map8[A, B, C, D, E, F, G, H]{
		world:    world,
		ids:      ids,
		mask:     newMask(ids...),
		storageA: &world.storage.components[ids[0].id],
		storageB: &world.storage.components[ids[1].id],
		storageC: &world.storage.components[ids[2].id],
		storageD: &world.storage.components[ids[3].id],
		storageE: &world.storage.components[ids[4].id],
		storageF: &world.storage.components[ids[5].id],
		storageG: &world.storage.components[ids[6].id],
		storageH: &world.storage.components[ids[7].id],
	}
}

// NewEntity creates a new entity with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (m *Map8[A, B, C, D, E, F, G, H]) NewEntity(a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, rel ...Relation) Entity {
	return m.NewEntityFn(func(pa *A, pb *B, pc *C, pd *D, pe *E, pf *F, pg *G, ph *H) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
		*pg = *g
		*ph = *h
	}, rel...)
}

// NewEntityFn creates a new entity with the mapped component and runs a callback instead of using a component for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map8[A, B, C, D, E, F, G, H]) NewEntityFn(fn func(*A, *B, *C, *D, *E, *F, *G, *H), rel ...Relation) Entity {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	entity, mask := m.world.newEntity(m.ids, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
			(*G)(m.storageG.columns[index.table].Get(row)),
			(*H)(m.storageH.columns[index.table].Get(row)),
		)
	}
	m.world.storage.observers.FireCreateEntityIfHas(entity, mask)
	if len(rel) > 0 {
		m.world.storage.observers.FireCreateEntityRelIfHas(entity, mask)
	}
	return entity
}

// NewBatch creates a batch of new entities with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (m *Map8[A, B, C, D, E, F, G, H]) NewBatch(count int, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, rel ...Relation) {
	m.NewBatchFn(count, func(_ Entity, pa *A, pb *B, pc *C, pd *D, pe *E, pf *F, pg *G, ph *H) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
		*pg = *g
		*ph = *h
	}, rel...)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map8[A, B, C, D, E, F, G, H]) NewBatchFn(count int, fn func(Entity, *A, *B, *C, *D, *E, *F, *G, *H), rel ...Relation) {
	m.world.checkLocked()
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)

	hasCreateObs := m.world.storage.observers.HasObservers(OnCreateEntity)
	hasRelObs := len(rel) > 0 && m.world.storage.observers.HasObservers(OnAddRelations)
	shouldLock := hasCreateObs || hasRelObs || fn != nil
	var lock uint8
	if shouldLock {
		lock = m.world.lock()
	}

	if fn != nil {
		table := &m.world.storage.tables[tableID]
		columnA := m.storageA.columns[tableID]
		columnB := m.storageB.columns[tableID]
		columnC := m.storageC.columns[tableID]
		columnD := m.storageD.columns[tableID]
		columnE := m.storageE.columns[tableID]
		columnF := m.storageF.columns[tableID]
		columnG := m.storageG.columns[tableID]
		columnH := m.storageH.columns[tableID]
		for i := range count {
			index := uintptr(start + i)
			fn(
				table.GetEntity(index),
				(*A)(columnA.Get(index)),
				(*B)(columnB.Get(index)),
				(*C)(columnC.Get(index)),
				(*D)(columnD.Get(index)),
				(*E)(columnE.Get(index)),
				(*F)(columnF.Get(index)),
				(*G)(columnG.Get(index)),
				(*H)(columnH.Get(index)),
			)
		}
	}

	if hasCreateObs {
		table := &m.world.storage.tables[tableID]
		earlyOut := true
		for i := range count {
			index := uintptr(start + i)
			if !m.world.storage.observers.FireCreateEntity(table.GetEntity(index), &m.mask, earlyOut) {
				break
			}
			earlyOut = false
		}
	}
	if hasRelObs {
		table := &m.world.storage.tables[tableID]
		earlyOut := true
		for i := range count {
			index := uintptr(start + i)
			if !m.world.storage.observers.FireCreateEntityRel(table.GetEntity(index), &m.mask, earlyOut) {
				break
			}
			earlyOut = false
		}
	}

	if shouldLock {
		m.world.unlock(lock)
	}
}

// Get returns the mapped components for the given entity.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map8[A, B, C, D, E, F, G, H]) Get(entity Entity) (*A, *B, *C, *D, *E, *F, *G, *H) {
	if !m.world.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	index := &m.world.storage.entities[entity.id]
	return get[A](m.storageA, index), get[B](m.storageB, index), get[C](m.storageC, index), get[D](m.storageD, index), get[E](m.storageE, index), get[F](m.storageF, index), get[G](m.storageG, index), get[H](m.storageH, index)
}

// GetUnchecked returns the mapped components for the given entity.
// In contrast to [Map8.Get], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map8[A, B, C, D, E, F, G, H]) GetUnchecked(entity Entity) (*A, *B, *C, *D, *E, *F, *G, *H) {
	index := &m.world.storage.entities[entity.id]
	return get[A](m.storageA, index), get[B](m.storageB, index), get[C](m.storageC, index), get[D](m.storageD, index), get[E](m.storageE, index), get[F](m.storageF, index), get[G](m.storageG, index), get[H](m.storageH, index)
}

// HasAll return whether the given entity has all mapped components.
//
// Using [Map8.Get] and checking for nil pointer may be faster
// than calling [Map8.HasAll] and [Map8.Get] subsequently.
func (m *Map8[A, B, C, D, E, F, G, H]) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	index := m.world.storage.entities[entity.id]
	return m.storageA.columns[index.table] != nil &&
		m.storageB.columns[index.table] != nil &&
		m.storageC.columns[index.table] != nil &&
		m.storageD.columns[index.table] != nil &&
		m.storageE.columns[index.table] != nil &&
		m.storageF.columns[index.table] != nil &&
		m.storageG.columns[index.table] != nil &&
		m.storageH.columns[index.table] != nil
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map8[A, B, C, D, E, F, G, H]) Add(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, rel ...Relation) {
	m.AddFn(entity, func(pa *A, pb *B, pc *C, pd *D, pe *E, pf *F, pg *G, ph *H) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
		*pg = *g
		*ph = *h
	}, rel...)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map8[A, B, C, D, E, F, G, H]) AddFn(entity Entity, fn func(*A, *B, *C, *D, *E, *F, *G, *H), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	oldMask, newMask := m.world.add(entity, m.ids, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
			(*G)(m.storageG.columns[index.table].Get(row)),
			(*H)(m.storageH.columns[index.table].Get(row)),
		)
	}
	m.world.storage.observers.FireAddIfHas(OnAddComponents, entity, oldMask, newMask)
	if len(rel) > 0 {
		m.world.storage.observers.FireAddIfHas(OnAddRelations, entity, oldMask, newMask)
	}
}

// Set the mapped components of the given entity to the given values.
// Requires the entity to already have all the mapped components.
//
// Triggers an OnSetComponents event, which is not the case when assigning by
// pointer dereference or assigning to fields. This can be used to notify observers
// about component updates.
//
// This is not a component operation, so it can be performed on a locked world.
func (m *Map8[A, B, C, D, E, F, G, H]) Set(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H) {
	if !m.world.Alive(entity) {
		panic("can't set components of a dead entity")
	}
	m.world.storage.checkHasComponent(entity, m.ids[0])
	m.world.storage.checkHasComponent(entity, m.ids[1])
	m.world.storage.checkHasComponent(entity, m.ids[2])
	m.world.storage.checkHasComponent(entity, m.ids[3])
	m.world.storage.checkHasComponent(entity, m.ids[4])
	m.world.storage.checkHasComponent(entity, m.ids[5])
	m.world.storage.checkHasComponent(entity, m.ids[6])
	m.world.storage.checkHasComponent(entity, m.ids[7])

	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)
	*(*A)(m.storageA.columns[index.table].Get(row)) = *a
	*(*B)(m.storageB.columns[index.table].Get(row)) = *b
	*(*C)(m.storageC.columns[index.table].Get(row)) = *c
	*(*D)(m.storageD.columns[index.table].Get(row)) = *d
	*(*E)(m.storageE.columns[index.table].Get(row)) = *e
	*(*F)(m.storageF.columns[index.table].Get(row)) = *f
	*(*G)(m.storageG.columns[index.table].Get(row)) = *g
	*(*H)(m.storageH.columns[index.table].Get(row)) = *h

	if m.world.storage.observers.HasObservers(OnSetComponents) {
		newMask := &m.world.storage.archetypes[m.world.storage.tables[index.table].archetype].mask
		m.world.storage.observers.FireSet(entity, &m.mask, newMask)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map8[A, B, C, D, E, F, G, H]) AddBatch(batch Batch, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, rel ...Relation) {
	m.AddBatchFn(batch, func(_ Entity, pa *A, pb *B, pc *C, pd *D, pe *E, pf *F, pg *G, ph *H) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
		*pg = *g
		*ph = *h
	}, rel...)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map8[A, B, C, D, E, F, G, H]) AddBatchFn(batch Batch, fn func(Entity, *A, *B, *C, *D, *E, *F, *G, *H), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)

	var process func(tableID tableID, start, len uint32)
	if fn != nil {
		process = func(tableID tableID, start, len uint32) {
			table := &m.world.storage.tables[tableID]
			columnA := m.storageA.columns[tableID]
			columnB := m.storageB.columns[tableID]
			columnC := m.storageC.columns[tableID]
			columnD := m.storageD.columns[tableID]
			columnE := m.storageE.columns[tableID]
			columnF := m.storageF.columns[tableID]
			columnG := m.storageG.columns[tableID]
			columnH := m.storageH.columns[tableID]

			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
					(*D)(columnD.Get(index)),
					(*E)(columnE.Get(index)),
					(*F)(columnF.Get(index)),
					(*G)(columnG.Get(index)),
					(*H)(columnH.Get(index)),
				)
			}
		}
	}
	m.world.exchangeBatch(&batch, m.ids, nil, m.relations, process)
}

// Remove the mapped components from the given entity.
func (m *Map8[A, B, C, D, E, F, G, H]) Remove(entity Entity) {
	m.world.remove(entity, m.ids)
}

// RemoveBatch removes the mapped components from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map8[A, B, C, D, E, F, G, H]) RemoveBatch(batch Batch, fn func(entity Entity)) {
	removeBatch(m.world, &batch, m.ids, fn)
}

// GetRelation returns the relation target of an entity for the component at the given index.
func (m *Map8[A, B, C, D, E, F, G, H]) GetRelation(entity Entity, index int) Entity {
	if !m.world.Alive(entity) {
		panic("can't get entity relation target for a dead entity")
	}
	return m.GetRelationUnchecked(entity, index)
}

// GetRelationUnchecked returns the relation target of an entity for the component at the given index.
// In contrast to [Map8.GetRelation], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map8[A, B, C, D, E, F, G, H]) GetRelationUnchecked(entity Entity, index int) Entity {
	return m.world.storage.getRelation(entity, m.ids[index])
}

// SetRelations sets relation targets for the given entity.
func (m *Map8[A, B, C, D, E, F, G, H]) SetRelations(entity Entity, rel ...Relation) {
	// alive check is done in World.setRelations
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	m.world.setRelations(entity, m.relations)
}

// SetRelationsBatch sets relation targets for all entities matching the given batch filter.
func (m *Map8[A, B, C, D, E, F, G, H]) SetRelationsBatch(batch Batch, fn func(entity Entity), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	setRelationsBatch(m.world, &batch, fn, m.relations)
}

// Map9 is a mapper to access 9 components of an entity.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Map2] for a usage example.
type Map9[A any, B any, C any, D any, E any, F any, G any, H any, I any] struct {
	mask      bitMask
	ids       []ID
	relations []relationID
	world     *World
	storageA  *componentStorage
	storageB  *componentStorage
	storageC  *componentStorage
	storageD  *componentStorage
	storageE  *componentStorage
	storageF  *componentStorage
	storageG  *componentStorage
	storageH  *componentStorage
	storageI  *componentStorage
}

// New creates a new [Map9]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
//
// See [Map2.New] for an example.
func (_ *Map9[A, B, C, D, E, F, G, H, I]) New(world *World) *Map9[A, B, C, D, E, F, G, H, I] {
	return NewMap9[A, B, C, D, E, F, G, H, I](world)
}

// NewMap9 creates a new [Map9].
func NewMap9[A any, B any, C any, D any, E any, F any, G any, H any, I any](world *World) *Map9[A, B, C, D, E, F, G, H, I] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
		ComponentID[F](world),
		ComponentID[G](world),
		ComponentID[H](world),
		ComponentID[I](world),
	}
	return &Map9[A, B, C, D, E, F, G, H, I]{
		world:    world,
		ids:      ids,
		mask:     newMask(ids...),
		storageA: &world.storage.components[ids[0].id],
		storageB: &world.storage.components[ids[1].id],
		storageC: &world.storage.components[ids[2].id],
		storageD: &world.storage.components[ids[3].id],
		storageE: &world.storage.components[ids[4].id],
		storageF: &world.storage.components[ids[5].id],
		storageG: &world.storage.components[ids[6].id],
		storageH: &world.storage.components[ids[7].id],
		storageI: &world.storage.components[ids[8].id],
	}
}

// NewEntity creates a new entity with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (m *Map9[A, B, C, D, E, F, G, H, I]) NewEntity(a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, rel ...Relation) Entity {
	return m.NewEntityFn(func(pa *A, pb *B, pc *C, pd *D, pe *E, pf *F, pg *G, ph *H, pi *I) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
		*pg = *g
		*ph = *h
		*pi = *i
	}, rel...)
}

// NewEntityFn creates a new entity with the mapped component and runs a callback instead of using a component for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map9[A, B, C, D, E, F, G, H, I]) NewEntityFn(fn func(*A, *B, *C, *D, *E, *F, *G, *H, *I), rel ...Relation) Entity {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	entity, mask := m.world.newEntity(m.ids, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
			(*G)(m.storageG.columns[index.table].Get(row)),
			(*H)(m.storageH.columns[index.table].Get(row)),
			(*I)(m.storageI.columns[index.table].Get(row)),
		)
	}
	m.world.storage.observers.FireCreateEntityIfHas(entity, mask)
	if len(rel) > 0 {
		m.world.storage.observers.FireCreateEntityRelIfHas(entity, mask)
	}
	return entity
}

// NewBatch creates a batch of new entities with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (m *Map9[A, B, C, D, E, F, G, H, I]) NewBatch(count int, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, rel ...Relation) {
	m.NewBatchFn(count, func(_ Entity, pa *A, pb *B, pc *C, pd *D, pe *E, pf *F, pg *G, ph *H, pi *I) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
		*pg = *g
		*ph = *h
		*pi = *i
	}, rel...)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map9[A, B, C, D, E, F, G, H, I]) NewBatchFn(count int, fn func(Entity, *A, *B, *C, *D, *E, *F, *G, *H, *I), rel ...Relation) {
	m.world.checkLocked()
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)

	hasCreateObs := m.world.storage.observers.HasObservers(OnCreateEntity)
	hasRelObs := len(rel) > 0 && m.world.storage.observers.HasObservers(OnAddRelations)
	shouldLock := hasCreateObs || hasRelObs || fn != nil
	var lock uint8
	if shouldLock {
		lock = m.world.lock()
	}

	if fn != nil {
		table := &m.world.storage.tables[tableID]
		columnA := m.storageA.columns[tableID]
		columnB := m.storageB.columns[tableID]
		columnC := m.storageC.columns[tableID]
		columnD := m.storageD.columns[tableID]
		columnE := m.storageE.columns[tableID]
		columnF := m.storageF.columns[tableID]
		columnG := m.storageG.columns[tableID]
		columnH := m.storageH.columns[tableID]
		columnI := m.storageI.columns[tableID]
		for i := range count {
			index := uintptr(start + i)
			fn(
				table.GetEntity(index),
				(*A)(columnA.Get(index)),
				(*B)(columnB.Get(index)),
				(*C)(columnC.Get(index)),
				(*D)(columnD.Get(index)),
				(*E)(columnE.Get(index)),
				(*F)(columnF.Get(index)),
				(*G)(columnG.Get(index)),
				(*H)(columnH.Get(index)),
				(*I)(columnI.Get(index)),
			)
		}
	}

	if hasCreateObs {
		table := &m.world.storage.tables[tableID]
		earlyOut := true
		for i := range count {
			index := uintptr(start + i)
			if !m.world.storage.observers.FireCreateEntity(table.GetEntity(index), &m.mask, earlyOut) {
				break
			}
			earlyOut = false
		}
	}
	if hasRelObs {
		table := &m.world.storage.tables[tableID]
		earlyOut := true
		for i := range count {
			index := uintptr(start + i)
			if !m.world.storage.observers.FireCreateEntityRel(table.GetEntity(index), &m.mask, earlyOut) {
				break
			}
			earlyOut = false
		}
	}

	if shouldLock {
		m.world.unlock(lock)
	}
}

// Get returns the mapped components for the given entity.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map9[A, B, C, D, E, F, G, H, I]) Get(entity Entity) (*A, *B, *C, *D, *E, *F, *G, *H, *I) {
	if !m.world.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	index := &m.world.storage.entities[entity.id]
	return get[A](m.storageA, index), get[B](m.storageB, index), get[C](m.storageC, index), get[D](m.storageD, index), get[E](m.storageE, index), get[F](m.storageF, index), get[G](m.storageG, index), get[H](m.storageH, index), get[I](m.storageI, index)
}

// GetUnchecked returns the mapped components for the given entity.
// In contrast to [Map9.Get], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map9[A, B, C, D, E, F, G, H, I]) GetUnchecked(entity Entity) (*A, *B, *C, *D, *E, *F, *G, *H, *I) {
	index := &m.world.storage.entities[entity.id]
	return get[A](m.storageA, index), get[B](m.storageB, index), get[C](m.storageC, index), get[D](m.storageD, index), get[E](m.storageE, index), get[F](m.storageF, index), get[G](m.storageG, index), get[H](m.storageH, index), get[I](m.storageI, index)
}

// HasAll return whether the given entity has all mapped components.
//
// Using [Map9.Get] and checking for nil pointer may be faster
// than calling [Map9.HasAll] and [Map9.Get] subsequently.
func (m *Map9[A, B, C, D, E, F, G, H, I]) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	index := m.world.storage.entities[entity.id]
	return m.storageA.columns[index.table] != nil &&
		m.storageB.columns[index.table] != nil &&
		m.storageC.columns[index.table] != nil &&
		m.storageD.columns[index.table] != nil &&
		m.storageE.columns[index.table] != nil &&
		m.storageF.columns[index.table] != nil &&
		m.storageG.columns[index.table] != nil &&
		m.storageH.columns[index.table] != nil &&
		m.storageI.columns[index.table] != nil
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map9[A, B, C, D, E, F, G, H, I]) Add(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, rel ...Relation) {
	m.AddFn(entity, func(pa *A, pb *B, pc *C, pd *D, pe *E, pf *F, pg *G, ph *H, pi *I) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
		*pg = *g
		*ph = *h
		*pi = *i
	}, rel...)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map9[A, B, C, D, E, F, G, H, I]) AddFn(entity Entity, fn func(*A, *B, *C, *D, *E, *F, *G, *H, *I), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	oldMask, newMask := m.world.add(entity, m.ids, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
			(*G)(m.storageG.columns[index.table].Get(row)),
			(*H)(m.storageH.columns[index.table].Get(row)),
			(*I)(m.storageI.columns[index.table].Get(row)),
		)
	}
	m.world.storage.observers.FireAddIfHas(OnAddComponents, entity, oldMask, newMask)
	if len(rel) > 0 {
		m.world.storage.observers.FireAddIfHas(OnAddRelations, entity, oldMask, newMask)
	}
}

// Set the mapped components of the given entity to the given values.
// Requires the entity to already have all the mapped components.
//
// Triggers an OnSetComponents event, which is not the case when assigning by
// pointer dereference or assigning to fields. This can be used to notify observers
// about component updates.
//
// This is not a component operation, so it can be performed on a locked world.
func (m *Map9[A, B, C, D, E, F, G, H, I]) Set(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I) {
	if !m.world.Alive(entity) {
		panic("can't set components of a dead entity")
	}
	m.world.storage.checkHasComponent(entity, m.ids[0])
	m.world.storage.checkHasComponent(entity, m.ids[1])
	m.world.storage.checkHasComponent(entity, m.ids[2])
	m.world.storage.checkHasComponent(entity, m.ids[3])
	m.world.storage.checkHasComponent(entity, m.ids[4])
	m.world.storage.checkHasComponent(entity, m.ids[5])
	m.world.storage.checkHasComponent(entity, m.ids[6])
	m.world.storage.checkHasComponent(entity, m.ids[7])
	m.world.storage.checkHasComponent(entity, m.ids[8])

	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)
	*(*A)(m.storageA.columns[index.table].Get(row)) = *a
	*(*B)(m.storageB.columns[index.table].Get(row)) = *b
	*(*C)(m.storageC.columns[index.table].Get(row)) = *c
	*(*D)(m.storageD.columns[index.table].Get(row)) = *d
	*(*E)(m.storageE.columns[index.table].Get(row)) = *e
	*(*F)(m.storageF.columns[index.table].Get(row)) = *f
	*(*G)(m.storageG.columns[index.table].Get(row)) = *g
	*(*H)(m.storageH.columns[index.table].Get(row)) = *h
	*(*I)(m.storageI.columns[index.table].Get(row)) = *i

	if m.world.storage.observers.HasObservers(OnSetComponents) {
		newMask := &m.world.storage.archetypes[m.world.storage.tables[index.table].archetype].mask
		m.world.storage.observers.FireSet(entity, &m.mask, newMask)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map9[A, B, C, D, E, F, G, H, I]) AddBatch(batch Batch, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, rel ...Relation) {
	m.AddBatchFn(batch, func(_ Entity, pa *A, pb *B, pc *C, pd *D, pe *E, pf *F, pg *G, ph *H, pi *I) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
		*pg = *g
		*ph = *h
		*pi = *i
	}, rel...)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map9[A, B, C, D, E, F, G, H, I]) AddBatchFn(batch Batch, fn func(Entity, *A, *B, *C, *D, *E, *F, *G, *H, *I), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)

	var process func(tableID tableID, start, len uint32)
	if fn != nil {
		process = func(tableID tableID, start, len uint32) {
			table := &m.world.storage.tables[tableID]
			columnA := m.storageA.columns[tableID]
			columnB := m.storageB.columns[tableID]
			columnC := m.storageC.columns[tableID]
			columnD := m.storageD.columns[tableID]
			columnE := m.storageE.columns[tableID]
			columnF := m.storageF.columns[tableID]
			columnG := m.storageG.columns[tableID]
			columnH := m.storageH.columns[tableID]
			columnI := m.storageI.columns[tableID]

			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
					(*D)(columnD.Get(index)),
					(*E)(columnE.Get(index)),
					(*F)(columnF.Get(index)),
					(*G)(columnG.Get(index)),
					(*H)(columnH.Get(index)),
					(*I)(columnI.Get(index)),
				)
			}
		}
	}
	m.world.exchangeBatch(&batch, m.ids, nil, m.relations, process)
}

// Remove the mapped components from the given entity.
func (m *Map9[A, B, C, D, E, F, G, H, I]) Remove(entity Entity) {
	m.world.remove(entity, m.ids)
}

// RemoveBatch removes the mapped components from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map9[A, B, C, D, E, F, G, H, I]) RemoveBatch(batch Batch, fn func(entity Entity)) {
	removeBatch(m.world, &batch, m.ids, fn)
}

// GetRelation returns the relation target of an entity for the component at the given index.
func (m *Map9[A, B, C, D, E, F, G, H, I]) GetRelation(entity Entity, index int) Entity {
	if !m.world.Alive(entity) {
		panic("can't get entity relation target for a dead entity")
	}
	return m.GetRelationUnchecked(entity, index)
}

// GetRelationUnchecked returns the relation target of an entity for the component at the given index.
// In contrast to [Map9.GetRelation], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map9[A, B, C, D, E, F, G, H, I]) GetRelationUnchecked(entity Entity, index int) Entity {
	return m.world.storage.getRelation(entity, m.ids[index])
}

// SetRelations sets relation targets for the given entity.
func (m *Map9[A, B, C, D, E, F, G, H, I]) SetRelations(entity Entity, rel ...Relation) {
	// alive check is done in World.setRelations
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	m.world.setRelations(entity, m.relations)
}

// SetRelationsBatch sets relation targets for all entities matching the given batch filter.
func (m *Map9[A, B, C, D, E, F, G, H, I]) SetRelationsBatch(batch Batch, fn func(entity Entity), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	setRelationsBatch(m.world, &batch, fn, m.relations)
}

// Map10 is a mapper to access 10 components of an entity.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Map2] for a usage example.
type Map10[A any, B any, C any, D any, E any, F any, G any, H any, I any, J any] struct {
	mask      bitMask
	ids       []ID
	relations []relationID
	world     *World
	storageA  *componentStorage
	storageB  *componentStorage
	storageC  *componentStorage
	storageD  *componentStorage
	storageE  *componentStorage
	storageF  *componentStorage
	storageG  *componentStorage
	storageH  *componentStorage
	storageI  *componentStorage
	storageJ  *componentStorage
}

// New creates a new [Map10]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
//
// See [Map2.New] for an example.
func (_ *Map10[A, B, C, D, E, F, G, H, I, J]) New(world *World) *Map10[A, B, C, D, E, F, G, H, I, J] {
	return NewMap10[A, B, C, D, E, F, G, H, I, J](world)
}

// NewMap10 creates a new [Map10].
func NewMap10[A any, B any, C any, D any, E any, F any, G any, H any, I any, J any](world *World) *Map10[A, B, C, D, E, F, G, H, I, J] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
		ComponentID[F](world),
		ComponentID[G](world),
		ComponentID[H](world),
		ComponentID[I](world),
		ComponentID[J](world),
	}
	return &Map10[A, B, C, D, E, F, G, H, I, J]{
		world:    world,
		ids:      ids,
		mask:     newMask(ids...),
		storageA: &world.storage.components[ids[0].id],
		storageB: &world.storage.components[ids[1].id],
		storageC: &world.storage.components[ids[2].id],
		storageD: &world.storage.components[ids[3].id],
		storageE: &world.storage.components[ids[4].id],
		storageF: &world.storage.components[ids[5].id],
		storageG: &world.storage.components[ids[6].id],
		storageH: &world.storage.components[ids[7].id],
		storageI: &world.storage.components[ids[8].id],
		storageJ: &world.storage.components[ids[9].id],
	}
}

// NewEntity creates a new entity with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) NewEntity(a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, rel ...Relation) Entity {
	return m.NewEntityFn(func(pa *A, pb *B, pc *C, pd *D, pe *E, pf *F, pg *G, ph *H, pi *I, pj *J) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
		*pg = *g
		*ph = *h
		*pi = *i
		*pj = *j
	}, rel...)
}

// NewEntityFn creates a new entity with the mapped component and runs a callback instead of using a component for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) NewEntityFn(fn func(*A, *B, *C, *D, *E, *F, *G, *H, *I, *J), rel ...Relation) Entity {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	entity, mask := m.world.newEntity(m.ids, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
			(*G)(m.storageG.columns[index.table].Get(row)),
			(*H)(m.storageH.columns[index.table].Get(row)),
			(*I)(m.storageI.columns[index.table].Get(row)),
			(*J)(m.storageJ.columns[index.table].Get(row)),
		)
	}
	m.world.storage.observers.FireCreateEntityIfHas(entity, mask)
	if len(rel) > 0 {
		m.world.storage.observers.FireCreateEntityRelIfHas(entity, mask)
	}
	return entity
}

// NewBatch creates a batch of new entities with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) NewBatch(count int, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, rel ...Relation) {
	m.NewBatchFn(count, func(_ Entity, pa *A, pb *B, pc *C, pd *D, pe *E, pf *F, pg *G, ph *H, pi *I, pj *J) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
		*pg = *g
		*ph = *h
		*pi = *i
		*pj = *j
	}, rel...)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) NewBatchFn(count int, fn func(Entity, *A, *B, *C, *D, *E, *F, *G, *H, *I, *J), rel ...Relation) {
	m.world.checkLocked()
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)

	hasCreateObs := m.world.storage.observers.HasObservers(OnCreateEntity)
	hasRelObs := len(rel) > 0 && m.world.storage.observers.HasObservers(OnAddRelations)
	shouldLock := hasCreateObs || hasRelObs || fn != nil
	var lock uint8
	if shouldLock {
		lock = m.world.lock()
	}

	if fn != nil {
		table := &m.world.storage.tables[tableID]
		columnA := m.storageA.columns[tableID]
		columnB := m.storageB.columns[tableID]
		columnC := m.storageC.columns[tableID]
		columnD := m.storageD.columns[tableID]
		columnE := m.storageE.columns[tableID]
		columnF := m.storageF.columns[tableID]
		columnG := m.storageG.columns[tableID]
		columnH := m.storageH.columns[tableID]
		columnI := m.storageI.columns[tableID]
		columnJ := m.storageJ.columns[tableID]
		for i := range count {
			index := uintptr(start + i)
			fn(
				table.GetEntity(index),
				(*A)(columnA.Get(index)),
				(*B)(columnB.Get(index)),
				(*C)(columnC.Get(index)),
				(*D)(columnD.Get(index)),
				(*E)(columnE.Get(index)),
				(*F)(columnF.Get(index)),
				(*G)(columnG.Get(index)),
				(*H)(columnH.Get(index)),
				(*I)(columnI.Get(index)),
				(*J)(columnJ.Get(index)),
			)
		}
	}

	if hasCreateObs {
		table := &m.world.storage.tables[tableID]
		earlyOut := true
		for i := range count {
			index := uintptr(start + i)
			if !m.world.storage.observers.FireCreateEntity(table.GetEntity(index), &m.mask, earlyOut) {
				break
			}
			earlyOut = false
		}
	}
	if hasRelObs {
		table := &m.world.storage.tables[tableID]
		earlyOut := true
		for i := range count {
			index := uintptr(start + i)
			if !m.world.storage.observers.FireCreateEntityRel(table.GetEntity(index), &m.mask, earlyOut) {
				break
			}
			earlyOut = false
		}
	}

	if shouldLock {
		m.world.unlock(lock)
	}
}

// Get returns the mapped components for the given entity.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) Get(entity Entity) (*A, *B, *C, *D, *E, *F, *G, *H, *I, *J) {
	if !m.world.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	index := &m.world.storage.entities[entity.id]
	return get[A](m.storageA, index), get[B](m.storageB, index), get[C](m.storageC, index), get[D](m.storageD, index), get[E](m.storageE, index), get[F](m.storageF, index), get[G](m.storageG, index), get[H](m.storageH, index), get[I](m.storageI, index), get[J](m.storageJ, index)
}

// GetUnchecked returns the mapped components for the given entity.
// In contrast to [Map10.Get], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) GetUnchecked(entity Entity) (*A, *B, *C, *D, *E, *F, *G, *H, *I, *J) {
	index := &m.world.storage.entities[entity.id]
	return get[A](m.storageA, index), get[B](m.storageB, index), get[C](m.storageC, index), get[D](m.storageD, index), get[E](m.storageE, index), get[F](m.storageF, index), get[G](m.storageG, index), get[H](m.storageH, index), get[I](m.storageI, index), get[J](m.storageJ, index)
}

// HasAll return whether the given entity has all mapped components.
//
// Using [Map10.Get] and checking for nil pointer may be faster
// than calling [Map10.HasAll] and [Map10.Get] subsequently.
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	index := m.world.storage.entities[entity.id]
	return m.storageA.columns[index.table] != nil &&
		m.storageB.columns[index.table] != nil &&
		m.storageC.columns[index.table] != nil &&
		m.storageD.columns[index.table] != nil &&
		m.storageE.columns[index.table] != nil &&
		m.storageF.columns[index.table] != nil &&
		m.storageG.columns[index.table] != nil &&
		m.storageH.columns[index.table] != nil &&
		m.storageI.columns[index.table] != nil &&
		m.storageJ.columns[index.table] != nil
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) Add(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, rel ...Relation) {
	m.AddFn(entity, func(pa *A, pb *B, pc *C, pd *D, pe *E, pf *F, pg *G, ph *H, pi *I, pj *J) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
		*pg = *g
		*ph = *h
		*pi = *i
		*pj = *j
	}, rel...)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) AddFn(entity Entity, fn func(*A, *B, *C, *D, *E, *F, *G, *H, *I, *J), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	oldMask, newMask := m.world.add(entity, m.ids, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
			(*G)(m.storageG.columns[index.table].Get(row)),
			(*H)(m.storageH.columns[index.table].Get(row)),
			(*I)(m.storageI.columns[index.table].Get(row)),
			(*J)(m.storageJ.columns[index.table].Get(row)),
		)
	}
	m.world.storage.observers.FireAddIfHas(OnAddComponents, entity, oldMask, newMask)
	if len(rel) > 0 {
		m.world.storage.observers.FireAddIfHas(OnAddRelations, entity, oldMask, newMask)
	}
}

// Set the mapped components of the given entity to the given values.
// Requires the entity to already have all the mapped components.
//
// Triggers an OnSetComponents event, which is not the case when assigning by
// pointer dereference or assigning to fields. This can be used to notify observers
// about component updates.
//
// This is not a component operation, so it can be performed on a locked world.
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) Set(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J) {
	if !m.world.Alive(entity) {
		panic("can't set components of a dead entity")
	}
	m.world.storage.checkHasComponent(entity, m.ids[0])
	m.world.storage.checkHasComponent(entity, m.ids[1])
	m.world.storage.checkHasComponent(entity, m.ids[2])
	m.world.storage.checkHasComponent(entity, m.ids[3])
	m.world.storage.checkHasComponent(entity, m.ids[4])
	m.world.storage.checkHasComponent(entity, m.ids[5])
	m.world.storage.checkHasComponent(entity, m.ids[6])
	m.world.storage.checkHasComponent(entity, m.ids[7])
	m.world.storage.checkHasComponent(entity, m.ids[8])
	m.world.storage.checkHasComponent(entity, m.ids[9])

	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)
	*(*A)(m.storageA.columns[index.table].Get(row)) = *a
	*(*B)(m.storageB.columns[index.table].Get(row)) = *b
	*(*C)(m.storageC.columns[index.table].Get(row)) = *c
	*(*D)(m.storageD.columns[index.table].Get(row)) = *d
	*(*E)(m.storageE.columns[index.table].Get(row)) = *e
	*(*F)(m.storageF.columns[index.table].Get(row)) = *f
	*(*G)(m.storageG.columns[index.table].Get(row)) = *g
	*(*H)(m.storageH.columns[index.table].Get(row)) = *h
	*(*I)(m.storageI.columns[index.table].Get(row)) = *i
	*(*J)(m.storageJ.columns[index.table].Get(row)) = *j

	if m.world.storage.observers.HasObservers(OnSetComponents) {
		newMask := &m.world.storage.archetypes[m.world.storage.tables[index.table].archetype].mask
		m.world.storage.observers.FireSet(entity, &m.mask, newMask)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) AddBatch(batch Batch, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, rel ...Relation) {
	m.AddBatchFn(batch, func(_ Entity, pa *A, pb *B, pc *C, pd *D, pe *E, pf *F, pg *G, ph *H, pi *I, pj *J) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
		*pg = *g
		*ph = *h
		*pi = *i
		*pj = *j
	}, rel...)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) AddBatchFn(batch Batch, fn func(Entity, *A, *B, *C, *D, *E, *F, *G, *H, *I, *J), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)

	var process func(tableID tableID, start, len uint32)
	if fn != nil {
		process = func(tableID tableID, start, len uint32) {
			table := &m.world.storage.tables[tableID]
			columnA := m.storageA.columns[tableID]
			columnB := m.storageB.columns[tableID]
			columnC := m.storageC.columns[tableID]
			columnD := m.storageD.columns[tableID]
			columnE := m.storageE.columns[tableID]
			columnF := m.storageF.columns[tableID]
			columnG := m.storageG.columns[tableID]
			columnH := m.storageH.columns[tableID]
			columnI := m.storageI.columns[tableID]
			columnJ := m.storageJ.columns[tableID]

			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
					(*D)(columnD.Get(index)),
					(*E)(columnE.Get(index)),
					(*F)(columnF.Get(index)),
					(*G)(columnG.Get(index)),
					(*H)(columnH.Get(index)),
					(*I)(columnI.Get(index)),
					(*J)(columnJ.Get(index)),
				)
			}
		}
	}
	m.world.exchangeBatch(&batch, m.ids, nil, m.relations, process)
}

// Remove the mapped components from the given entity.
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) Remove(entity Entity) {
	m.world.remove(entity, m.ids)
}

// RemoveBatch removes the mapped components from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) RemoveBatch(batch Batch, fn func(entity Entity)) {
	removeBatch(m.world, &batch, m.ids, fn)
}

// GetRelation returns the relation target of an entity for the component at the given index.
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) GetRelation(entity Entity, index int) Entity {
	if !m.world.Alive(entity) {
		panic("can't get entity relation target for a dead entity")
	}
	return m.GetRelationUnchecked(entity, index)
}

// GetRelationUnchecked returns the relation target of an entity for the component at the given index.
// In contrast to [Map10.GetRelation], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) GetRelationUnchecked(entity Entity, index int) Entity {
	return m.world.storage.getRelation(entity, m.ids[index])
}

// SetRelations sets relation targets for the given entity.
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) SetRelations(entity Entity, rel ...Relation) {
	// alive check is done in World.setRelations
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	m.world.setRelations(entity, m.relations)
}

// SetRelationsBatch sets relation targets for all entities matching the given batch filter.
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) SetRelationsBatch(batch Batch, fn func(entity Entity), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	setRelationsBatch(m.world, &batch, fn, m.relations)
}

// Map11 is a mapper to access 11 components of an entity.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Map2] for a usage example.
type Map11[A any, B any, C any, D any, E any, F any, G any, H any, I any, J any, K any] struct {
	mask      bitMask
	ids       []ID
	relations []relationID
	world     *World
	storageA  *componentStorage
	storageB  *componentStorage
	storageC  *componentStorage
	storageD  *componentStorage
	storageE  *componentStorage
	storageF  *componentStorage
	storageG  *componentStorage
	storageH  *componentStorage
	storageI  *componentStorage
	storageJ  *componentStorage
	storageK  *componentStorage
}

// New creates a new [Map11]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
//
// See [Map2.New] for an example.
func (_ *Map11[A, B, C, D, E, F, G, H, I, J, K]) New(world *World) *Map11[A, B, C, D, E, F, G, H, I, J, K] {
	return NewMap11[A, B, C, D, E, F, G, H, I, J, K](world)
}

// NewMap11 creates a new [Map11].
func NewMap11[A any, B any, C any, D any, E any, F any, G any, H any, I any, J any, K any](world *World) *Map11[A, B, C, D, E, F, G, H, I, J, K] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
		ComponentID[F](world),
		ComponentID[G](world),
		ComponentID[H](world),
		ComponentID[I](world),
		ComponentID[J](world),
		ComponentID[K](world),
	}
	return &Map11[A, B, C, D, E, F, G, H, I, J, K]{
		world:    world,
		ids:      ids,
		mask:     newMask(ids...),
		storageA: &world.storage.components[ids[0].id],
		storageB: &world.storage.components[ids[1].id],
		storageC: &world.storage.components[ids[2].id],
		storageD: &world.storage.components[ids[3].id],
		storageE: &world.storage.components[ids[4].id],
		storageF: &world.storage.components[ids[5].id],
		storageG: &world.storage.components[ids[6].id],
		storageH: &world.storage.components[ids[7].id],
		storageI: &world.storage.components[ids[8].id],
		storageJ: &world.storage.components[ids[9].id],
		storageK: &world.storage.components[ids[10].id],
	}
}

// NewEntity creates a new entity with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) NewEntity(a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K, rel ...Relation) Entity {
	return m.NewEntityFn(func(pa *A, pb *B, pc *C, pd *D, pe *E, pf *F, pg *G, ph *H, pi *I, pj *J, pk *K) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
		*pg = *g
		*ph = *h
		*pi = *i
		*pj = *j
		*pk = *k
	}, rel...)
}

// NewEntityFn creates a new entity with the mapped component and runs a callback instead of using a component for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) NewEntityFn(fn func(*A, *B, *C, *D, *E, *F, *G, *H, *I, *J, *K), rel ...Relation) Entity {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	entity, mask := m.world.newEntity(m.ids, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
			(*G)(m.storageG.columns[index.table].Get(row)),
			(*H)(m.storageH.columns[index.table].Get(row)),
			(*I)(m.storageI.columns[index.table].Get(row)),
			(*J)(m.storageJ.columns[index.table].Get(row)),
			(*K)(m.storageK.columns[index.table].Get(row)),
		)
	}
	m.world.storage.observers.FireCreateEntityIfHas(entity, mask)
	if len(rel) > 0 {
		m.world.storage.observers.FireCreateEntityRelIfHas(entity, mask)
	}
	return entity
}

// NewBatch creates a batch of new entities with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) NewBatch(count int, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K, rel ...Relation) {
	m.NewBatchFn(count, func(_ Entity, pa *A, pb *B, pc *C, pd *D, pe *E, pf *F, pg *G, ph *H, pi *I, pj *J, pk *K) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
		*pg = *g
		*ph = *h
		*pi = *i
		*pj = *j
		*pk = *k
	}, rel...)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) NewBatchFn(count int, fn func(Entity, *A, *B, *C, *D, *E, *F, *G, *H, *I, *J, *K), rel ...Relation) {
	m.world.checkLocked()
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)

	hasCreateObs := m.world.storage.observers.HasObservers(OnCreateEntity)
	hasRelObs := len(rel) > 0 && m.world.storage.observers.HasObservers(OnAddRelations)
	shouldLock := hasCreateObs || hasRelObs || fn != nil
	var lock uint8
	if shouldLock {
		lock = m.world.lock()
	}

	if fn != nil {
		table := &m.world.storage.tables[tableID]
		columnA := m.storageA.columns[tableID]
		columnB := m.storageB.columns[tableID]
		columnC := m.storageC.columns[tableID]
		columnD := m.storageD.columns[tableID]
		columnE := m.storageE.columns[tableID]
		columnF := m.storageF.columns[tableID]
		columnG := m.storageG.columns[tableID]
		columnH := m.storageH.columns[tableID]
		columnI := m.storageI.columns[tableID]
		columnJ := m.storageJ.columns[tableID]
		columnK := m.storageK.columns[tableID]
		for i := range count {
			index := uintptr(start + i)
			fn(
				table.GetEntity(index),
				(*A)(columnA.Get(index)),
				(*B)(columnB.Get(index)),
				(*C)(columnC.Get(index)),
				(*D)(columnD.Get(index)),
				(*E)(columnE.Get(index)),
				(*F)(columnF.Get(index)),
				(*G)(columnG.Get(index)),
				(*H)(columnH.Get(index)),
				(*I)(columnI.Get(index)),
				(*J)(columnJ.Get(index)),
				(*K)(columnK.Get(index)),
			)
		}
	}

	if hasCreateObs {
		table := &m.world.storage.tables[tableID]
		earlyOut := true
		for i := range count {
			index := uintptr(start + i)
			if !m.world.storage.observers.FireCreateEntity(table.GetEntity(index), &m.mask, earlyOut) {
				break
			}
			earlyOut = false
		}
	}
	if hasRelObs {
		table := &m.world.storage.tables[tableID]
		earlyOut := true
		for i := range count {
			index := uintptr(start + i)
			if !m.world.storage.observers.FireCreateEntityRel(table.GetEntity(index), &m.mask, earlyOut) {
				break
			}
			earlyOut = false
		}
	}

	if shouldLock {
		m.world.unlock(lock)
	}
}

// Get returns the mapped components for the given entity.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) Get(entity Entity) (*A, *B, *C, *D, *E, *F, *G, *H, *I, *J, *K) {
	if !m.world.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	index := &m.world.storage.entities[entity.id]
	return get[A](m.storageA, index), get[B](m.storageB, index), get[C](m.storageC, index), get[D](m.storageD, index), get[E](m.storageE, index), get[F](m.storageF, index), get[G](m.storageG, index), get[H](m.storageH, index), get[I](m.storageI, index), get[J](m.storageJ, index), get[K](m.storageK, index)
}

// GetUnchecked returns the mapped components for the given entity.
// In contrast to [Map11.Get], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) GetUnchecked(entity Entity) (*A, *B, *C, *D, *E, *F, *G, *H, *I, *J, *K) {
	index := &m.world.storage.entities[entity.id]
	return get[A](m.storageA, index), get[B](m.storageB, index), get[C](m.storageC, index), get[D](m.storageD, index), get[E](m.storageE, index), get[F](m.storageF, index), get[G](m.storageG, index), get[H](m.storageH, index), get[I](m.storageI, index), get[J](m.storageJ, index), get[K](m.storageK, index)
}

// HasAll return whether the given entity has all mapped components.
//
// Using [Map11.Get] and checking for nil pointer may be faster
// than calling [Map11.HasAll] and [Map11.Get] subsequently.
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	index := m.world.storage.entities[entity.id]
	return m.storageA.columns[index.table] != nil &&
		m.storageB.columns[index.table] != nil &&
		m.storageC.columns[index.table] != nil &&
		m.storageD.columns[index.table] != nil &&
		m.storageE.columns[index.table] != nil &&
		m.storageF.columns[index.table] != nil &&
		m.storageG.columns[index.table] != nil &&
		m.storageH.columns[index.table] != nil &&
		m.storageI.columns[index.table] != nil &&
		m.storageJ.columns[index.table] != nil &&
		m.storageK.columns[index.table] != nil
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) Add(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K, rel ...Relation) {
	m.AddFn(entity, func(pa *A, pb *B, pc *C, pd *D, pe *E, pf *F, pg *G, ph *H, pi *I, pj *J, pk *K) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
		*pg = *g
		*ph = *h
		*pi = *i
		*pj = *j
		*pk = *k
	}, rel...)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) AddFn(entity Entity, fn func(*A, *B, *C, *D, *E, *F, *G, *H, *I, *J, *K), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	oldMask, newMask := m.world.add(entity, m.ids, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
			(*G)(m.storageG.columns[index.table].Get(row)),
			(*H)(m.storageH.columns[index.table].Get(row)),
			(*I)(m.storageI.columns[index.table].Get(row)),
			(*J)(m.storageJ.columns[index.table].Get(row)),
			(*K)(m.storageK.columns[index.table].Get(row)),
		)
	}
	m.world.storage.observers.FireAddIfHas(OnAddComponents, entity, oldMask, newMask)
	if len(rel) > 0 {
		m.world.storage.observers.FireAddIfHas(OnAddRelations, entity, oldMask, newMask)
	}
}

// Set the mapped components of the given entity to the given values.
// Requires the entity to already have all the mapped components.
//
// Triggers an OnSetComponents event, which is not the case when assigning by
// pointer dereference or assigning to fields. This can be used to notify observers
// about component updates.
//
// This is not a component operation, so it can be performed on a locked world.
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) Set(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K) {
	if !m.world.Alive(entity) {
		panic("can't set components of a dead entity")
	}
	m.world.storage.checkHasComponent(entity, m.ids[0])
	m.world.storage.checkHasComponent(entity, m.ids[1])
	m.world.storage.checkHasComponent(entity, m.ids[2])
	m.world.storage.checkHasComponent(entity, m.ids[3])
	m.world.storage.checkHasComponent(entity, m.ids[4])
	m.world.storage.checkHasComponent(entity, m.ids[5])
	m.world.storage.checkHasComponent(entity, m.ids[6])
	m.world.storage.checkHasComponent(entity, m.ids[7])
	m.world.storage.checkHasComponent(entity, m.ids[8])
	m.world.storage.checkHasComponent(entity, m.ids[9])
	m.world.storage.checkHasComponent(entity, m.ids[10])

	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)
	*(*A)(m.storageA.columns[index.table].Get(row)) = *a
	*(*B)(m.storageB.columns[index.table].Get(row)) = *b
	*(*C)(m.storageC.columns[index.table].Get(row)) = *c
	*(*D)(m.storageD.columns[index.table].Get(row)) = *d
	*(*E)(m.storageE.columns[index.table].Get(row)) = *e
	*(*F)(m.storageF.columns[index.table].Get(row)) = *f
	*(*G)(m.storageG.columns[index.table].Get(row)) = *g
	*(*H)(m.storageH.columns[index.table].Get(row)) = *h
	*(*I)(m.storageI.columns[index.table].Get(row)) = *i
	*(*J)(m.storageJ.columns[index.table].Get(row)) = *j
	*(*K)(m.storageK.columns[index.table].Get(row)) = *k

	if m.world.storage.observers.HasObservers(OnSetComponents) {
		newMask := &m.world.storage.archetypes[m.world.storage.tables[index.table].archetype].mask
		m.world.storage.observers.FireSet(entity, &m.mask, newMask)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) AddBatch(batch Batch, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K, rel ...Relation) {
	m.AddBatchFn(batch, func(_ Entity, pa *A, pb *B, pc *C, pd *D, pe *E, pf *F, pg *G, ph *H, pi *I, pj *J, pk *K) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
		*pg = *g
		*ph = *h
		*pi = *i
		*pj = *j
		*pk = *k
	}, rel...)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) AddBatchFn(batch Batch, fn func(Entity, *A, *B, *C, *D, *E, *F, *G, *H, *I, *J, *K), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)

	var process func(tableID tableID, start, len uint32)
	if fn != nil {
		process = func(tableID tableID, start, len uint32) {
			table := &m.world.storage.tables[tableID]
			columnA := m.storageA.columns[tableID]
			columnB := m.storageB.columns[tableID]
			columnC := m.storageC.columns[tableID]
			columnD := m.storageD.columns[tableID]
			columnE := m.storageE.columns[tableID]
			columnF := m.storageF.columns[tableID]
			columnG := m.storageG.columns[tableID]
			columnH := m.storageH.columns[tableID]
			columnI := m.storageI.columns[tableID]
			columnJ := m.storageJ.columns[tableID]
			columnK := m.storageK.columns[tableID]

			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
					(*D)(columnD.Get(index)),
					(*E)(columnE.Get(index)),
					(*F)(columnF.Get(index)),
					(*G)(columnG.Get(index)),
					(*H)(columnH.Get(index)),
					(*I)(columnI.Get(index)),
					(*J)(columnJ.Get(index)),
					(*K)(columnK.Get(index)),
				)
			}
		}
	}
	m.world.exchangeBatch(&batch, m.ids, nil, m.relations, process)
}

// Remove the mapped components from the given entity.
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) Remove(entity Entity) {
	m.world.remove(entity, m.ids)
}

// RemoveBatch removes the mapped components from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) RemoveBatch(batch Batch, fn func(entity Entity)) {
	removeBatch(m.world, &batch, m.ids, fn)
}

// GetRelation returns the relation target of an entity for the component at the given index.
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) GetRelation(entity Entity, index int) Entity {
	if !m.world.Alive(entity) {
		panic("can't get entity relation target for a dead entity")
	}
	return m.GetRelationUnchecked(entity, index)
}

// GetRelationUnchecked returns the relation target of an entity for the component at the given index.
// In contrast to [Map11.GetRelation], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) GetRelationUnchecked(entity Entity, index int) Entity {
	return m.world.storage.getRelation(entity, m.ids[index])
}

// SetRelations sets relation targets for the given entity.
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) SetRelations(entity Entity, rel ...Relation) {
	// alive check is done in World.setRelations
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	m.world.setRelations(entity, m.relations)
}

// SetRelationsBatch sets relation targets for all entities matching the given batch filter.
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) SetRelationsBatch(batch Batch, fn func(entity Entity), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	setRelationsBatch(m.world, &batch, fn, m.relations)
}

// Map12 is a mapper to access 12 components of an entity.
//
// Instances should be created during initialization and stored, e.g. in systems.
//
// See [Map2] for a usage example.
type Map12[A any, B any, C any, D any, E any, F any, G any, H any, I any, J any, K any, L any] struct {
	mask      bitMask
	ids       []ID
	relations []relationID
	world     *World
	storageA  *componentStorage
	storageB  *componentStorage
	storageC  *componentStorage
	storageD  *componentStorage
	storageE  *componentStorage
	storageF  *componentStorage
	storageG  *componentStorage
	storageH  *componentStorage
	storageI  *componentStorage
	storageJ  *componentStorage
	storageK  *componentStorage
	storageL  *componentStorage
}

// New creates a new [Map12]. It is safe to call on `nil` instance.
// It is a helper method, intended to avoid repeated listing of type parameters.
//
// See [Map2.New] for an example.
func (_ *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) New(world *World) *Map12[A, B, C, D, E, F, G, H, I, J, K, L] {
	return NewMap12[A, B, C, D, E, F, G, H, I, J, K, L](world)
}

// NewMap12 creates a new [Map12].
func NewMap12[A any, B any, C any, D any, E any, F any, G any, H any, I any, J any, K any, L any](world *World) *Map12[A, B, C, D, E, F, G, H, I, J, K, L] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
		ComponentID[F](world),
		ComponentID[G](world),
		ComponentID[H](world),
		ComponentID[I](world),
		ComponentID[J](world),
		ComponentID[K](world),
		ComponentID[L](world),
	}
	return &Map12[A, B, C, D, E, F, G, H, I, J, K, L]{
		world:    world,
		ids:      ids,
		mask:     newMask(ids...),
		storageA: &world.storage.components[ids[0].id],
		storageB: &world.storage.components[ids[1].id],
		storageC: &world.storage.components[ids[2].id],
		storageD: &world.storage.components[ids[3].id],
		storageE: &world.storage.components[ids[4].id],
		storageF: &world.storage.components[ids[5].id],
		storageG: &world.storage.components[ids[6].id],
		storageH: &world.storage.components[ids[7].id],
		storageI: &world.storage.components[ids[8].id],
		storageJ: &world.storage.components[ids[9].id],
		storageK: &world.storage.components[ids[10].id],
		storageL: &world.storage.components[ids[11].id],
	}
}

// NewEntity creates a new entity with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) NewEntity(a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K, l *L, rel ...Relation) Entity {
	return m.NewEntityFn(func(pa *A, pb *B, pc *C, pd *D, pe *E, pf *F, pg *G, ph *H, pi *I, pj *J, pk *K, pl *L) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
		*pg = *g
		*ph = *h
		*pi = *i
		*pj = *j
		*pk = *k
		*pl = *l
	}, rel...)
}

// NewEntityFn creates a new entity with the mapped component and runs a callback instead of using a component for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) NewEntityFn(fn func(*A, *B, *C, *D, *E, *F, *G, *H, *I, *J, *K, *L), rel ...Relation) Entity {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	entity, mask := m.world.newEntity(m.ids, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
			(*G)(m.storageG.columns[index.table].Get(row)),
			(*H)(m.storageH.columns[index.table].Get(row)),
			(*I)(m.storageI.columns[index.table].Get(row)),
			(*J)(m.storageJ.columns[index.table].Get(row)),
			(*K)(m.storageK.columns[index.table].Get(row)),
			(*L)(m.storageL.columns[index.table].Get(row)),
		)
	}
	m.world.storage.observers.FireCreateEntityIfHas(entity, mask)
	if len(rel) > 0 {
		m.world.storage.observers.FireCreateEntityRelIfHas(entity, mask)
	}
	return entity
}

// NewBatch creates a batch of new entities with the mapped components.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) NewBatch(count int, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K, l *L, rel ...Relation) {
	m.NewBatchFn(count, func(_ Entity, pa *A, pb *B, pc *C, pd *D, pe *E, pf *F, pg *G, ph *H, pi *I, pj *J, pk *K, pl *L) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
		*pg = *g
		*ph = *h
		*pi = *i
		*pj = *j
		*pk = *k
		*pl = *l
	}, rel...)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided via the variadic arguments.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) NewBatchFn(count int, fn func(Entity, *A, *B, *C, *D, *E, *F, *G, *H, *I, *J, *K, *L), rel ...Relation) {
	m.world.checkLocked()
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)

	hasCreateObs := m.world.storage.observers.HasObservers(OnCreateEntity)
	hasRelObs := len(rel) > 0 && m.world.storage.observers.HasObservers(OnAddRelations)
	shouldLock := hasCreateObs || hasRelObs || fn != nil
	var lock uint8
	if shouldLock {
		lock = m.world.lock()
	}

	if fn != nil {
		table := &m.world.storage.tables[tableID]
		columnA := m.storageA.columns[tableID]
		columnB := m.storageB.columns[tableID]
		columnC := m.storageC.columns[tableID]
		columnD := m.storageD.columns[tableID]
		columnE := m.storageE.columns[tableID]
		columnF := m.storageF.columns[tableID]
		columnG := m.storageG.columns[tableID]
		columnH := m.storageH.columns[tableID]
		columnI := m.storageI.columns[tableID]
		columnJ := m.storageJ.columns[tableID]
		columnK := m.storageK.columns[tableID]
		columnL := m.storageL.columns[tableID]
		for i := range count {
			index := uintptr(start + i)
			fn(
				table.GetEntity(index),
				(*A)(columnA.Get(index)),
				(*B)(columnB.Get(index)),
				(*C)(columnC.Get(index)),
				(*D)(columnD.Get(index)),
				(*E)(columnE.Get(index)),
				(*F)(columnF.Get(index)),
				(*G)(columnG.Get(index)),
				(*H)(columnH.Get(index)),
				(*I)(columnI.Get(index)),
				(*J)(columnJ.Get(index)),
				(*K)(columnK.Get(index)),
				(*L)(columnL.Get(index)),
			)
		}
	}

	if hasCreateObs {
		table := &m.world.storage.tables[tableID]
		earlyOut := true
		for i := range count {
			index := uintptr(start + i)
			if !m.world.storage.observers.FireCreateEntity(table.GetEntity(index), &m.mask, earlyOut) {
				break
			}
			earlyOut = false
		}
	}
	if hasRelObs {
		table := &m.world.storage.tables[tableID]
		earlyOut := true
		for i := range count {
			index := uintptr(start + i)
			if !m.world.storage.observers.FireCreateEntityRel(table.GetEntity(index), &m.mask, earlyOut) {
				break
			}
			earlyOut = false
		}
	}

	if shouldLock {
		m.world.unlock(lock)
	}
}

// Get returns the mapped components for the given entity.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) Get(entity Entity) (*A, *B, *C, *D, *E, *F, *G, *H, *I, *J, *K, *L) {
	if !m.world.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	index := &m.world.storage.entities[entity.id]
	return get[A](m.storageA, index), get[B](m.storageB, index), get[C](m.storageC, index), get[D](m.storageD, index), get[E](m.storageE, index), get[F](m.storageF, index), get[G](m.storageG, index), get[H](m.storageH, index), get[I](m.storageI, index), get[J](m.storageJ, index), get[K](m.storageK, index), get[L](m.storageL, index)
}

// GetUnchecked returns the mapped components for the given entity.
// In contrast to [Map12.Get], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
//
// Return nil for components the entity is missing.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) GetUnchecked(entity Entity) (*A, *B, *C, *D, *E, *F, *G, *H, *I, *J, *K, *L) {
	index := &m.world.storage.entities[entity.id]
	return get[A](m.storageA, index), get[B](m.storageB, index), get[C](m.storageC, index), get[D](m.storageD, index), get[E](m.storageE, index), get[F](m.storageF, index), get[G](m.storageG, index), get[H](m.storageH, index), get[I](m.storageI, index), get[J](m.storageJ, index), get[K](m.storageK, index), get[L](m.storageL, index)
}

// HasAll return whether the given entity has all mapped components.
//
// Using [Map12.Get] and checking for nil pointer may be faster
// than calling [Map12.HasAll] and [Map12.Get] subsequently.
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	index := m.world.storage.entities[entity.id]
	return m.storageA.columns[index.table] != nil &&
		m.storageB.columns[index.table] != nil &&
		m.storageC.columns[index.table] != nil &&
		m.storageD.columns[index.table] != nil &&
		m.storageE.columns[index.table] != nil &&
		m.storageF.columns[index.table] != nil &&
		m.storageG.columns[index.table] != nil &&
		m.storageH.columns[index.table] != nil &&
		m.storageI.columns[index.table] != nil &&
		m.storageJ.columns[index.table] != nil &&
		m.storageK.columns[index.table] != nil &&
		m.storageL.columns[index.table] != nil
}

// Add the mapped components to the given entity.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) Add(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K, l *L, rel ...Relation) {
	m.AddFn(entity, func(pa *A, pb *B, pc *C, pd *D, pe *E, pf *F, pg *G, ph *H, pi *I, pj *J, pk *K, pl *L) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
		*pg = *g
		*ph = *h
		*pi = *i
		*pj = *j
		*pk = *k
		*pl = *l
	}, rel...)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) AddFn(entity Entity, fn func(*A, *B, *C, *D, *E, *F, *G, *H, *I, *J, *K, *L), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	oldMask, newMask := m.world.add(entity, m.ids, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
			(*G)(m.storageG.columns[index.table].Get(row)),
			(*H)(m.storageH.columns[index.table].Get(row)),
			(*I)(m.storageI.columns[index.table].Get(row)),
			(*J)(m.storageJ.columns[index.table].Get(row)),
			(*K)(m.storageK.columns[index.table].Get(row)),
			(*L)(m.storageL.columns[index.table].Get(row)),
		)
	}
	m.world.storage.observers.FireAddIfHas(OnAddComponents, entity, oldMask, newMask)
	if len(rel) > 0 {
		m.world.storage.observers.FireAddIfHas(OnAddRelations, entity, oldMask, newMask)
	}
}

// Set the mapped components of the given entity to the given values.
// Requires the entity to already have all the mapped components.
//
// Triggers an OnSetComponents event, which is not the case when assigning by
// pointer dereference or assigning to fields. This can be used to notify observers
// about component updates.
//
// This is not a component operation, so it can be performed on a locked world.
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) Set(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K, l *L) {
	if !m.world.Alive(entity) {
		panic("can't set components of a dead entity")
	}
	m.world.storage.checkHasComponent(entity, m.ids[0])
	m.world.storage.checkHasComponent(entity, m.ids[1])
	m.world.storage.checkHasComponent(entity, m.ids[2])
	m.world.storage.checkHasComponent(entity, m.ids[3])
	m.world.storage.checkHasComponent(entity, m.ids[4])
	m.world.storage.checkHasComponent(entity, m.ids[5])
	m.world.storage.checkHasComponent(entity, m.ids[6])
	m.world.storage.checkHasComponent(entity, m.ids[7])
	m.world.storage.checkHasComponent(entity, m.ids[8])
	m.world.storage.checkHasComponent(entity, m.ids[9])
	m.world.storage.checkHasComponent(entity, m.ids[10])
	m.world.storage.checkHasComponent(entity, m.ids[11])

	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)
	*(*A)(m.storageA.columns[index.table].Get(row)) = *a
	*(*B)(m.storageB.columns[index.table].Get(row)) = *b
	*(*C)(m.storageC.columns[index.table].Get(row)) = *c
	*(*D)(m.storageD.columns[index.table].Get(row)) = *d
	*(*E)(m.storageE.columns[index.table].Get(row)) = *e
	*(*F)(m.storageF.columns[index.table].Get(row)) = *f
	*(*G)(m.storageG.columns[index.table].Get(row)) = *g
	*(*H)(m.storageH.columns[index.table].Get(row)) = *h
	*(*I)(m.storageI.columns[index.table].Get(row)) = *i
	*(*J)(m.storageJ.columns[index.table].Get(row)) = *j
	*(*K)(m.storageK.columns[index.table].Get(row)) = *k
	*(*L)(m.storageL.columns[index.table].Get(row)) = *l

	if m.world.storage.observers.HasObservers(OnSetComponents) {
		newMask := &m.world.storage.archetypes[m.world.storage.tables[index.table].archetype].mask
		m.world.storage.observers.FireSet(entity, &m.mask, newMask)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) AddBatch(batch Batch, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K, l *L, rel ...Relation) {
	m.AddBatchFn(batch, func(_ Entity, pa *A, pb *B, pc *C, pd *D, pe *E, pf *F, pg *G, ph *H, pi *I, pj *J, pk *K, pl *L) {
		*pa = *a
		*pb = *b
		*pc = *c
		*pd = *d
		*pe = *e
		*pf = *f
		*pg = *g
		*ph = *h
		*pi = *i
		*pj = *j
		*pk = *k
		*pl = *l
	}, rel...)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
//
// For each mapped component that is a relationships (see [RelationMarker]),
// a relation target entity must be provided.
//
// ⚠️ Do not store the obtained pointers outside of the current context!
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) AddBatchFn(batch Batch, fn func(Entity, *A, *B, *C, *D, *E, *F, *G, *H, *I, *J, *K, *L), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)

	var process func(tableID tableID, start, len uint32)
	if fn != nil {
		process = func(tableID tableID, start, len uint32) {
			table := &m.world.storage.tables[tableID]
			columnA := m.storageA.columns[tableID]
			columnB := m.storageB.columns[tableID]
			columnC := m.storageC.columns[tableID]
			columnD := m.storageD.columns[tableID]
			columnE := m.storageE.columns[tableID]
			columnF := m.storageF.columns[tableID]
			columnG := m.storageG.columns[tableID]
			columnH := m.storageH.columns[tableID]
			columnI := m.storageI.columns[tableID]
			columnJ := m.storageJ.columns[tableID]
			columnK := m.storageK.columns[tableID]
			columnL := m.storageL.columns[tableID]

			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
					(*D)(columnD.Get(index)),
					(*E)(columnE.Get(index)),
					(*F)(columnF.Get(index)),
					(*G)(columnG.Get(index)),
					(*H)(columnH.Get(index)),
					(*I)(columnI.Get(index)),
					(*J)(columnJ.Get(index)),
					(*K)(columnK.Get(index)),
					(*L)(columnL.Get(index)),
				)
			}
		}
	}
	m.world.exchangeBatch(&batch, m.ids, nil, m.relations, process)
}

// Remove the mapped components from the given entity.
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) Remove(entity Entity) {
	m.world.remove(entity, m.ids)
}

// RemoveBatch removes the mapped components from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) RemoveBatch(batch Batch, fn func(entity Entity)) {
	removeBatch(m.world, &batch, m.ids, fn)
}

// GetRelation returns the relation target of an entity for the component at the given index.
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) GetRelation(entity Entity, index int) Entity {
	if !m.world.Alive(entity) {
		panic("can't get entity relation target for a dead entity")
	}
	return m.GetRelationUnchecked(entity, index)
}

// GetRelationUnchecked returns the relation target of an entity for the component at the given index.
// In contrast to [Map12.GetRelation], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) GetRelationUnchecked(entity Entity, index int) Entity {
	return m.world.storage.getRelation(entity, m.ids[index])
}

// SetRelations sets relation targets for the given entity.
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) SetRelations(entity Entity, rel ...Relation) {
	// alive check is done in World.setRelations
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	m.world.setRelations(entity, m.relations)
}

// SetRelationsBatch sets relation targets for all entities matching the given batch filter.
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) SetRelationsBatch(batch Batch, fn func(entity Entity), rel ...Relation) {
	m.relations = relationSlice(rel).ToRelations(m.world, &m.mask, m.ids, m.relations[:0], false)
	setRelationsBatch(m.world, &batch, fn, m.relations)
}
