package ecs

// Code generated by go generate; DO NOT EDIT.

import "unsafe"

// Map1 is a mapper to access 1 components of an entity.
type Map1[A any] struct {
	world     *World
	ids       []ID
	storageA  *componentStorage
	relations []RelationID
}

// NewMap1 creates a new [Map1].
func NewMap1[A any](world *World) Map1[A] {
	ids := []ID{
		ComponentID[A](world),
	}
	return Map1[A]{
		world:    world,
		ids:      ids,
		storageA: &world.storage.components[ids[0].id],
	}
}

// NewEntity creates a new entity with the mapped components.
func (m *Map1[A]) NewEntity(a *A, rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	return m.world.newEntityWith(m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
	}, m.relations)
}

// NewEntityFn creates a new entity with the mapped component and runs a callback instead of using a component for initialization.
// The callback can be nil.
func (m *Map1[A]) NewEntityFn(fn func(a *A), rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	entity := m.world.newEntityWith(m.ids, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
		)
	}
	return entity
}

// NewBatch creates a batch of new entities with the mapped components.
func (m *Map1[A]) NewBatch(count int, a *A, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.newEntitiesWith(count, m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
	}, m.relations)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
func (m *Map1[A]) NewBatchFn(count int, fn func(entity Entity, a *A), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)
	if fn == nil {
		return
	}

	table := &m.world.storage.tables[tableID]
	columnA := m.storageA.columns[tableID]

	lock := m.world.lock()
	for i := range count {
		index := uintptr(start + i)
		fn(
			table.GetEntity(index),
			(*A)(columnA.Get(index)),
		)
	}
	m.world.unlock(lock)
}

// Get returns the mapped components for the given entity.
//
// ⚠️ Do not store the obtained pointer outside of the current context!
func (m *Map1[A]) Get(entity Entity) *A {
	if !m.world.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	return m.GetUnchecked(entity)
}

// GetUnchecked returns the mapped components for the given entity.
// In contrast to [Map1.Get], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
//
// ⚠️ Do not store the obtained pointer outside of the current context!
func (m *Map1[A]) GetUnchecked(entity Entity) *A {
	m.world.storage.checkHasComponent(entity, m.ids[0])

	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)

	return (*A)(m.storageA.columns[index.table].Get(row))
}

// HasAll return whether the given entity has all mapped components.
func (m *Map1[A]) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	index := m.world.storage.entities[entity.id]
	return m.storageA.columns[index.table] != nil
}

// Add the mapped components to the given entity.
func (m *Map1[A]) Add(entity Entity, a *A, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.exchange(entity, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
	}, m.relations)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
func (m *Map1[A]) AddFn(entity Entity, fn func(a *A), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.exchange(entity, m.ids, nil, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
		)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
func (m *Map1[A]) AddBatch(batch *Batch, a *A, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.exchangeBatch(batch, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
	}, m.relations, nil)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map1[A]) AddBatchFn(batch *Batch, fn func(entity Entity, a *A), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]
			columnA := m.storageA.columns[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
				)
			}
			m.world.unlock(lock)
		}
	}
	m.world.exchangeBatch(batch, m.ids, nil, nil, m.relations, process)
}

// Remove the mapped components from the given entity.
func (m *Map1[A]) Remove(entity Entity) {
	m.world.exchange(entity, nil, m.ids, nil, nil)
}

// RemoveBatch removes the mapped components from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map1[A]) RemoveBatch(batch *Batch, fn func(entity Entity)) {
	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(table.GetEntity(index))
			}
			m.world.unlock(lock)
		}
	}
	m.world.exchangeBatch(batch, nil, m.ids, nil, nil, process)
}

// GetRelation returns the relation target of an entity for the component at the given index.
func (m *Map1[A]) GetRelation(entity Entity, index int) Entity {
	if !m.world.Alive(entity) {
		panic("can't get entity relation target for a dead entity")
	}
	return m.GetRelationUnchecked(entity, index)
}

// GetRelationUnchecked returns the relation target of an entity for the component at the given index.
// In contrast to [Map1.GetRelation], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map1[A]) GetRelationUnchecked(entity Entity, index int) Entity {
	return m.world.storage.getRelation(entity, m.ids[index])
}

// SetRelations sets relation targets for the given entity.
func (m *Map1[A]) SetRelations(entity Entity, rel ...Relation) {
	// alive check is done in World.setRelations
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.setRelations(entity, m.relations)
}

// SetRelationsBatch sets relation targets for all entities matching the given batch filter.
func (m *Map1[A]) SetRelationsBatch(batch *Batch, fn func(entity Entity), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(table.GetEntity(index))
			}
			m.world.unlock(lock)
		}
	}
	m.world.setRelationsBatch(batch, m.relations, process)
}

// Map2 is a mapper to access 2 components of an entity.
type Map2[A any, B any] struct {
	world     *World
	ids       []ID
	storageA  *componentStorage
	storageB  *componentStorage
	relations []RelationID
}

// NewMap2 creates a new [Map2].
func NewMap2[A any, B any](world *World) Map2[A, B] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
	}
	return Map2[A, B]{
		world:    world,
		ids:      ids,
		storageA: &world.storage.components[ids[0].id],
		storageB: &world.storage.components[ids[1].id],
	}
}

// NewEntity creates a new entity with the mapped components.
func (m *Map2[A, B]) NewEntity(a *A, b *B, rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	return m.world.newEntityWith(m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
	}, m.relations)
}

// NewEntityFn creates a new entity with the mapped component and runs a callback instead of using a component for initialization.
// The callback can be nil.
func (m *Map2[A, B]) NewEntityFn(fn func(a *A, b *B), rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	entity := m.world.newEntityWith(m.ids, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
		)
	}
	return entity
}

// NewBatch creates a batch of new entities with the mapped components.
func (m *Map2[A, B]) NewBatch(count int, a *A, b *B, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.newEntitiesWith(count, m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
	}, m.relations)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
func (m *Map2[A, B]) NewBatchFn(count int, fn func(entity Entity, a *A, b *B), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)
	if fn == nil {
		return
	}

	table := &m.world.storage.tables[tableID]
	columnA := m.storageA.columns[tableID]
	columnB := m.storageB.columns[tableID]

	lock := m.world.lock()
	for i := range count {
		index := uintptr(start + i)
		fn(
			table.GetEntity(index),
			(*A)(columnA.Get(index)),
			(*B)(columnB.Get(index)),
		)
	}
	m.world.unlock(lock)
}

// Get returns the mapped components for the given entity.
//
// ⚠️ Do not store the obtained pointer outside of the current context!
func (m *Map2[A, B]) Get(entity Entity) (*A, *B) {
	if !m.world.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	return m.GetUnchecked(entity)
}

// GetUnchecked returns the mapped components for the given entity.
// In contrast to [Map2.Get], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
//
// ⚠️ Do not store the obtained pointer outside of the current context!
func (m *Map2[A, B]) GetUnchecked(entity Entity) (*A, *B) {
	m.world.storage.checkHasComponent(entity, m.ids[0])
	m.world.storage.checkHasComponent(entity, m.ids[1])

	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)

	return (*A)(m.storageA.columns[index.table].Get(row)),
		(*B)(m.storageB.columns[index.table].Get(row))
}

// HasAll return whether the given entity has all mapped components.
func (m *Map2[A, B]) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	index := m.world.storage.entities[entity.id]
	return m.storageA.columns[index.table] != nil &&
		m.storageB.columns[index.table] != nil
}

// Add the mapped components to the given entity.
func (m *Map2[A, B]) Add(entity Entity, a *A, b *B, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.exchange(entity, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
	}, m.relations)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
func (m *Map2[A, B]) AddFn(entity Entity, fn func(a *A, b *B), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.exchange(entity, m.ids, nil, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
		)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
func (m *Map2[A, B]) AddBatch(batch *Batch, a *A, b *B, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.exchangeBatch(batch, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
	}, m.relations, nil)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map2[A, B]) AddBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]
			columnA := m.storageA.columns[tableID]
			columnB := m.storageB.columns[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
				)
			}
			m.world.unlock(lock)
		}
	}
	m.world.exchangeBatch(batch, m.ids, nil, nil, m.relations, process)
}

// Remove the mapped components from the given entity.
func (m *Map2[A, B]) Remove(entity Entity) {
	m.world.exchange(entity, nil, m.ids, nil, nil)
}

// RemoveBatch removes the mapped components from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map2[A, B]) RemoveBatch(batch *Batch, fn func(entity Entity)) {
	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(table.GetEntity(index))
			}
			m.world.unlock(lock)
		}
	}
	m.world.exchangeBatch(batch, nil, m.ids, nil, nil, process)
}

// GetRelation returns the relation target of an entity for the component at the given index.
func (m *Map2[A, B]) GetRelation(entity Entity, index int) Entity {
	if !m.world.Alive(entity) {
		panic("can't get entity relation target for a dead entity")
	}
	return m.GetRelationUnchecked(entity, index)
}

// GetRelationUnchecked returns the relation target of an entity for the component at the given index.
// In contrast to [Map2.GetRelation], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map2[A, B]) GetRelationUnchecked(entity Entity, index int) Entity {
	return m.world.storage.getRelation(entity, m.ids[index])
}

// SetRelations sets relation targets for the given entity.
func (m *Map2[A, B]) SetRelations(entity Entity, rel ...Relation) {
	// alive check is done in World.setRelations
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.setRelations(entity, m.relations)
}

// SetRelationsBatch sets relation targets for all entities matching the given batch filter.
func (m *Map2[A, B]) SetRelationsBatch(batch *Batch, fn func(entity Entity), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(table.GetEntity(index))
			}
			m.world.unlock(lock)
		}
	}
	m.world.setRelationsBatch(batch, m.relations, process)
}

// Map3 is a mapper to access 3 components of an entity.
type Map3[A any, B any, C any] struct {
	world     *World
	ids       []ID
	storageA  *componentStorage
	storageB  *componentStorage
	storageC  *componentStorage
	relations []RelationID
}

// NewMap3 creates a new [Map3].
func NewMap3[A any, B any, C any](world *World) Map3[A, B, C] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
	}
	return Map3[A, B, C]{
		world:    world,
		ids:      ids,
		storageA: &world.storage.components[ids[0].id],
		storageB: &world.storage.components[ids[1].id],
		storageC: &world.storage.components[ids[2].id],
	}
}

// NewEntity creates a new entity with the mapped components.
func (m *Map3[A, B, C]) NewEntity(a *A, b *B, c *C, rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	return m.world.newEntityWith(m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
	}, m.relations)
}

// NewEntityFn creates a new entity with the mapped component and runs a callback instead of using a component for initialization.
// The callback can be nil.
func (m *Map3[A, B, C]) NewEntityFn(fn func(a *A, b *B, c *C), rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	entity := m.world.newEntityWith(m.ids, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
		)
	}
	return entity
}

// NewBatch creates a batch of new entities with the mapped components.
func (m *Map3[A, B, C]) NewBatch(count int, a *A, b *B, c *C, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.newEntitiesWith(count, m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
	}, m.relations)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
func (m *Map3[A, B, C]) NewBatchFn(count int, fn func(entity Entity, a *A, b *B, c *C), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)
	if fn == nil {
		return
	}

	table := &m.world.storage.tables[tableID]
	columnA := m.storageA.columns[tableID]
	columnB := m.storageB.columns[tableID]
	columnC := m.storageC.columns[tableID]

	lock := m.world.lock()
	for i := range count {
		index := uintptr(start + i)
		fn(
			table.GetEntity(index),
			(*A)(columnA.Get(index)),
			(*B)(columnB.Get(index)),
			(*C)(columnC.Get(index)),
		)
	}
	m.world.unlock(lock)
}

// Get returns the mapped components for the given entity.
//
// ⚠️ Do not store the obtained pointer outside of the current context!
func (m *Map3[A, B, C]) Get(entity Entity) (*A, *B, *C) {
	if !m.world.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	return m.GetUnchecked(entity)
}

// GetUnchecked returns the mapped components for the given entity.
// In contrast to [Map3.Get], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
//
// ⚠️ Do not store the obtained pointer outside of the current context!
func (m *Map3[A, B, C]) GetUnchecked(entity Entity) (*A, *B, *C) {
	m.world.storage.checkHasComponent(entity, m.ids[0])
	m.world.storage.checkHasComponent(entity, m.ids[1])
	m.world.storage.checkHasComponent(entity, m.ids[2])

	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)

	return (*A)(m.storageA.columns[index.table].Get(row)),
		(*B)(m.storageB.columns[index.table].Get(row)),
		(*C)(m.storageC.columns[index.table].Get(row))
}

// HasAll return whether the given entity has all mapped components.
func (m *Map3[A, B, C]) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	index := m.world.storage.entities[entity.id]
	return m.storageA.columns[index.table] != nil &&
		m.storageB.columns[index.table] != nil &&
		m.storageC.columns[index.table] != nil
}

// Add the mapped components to the given entity.
func (m *Map3[A, B, C]) Add(entity Entity, a *A, b *B, c *C, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.exchange(entity, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
	}, m.relations)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
func (m *Map3[A, B, C]) AddFn(entity Entity, fn func(a *A, b *B, c *C), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.exchange(entity, m.ids, nil, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
		)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
func (m *Map3[A, B, C]) AddBatch(batch *Batch, a *A, b *B, c *C, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.exchangeBatch(batch, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
	}, m.relations, nil)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map3[A, B, C]) AddBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]
			columnA := m.storageA.columns[tableID]
			columnB := m.storageB.columns[tableID]
			columnC := m.storageC.columns[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
				)
			}
			m.world.unlock(lock)
		}
	}
	m.world.exchangeBatch(batch, m.ids, nil, nil, m.relations, process)
}

// Remove the mapped components from the given entity.
func (m *Map3[A, B, C]) Remove(entity Entity) {
	m.world.exchange(entity, nil, m.ids, nil, nil)
}

// RemoveBatch removes the mapped components from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map3[A, B, C]) RemoveBatch(batch *Batch, fn func(entity Entity)) {
	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(table.GetEntity(index))
			}
			m.world.unlock(lock)
		}
	}
	m.world.exchangeBatch(batch, nil, m.ids, nil, nil, process)
}

// GetRelation returns the relation target of an entity for the component at the given index.
func (m *Map3[A, B, C]) GetRelation(entity Entity, index int) Entity {
	if !m.world.Alive(entity) {
		panic("can't get entity relation target for a dead entity")
	}
	return m.GetRelationUnchecked(entity, index)
}

// GetRelationUnchecked returns the relation target of an entity for the component at the given index.
// In contrast to [Map3.GetRelation], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map3[A, B, C]) GetRelationUnchecked(entity Entity, index int) Entity {
	return m.world.storage.getRelation(entity, m.ids[index])
}

// SetRelations sets relation targets for the given entity.
func (m *Map3[A, B, C]) SetRelations(entity Entity, rel ...Relation) {
	// alive check is done in World.setRelations
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.setRelations(entity, m.relations)
}

// SetRelationsBatch sets relation targets for all entities matching the given batch filter.
func (m *Map3[A, B, C]) SetRelationsBatch(batch *Batch, fn func(entity Entity), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(table.GetEntity(index))
			}
			m.world.unlock(lock)
		}
	}
	m.world.setRelationsBatch(batch, m.relations, process)
}

// Map4 is a mapper to access 4 components of an entity.
type Map4[A any, B any, C any, D any] struct {
	world     *World
	ids       []ID
	storageA  *componentStorage
	storageB  *componentStorage
	storageC  *componentStorage
	storageD  *componentStorage
	relations []RelationID
}

// NewMap4 creates a new [Map4].
func NewMap4[A any, B any, C any, D any](world *World) Map4[A, B, C, D] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
	}
	return Map4[A, B, C, D]{
		world:    world,
		ids:      ids,
		storageA: &world.storage.components[ids[0].id],
		storageB: &world.storage.components[ids[1].id],
		storageC: &world.storage.components[ids[2].id],
		storageD: &world.storage.components[ids[3].id],
	}
}

// NewEntity creates a new entity with the mapped components.
func (m *Map4[A, B, C, D]) NewEntity(a *A, b *B, c *C, d *D, rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	return m.world.newEntityWith(m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
	}, m.relations)
}

// NewEntityFn creates a new entity with the mapped component and runs a callback instead of using a component for initialization.
// The callback can be nil.
func (m *Map4[A, B, C, D]) NewEntityFn(fn func(a *A, b *B, c *C, d *D), rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	entity := m.world.newEntityWith(m.ids, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
		)
	}
	return entity
}

// NewBatch creates a batch of new entities with the mapped components.
func (m *Map4[A, B, C, D]) NewBatch(count int, a *A, b *B, c *C, d *D, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.newEntitiesWith(count, m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
	}, m.relations)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
func (m *Map4[A, B, C, D]) NewBatchFn(count int, fn func(entity Entity, a *A, b *B, c *C, d *D), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)
	if fn == nil {
		return
	}

	table := &m.world.storage.tables[tableID]
	columnA := m.storageA.columns[tableID]
	columnB := m.storageB.columns[tableID]
	columnC := m.storageC.columns[tableID]
	columnD := m.storageD.columns[tableID]

	lock := m.world.lock()
	for i := range count {
		index := uintptr(start + i)
		fn(
			table.GetEntity(index),
			(*A)(columnA.Get(index)),
			(*B)(columnB.Get(index)),
			(*C)(columnC.Get(index)),
			(*D)(columnD.Get(index)),
		)
	}
	m.world.unlock(lock)
}

// Get returns the mapped components for the given entity.
//
// ⚠️ Do not store the obtained pointer outside of the current context!
func (m *Map4[A, B, C, D]) Get(entity Entity) (*A, *B, *C, *D) {
	if !m.world.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	return m.GetUnchecked(entity)
}

// GetUnchecked returns the mapped components for the given entity.
// In contrast to [Map4.Get], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
//
// ⚠️ Do not store the obtained pointer outside of the current context!
func (m *Map4[A, B, C, D]) GetUnchecked(entity Entity) (*A, *B, *C, *D) {
	m.world.storage.checkHasComponent(entity, m.ids[0])
	m.world.storage.checkHasComponent(entity, m.ids[1])
	m.world.storage.checkHasComponent(entity, m.ids[2])
	m.world.storage.checkHasComponent(entity, m.ids[3])

	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)

	return (*A)(m.storageA.columns[index.table].Get(row)),
		(*B)(m.storageB.columns[index.table].Get(row)),
		(*C)(m.storageC.columns[index.table].Get(row)),
		(*D)(m.storageD.columns[index.table].Get(row))
}

// HasAll return whether the given entity has all mapped components.
func (m *Map4[A, B, C, D]) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	index := m.world.storage.entities[entity.id]
	return m.storageA.columns[index.table] != nil &&
		m.storageB.columns[index.table] != nil &&
		m.storageC.columns[index.table] != nil &&
		m.storageD.columns[index.table] != nil
}

// Add the mapped components to the given entity.
func (m *Map4[A, B, C, D]) Add(entity Entity, a *A, b *B, c *C, d *D, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.exchange(entity, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
	}, m.relations)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
func (m *Map4[A, B, C, D]) AddFn(entity Entity, fn func(a *A, b *B, c *C, d *D), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.exchange(entity, m.ids, nil, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
		)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
func (m *Map4[A, B, C, D]) AddBatch(batch *Batch, a *A, b *B, c *C, d *D, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.exchangeBatch(batch, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
	}, m.relations, nil)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map4[A, B, C, D]) AddBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C, d *D), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]
			columnA := m.storageA.columns[tableID]
			columnB := m.storageB.columns[tableID]
			columnC := m.storageC.columns[tableID]
			columnD := m.storageD.columns[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
					(*D)(columnD.Get(index)),
				)
			}
			m.world.unlock(lock)
		}
	}
	m.world.exchangeBatch(batch, m.ids, nil, nil, m.relations, process)
}

// Remove the mapped components from the given entity.
func (m *Map4[A, B, C, D]) Remove(entity Entity) {
	m.world.exchange(entity, nil, m.ids, nil, nil)
}

// RemoveBatch removes the mapped components from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map4[A, B, C, D]) RemoveBatch(batch *Batch, fn func(entity Entity)) {
	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(table.GetEntity(index))
			}
			m.world.unlock(lock)
		}
	}
	m.world.exchangeBatch(batch, nil, m.ids, nil, nil, process)
}

// GetRelation returns the relation target of an entity for the component at the given index.
func (m *Map4[A, B, C, D]) GetRelation(entity Entity, index int) Entity {
	if !m.world.Alive(entity) {
		panic("can't get entity relation target for a dead entity")
	}
	return m.GetRelationUnchecked(entity, index)
}

// GetRelationUnchecked returns the relation target of an entity for the component at the given index.
// In contrast to [Map4.GetRelation], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map4[A, B, C, D]) GetRelationUnchecked(entity Entity, index int) Entity {
	return m.world.storage.getRelation(entity, m.ids[index])
}

// SetRelations sets relation targets for the given entity.
func (m *Map4[A, B, C, D]) SetRelations(entity Entity, rel ...Relation) {
	// alive check is done in World.setRelations
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.setRelations(entity, m.relations)
}

// SetRelationsBatch sets relation targets for all entities matching the given batch filter.
func (m *Map4[A, B, C, D]) SetRelationsBatch(batch *Batch, fn func(entity Entity), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(table.GetEntity(index))
			}
			m.world.unlock(lock)
		}
	}
	m.world.setRelationsBatch(batch, m.relations, process)
}

// Map5 is a mapper to access 5 components of an entity.
type Map5[A any, B any, C any, D any, E any] struct {
	world     *World
	ids       []ID
	storageA  *componentStorage
	storageB  *componentStorage
	storageC  *componentStorage
	storageD  *componentStorage
	storageE  *componentStorage
	relations []RelationID
}

// NewMap5 creates a new [Map5].
func NewMap5[A any, B any, C any, D any, E any](world *World) Map5[A, B, C, D, E] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
	}
	return Map5[A, B, C, D, E]{
		world:    world,
		ids:      ids,
		storageA: &world.storage.components[ids[0].id],
		storageB: &world.storage.components[ids[1].id],
		storageC: &world.storage.components[ids[2].id],
		storageD: &world.storage.components[ids[3].id],
		storageE: &world.storage.components[ids[4].id],
	}
}

// NewEntity creates a new entity with the mapped components.
func (m *Map5[A, B, C, D, E]) NewEntity(a *A, b *B, c *C, d *D, e *E, rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	return m.world.newEntityWith(m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
	}, m.relations)
}

// NewEntityFn creates a new entity with the mapped component and runs a callback instead of using a component for initialization.
// The callback can be nil.
func (m *Map5[A, B, C, D, E]) NewEntityFn(fn func(a *A, b *B, c *C, d *D, e *E), rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	entity := m.world.newEntityWith(m.ids, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
		)
	}
	return entity
}

// NewBatch creates a batch of new entities with the mapped components.
func (m *Map5[A, B, C, D, E]) NewBatch(count int, a *A, b *B, c *C, d *D, e *E, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.newEntitiesWith(count, m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
	}, m.relations)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
func (m *Map5[A, B, C, D, E]) NewBatchFn(count int, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)
	if fn == nil {
		return
	}

	table := &m.world.storage.tables[tableID]
	columnA := m.storageA.columns[tableID]
	columnB := m.storageB.columns[tableID]
	columnC := m.storageC.columns[tableID]
	columnD := m.storageD.columns[tableID]
	columnE := m.storageE.columns[tableID]

	lock := m.world.lock()
	for i := range count {
		index := uintptr(start + i)
		fn(
			table.GetEntity(index),
			(*A)(columnA.Get(index)),
			(*B)(columnB.Get(index)),
			(*C)(columnC.Get(index)),
			(*D)(columnD.Get(index)),
			(*E)(columnE.Get(index)),
		)
	}
	m.world.unlock(lock)
}

// Get returns the mapped components for the given entity.
//
// ⚠️ Do not store the obtained pointer outside of the current context!
func (m *Map5[A, B, C, D, E]) Get(entity Entity) (*A, *B, *C, *D, *E) {
	if !m.world.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	return m.GetUnchecked(entity)
}

// GetUnchecked returns the mapped components for the given entity.
// In contrast to [Map5.Get], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
//
// ⚠️ Do not store the obtained pointer outside of the current context!
func (m *Map5[A, B, C, D, E]) GetUnchecked(entity Entity) (*A, *B, *C, *D, *E) {
	m.world.storage.checkHasComponent(entity, m.ids[0])
	m.world.storage.checkHasComponent(entity, m.ids[1])
	m.world.storage.checkHasComponent(entity, m.ids[2])
	m.world.storage.checkHasComponent(entity, m.ids[3])
	m.world.storage.checkHasComponent(entity, m.ids[4])

	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)

	return (*A)(m.storageA.columns[index.table].Get(row)),
		(*B)(m.storageB.columns[index.table].Get(row)),
		(*C)(m.storageC.columns[index.table].Get(row)),
		(*D)(m.storageD.columns[index.table].Get(row)),
		(*E)(m.storageE.columns[index.table].Get(row))
}

// HasAll return whether the given entity has all mapped components.
func (m *Map5[A, B, C, D, E]) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	index := m.world.storage.entities[entity.id]
	return m.storageA.columns[index.table] != nil &&
		m.storageB.columns[index.table] != nil &&
		m.storageC.columns[index.table] != nil &&
		m.storageD.columns[index.table] != nil &&
		m.storageE.columns[index.table] != nil
}

// Add the mapped components to the given entity.
func (m *Map5[A, B, C, D, E]) Add(entity Entity, a *A, b *B, c *C, d *D, e *E, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.exchange(entity, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
	}, m.relations)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
func (m *Map5[A, B, C, D, E]) AddFn(entity Entity, fn func(a *A, b *B, c *C, d *D, e *E), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.exchange(entity, m.ids, nil, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
		)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
func (m *Map5[A, B, C, D, E]) AddBatch(batch *Batch, a *A, b *B, c *C, d *D, e *E, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.exchangeBatch(batch, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
	}, m.relations, nil)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map5[A, B, C, D, E]) AddBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]
			columnA := m.storageA.columns[tableID]
			columnB := m.storageB.columns[tableID]
			columnC := m.storageC.columns[tableID]
			columnD := m.storageD.columns[tableID]
			columnE := m.storageE.columns[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
					(*D)(columnD.Get(index)),
					(*E)(columnE.Get(index)),
				)
			}
			m.world.unlock(lock)
		}
	}
	m.world.exchangeBatch(batch, m.ids, nil, nil, m.relations, process)
}

// Remove the mapped components from the given entity.
func (m *Map5[A, B, C, D, E]) Remove(entity Entity) {
	m.world.exchange(entity, nil, m.ids, nil, nil)
}

// RemoveBatch removes the mapped components from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map5[A, B, C, D, E]) RemoveBatch(batch *Batch, fn func(entity Entity)) {
	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(table.GetEntity(index))
			}
			m.world.unlock(lock)
		}
	}
	m.world.exchangeBatch(batch, nil, m.ids, nil, nil, process)
}

// GetRelation returns the relation target of an entity for the component at the given index.
func (m *Map5[A, B, C, D, E]) GetRelation(entity Entity, index int) Entity {
	if !m.world.Alive(entity) {
		panic("can't get entity relation target for a dead entity")
	}
	return m.GetRelationUnchecked(entity, index)
}

// GetRelationUnchecked returns the relation target of an entity for the component at the given index.
// In contrast to [Map5.GetRelation], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map5[A, B, C, D, E]) GetRelationUnchecked(entity Entity, index int) Entity {
	return m.world.storage.getRelation(entity, m.ids[index])
}

// SetRelations sets relation targets for the given entity.
func (m *Map5[A, B, C, D, E]) SetRelations(entity Entity, rel ...Relation) {
	// alive check is done in World.setRelations
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.setRelations(entity, m.relations)
}

// SetRelationsBatch sets relation targets for all entities matching the given batch filter.
func (m *Map5[A, B, C, D, E]) SetRelationsBatch(batch *Batch, fn func(entity Entity), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(table.GetEntity(index))
			}
			m.world.unlock(lock)
		}
	}
	m.world.setRelationsBatch(batch, m.relations, process)
}

// Map6 is a mapper to access 6 components of an entity.
type Map6[A any, B any, C any, D any, E any, F any] struct {
	world     *World
	ids       []ID
	storageA  *componentStorage
	storageB  *componentStorage
	storageC  *componentStorage
	storageD  *componentStorage
	storageE  *componentStorage
	storageF  *componentStorage
	relations []RelationID
}

// NewMap6 creates a new [Map6].
func NewMap6[A any, B any, C any, D any, E any, F any](world *World) Map6[A, B, C, D, E, F] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
		ComponentID[F](world),
	}
	return Map6[A, B, C, D, E, F]{
		world:    world,
		ids:      ids,
		storageA: &world.storage.components[ids[0].id],
		storageB: &world.storage.components[ids[1].id],
		storageC: &world.storage.components[ids[2].id],
		storageD: &world.storage.components[ids[3].id],
		storageE: &world.storage.components[ids[4].id],
		storageF: &world.storage.components[ids[5].id],
	}
}

// NewEntity creates a new entity with the mapped components.
func (m *Map6[A, B, C, D, E, F]) NewEntity(a *A, b *B, c *C, d *D, e *E, f *F, rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	return m.world.newEntityWith(m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
	}, m.relations)
}

// NewEntityFn creates a new entity with the mapped component and runs a callback instead of using a component for initialization.
// The callback can be nil.
func (m *Map6[A, B, C, D, E, F]) NewEntityFn(fn func(a *A, b *B, c *C, d *D, e *E, f *F), rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	entity := m.world.newEntityWith(m.ids, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
		)
	}
	return entity
}

// NewBatch creates a batch of new entities with the mapped components.
func (m *Map6[A, B, C, D, E, F]) NewBatch(count int, a *A, b *B, c *C, d *D, e *E, f *F, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.newEntitiesWith(count, m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
	}, m.relations)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
func (m *Map6[A, B, C, D, E, F]) NewBatchFn(count int, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)
	if fn == nil {
		return
	}

	table := &m.world.storage.tables[tableID]
	columnA := m.storageA.columns[tableID]
	columnB := m.storageB.columns[tableID]
	columnC := m.storageC.columns[tableID]
	columnD := m.storageD.columns[tableID]
	columnE := m.storageE.columns[tableID]
	columnF := m.storageF.columns[tableID]

	lock := m.world.lock()
	for i := range count {
		index := uintptr(start + i)
		fn(
			table.GetEntity(index),
			(*A)(columnA.Get(index)),
			(*B)(columnB.Get(index)),
			(*C)(columnC.Get(index)),
			(*D)(columnD.Get(index)),
			(*E)(columnE.Get(index)),
			(*F)(columnF.Get(index)),
		)
	}
	m.world.unlock(lock)
}

// Get returns the mapped components for the given entity.
//
// ⚠️ Do not store the obtained pointer outside of the current context!
func (m *Map6[A, B, C, D, E, F]) Get(entity Entity) (*A, *B, *C, *D, *E, *F) {
	if !m.world.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	return m.GetUnchecked(entity)
}

// GetUnchecked returns the mapped components for the given entity.
// In contrast to [Map6.Get], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
//
// ⚠️ Do not store the obtained pointer outside of the current context!
func (m *Map6[A, B, C, D, E, F]) GetUnchecked(entity Entity) (*A, *B, *C, *D, *E, *F) {
	m.world.storage.checkHasComponent(entity, m.ids[0])
	m.world.storage.checkHasComponent(entity, m.ids[1])
	m.world.storage.checkHasComponent(entity, m.ids[2])
	m.world.storage.checkHasComponent(entity, m.ids[3])
	m.world.storage.checkHasComponent(entity, m.ids[4])
	m.world.storage.checkHasComponent(entity, m.ids[5])

	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)

	return (*A)(m.storageA.columns[index.table].Get(row)),
		(*B)(m.storageB.columns[index.table].Get(row)),
		(*C)(m.storageC.columns[index.table].Get(row)),
		(*D)(m.storageD.columns[index.table].Get(row)),
		(*E)(m.storageE.columns[index.table].Get(row)),
		(*F)(m.storageF.columns[index.table].Get(row))
}

// HasAll return whether the given entity has all mapped components.
func (m *Map6[A, B, C, D, E, F]) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	index := m.world.storage.entities[entity.id]
	return m.storageA.columns[index.table] != nil &&
		m.storageB.columns[index.table] != nil &&
		m.storageC.columns[index.table] != nil &&
		m.storageD.columns[index.table] != nil &&
		m.storageE.columns[index.table] != nil &&
		m.storageF.columns[index.table] != nil
}

// Add the mapped components to the given entity.
func (m *Map6[A, B, C, D, E, F]) Add(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.exchange(entity, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
	}, m.relations)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
func (m *Map6[A, B, C, D, E, F]) AddFn(entity Entity, fn func(a *A, b *B, c *C, d *D, e *E, f *F), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.exchange(entity, m.ids, nil, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
		)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
func (m *Map6[A, B, C, D, E, F]) AddBatch(batch *Batch, a *A, b *B, c *C, d *D, e *E, f *F, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.exchangeBatch(batch, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
	}, m.relations, nil)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map6[A, B, C, D, E, F]) AddBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]
			columnA := m.storageA.columns[tableID]
			columnB := m.storageB.columns[tableID]
			columnC := m.storageC.columns[tableID]
			columnD := m.storageD.columns[tableID]
			columnE := m.storageE.columns[tableID]
			columnF := m.storageF.columns[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
					(*D)(columnD.Get(index)),
					(*E)(columnE.Get(index)),
					(*F)(columnF.Get(index)),
				)
			}
			m.world.unlock(lock)
		}
	}
	m.world.exchangeBatch(batch, m.ids, nil, nil, m.relations, process)
}

// Remove the mapped components from the given entity.
func (m *Map6[A, B, C, D, E, F]) Remove(entity Entity) {
	m.world.exchange(entity, nil, m.ids, nil, nil)
}

// RemoveBatch removes the mapped components from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map6[A, B, C, D, E, F]) RemoveBatch(batch *Batch, fn func(entity Entity)) {
	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(table.GetEntity(index))
			}
			m.world.unlock(lock)
		}
	}
	m.world.exchangeBatch(batch, nil, m.ids, nil, nil, process)
}

// GetRelation returns the relation target of an entity for the component at the given index.
func (m *Map6[A, B, C, D, E, F]) GetRelation(entity Entity, index int) Entity {
	if !m.world.Alive(entity) {
		panic("can't get entity relation target for a dead entity")
	}
	return m.GetRelationUnchecked(entity, index)
}

// GetRelationUnchecked returns the relation target of an entity for the component at the given index.
// In contrast to [Map6.GetRelation], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map6[A, B, C, D, E, F]) GetRelationUnchecked(entity Entity, index int) Entity {
	return m.world.storage.getRelation(entity, m.ids[index])
}

// SetRelations sets relation targets for the given entity.
func (m *Map6[A, B, C, D, E, F]) SetRelations(entity Entity, rel ...Relation) {
	// alive check is done in World.setRelations
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.setRelations(entity, m.relations)
}

// SetRelationsBatch sets relation targets for all entities matching the given batch filter.
func (m *Map6[A, B, C, D, E, F]) SetRelationsBatch(batch *Batch, fn func(entity Entity), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(table.GetEntity(index))
			}
			m.world.unlock(lock)
		}
	}
	m.world.setRelationsBatch(batch, m.relations, process)
}

// Map7 is a mapper to access 7 components of an entity.
type Map7[A any, B any, C any, D any, E any, F any, G any] struct {
	world     *World
	ids       []ID
	storageA  *componentStorage
	storageB  *componentStorage
	storageC  *componentStorage
	storageD  *componentStorage
	storageE  *componentStorage
	storageF  *componentStorage
	storageG  *componentStorage
	relations []RelationID
}

// NewMap7 creates a new [Map7].
func NewMap7[A any, B any, C any, D any, E any, F any, G any](world *World) Map7[A, B, C, D, E, F, G] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
		ComponentID[F](world),
		ComponentID[G](world),
	}
	return Map7[A, B, C, D, E, F, G]{
		world:    world,
		ids:      ids,
		storageA: &world.storage.components[ids[0].id],
		storageB: &world.storage.components[ids[1].id],
		storageC: &world.storage.components[ids[2].id],
		storageD: &world.storage.components[ids[3].id],
		storageE: &world.storage.components[ids[4].id],
		storageF: &world.storage.components[ids[5].id],
		storageG: &world.storage.components[ids[6].id],
	}
}

// NewEntity creates a new entity with the mapped components.
func (m *Map7[A, B, C, D, E, F, G]) NewEntity(a *A, b *B, c *C, d *D, e *E, f *F, g *G, rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	return m.world.newEntityWith(m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
	}, m.relations)
}

// NewEntityFn creates a new entity with the mapped component and runs a callback instead of using a component for initialization.
// The callback can be nil.
func (m *Map7[A, B, C, D, E, F, G]) NewEntityFn(fn func(a *A, b *B, c *C, d *D, e *E, f *F, g *G), rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	entity := m.world.newEntityWith(m.ids, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
			(*G)(m.storageG.columns[index.table].Get(row)),
		)
	}
	return entity
}

// NewBatch creates a batch of new entities with the mapped components.
func (m *Map7[A, B, C, D, E, F, G]) NewBatch(count int, a *A, b *B, c *C, d *D, e *E, f *F, g *G, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.newEntitiesWith(count, m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
	}, m.relations)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
func (m *Map7[A, B, C, D, E, F, G]) NewBatchFn(count int, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)
	if fn == nil {
		return
	}

	table := &m.world.storage.tables[tableID]
	columnA := m.storageA.columns[tableID]
	columnB := m.storageB.columns[tableID]
	columnC := m.storageC.columns[tableID]
	columnD := m.storageD.columns[tableID]
	columnE := m.storageE.columns[tableID]
	columnF := m.storageF.columns[tableID]
	columnG := m.storageG.columns[tableID]

	lock := m.world.lock()
	for i := range count {
		index := uintptr(start + i)
		fn(
			table.GetEntity(index),
			(*A)(columnA.Get(index)),
			(*B)(columnB.Get(index)),
			(*C)(columnC.Get(index)),
			(*D)(columnD.Get(index)),
			(*E)(columnE.Get(index)),
			(*F)(columnF.Get(index)),
			(*G)(columnG.Get(index)),
		)
	}
	m.world.unlock(lock)
}

// Get returns the mapped components for the given entity.
//
// ⚠️ Do not store the obtained pointer outside of the current context!
func (m *Map7[A, B, C, D, E, F, G]) Get(entity Entity) (*A, *B, *C, *D, *E, *F, *G) {
	if !m.world.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	return m.GetUnchecked(entity)
}

// GetUnchecked returns the mapped components for the given entity.
// In contrast to [Map7.Get], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
//
// ⚠️ Do not store the obtained pointer outside of the current context!
func (m *Map7[A, B, C, D, E, F, G]) GetUnchecked(entity Entity) (*A, *B, *C, *D, *E, *F, *G) {
	m.world.storage.checkHasComponent(entity, m.ids[0])
	m.world.storage.checkHasComponent(entity, m.ids[1])
	m.world.storage.checkHasComponent(entity, m.ids[2])
	m.world.storage.checkHasComponent(entity, m.ids[3])
	m.world.storage.checkHasComponent(entity, m.ids[4])
	m.world.storage.checkHasComponent(entity, m.ids[5])
	m.world.storage.checkHasComponent(entity, m.ids[6])

	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)

	return (*A)(m.storageA.columns[index.table].Get(row)),
		(*B)(m.storageB.columns[index.table].Get(row)),
		(*C)(m.storageC.columns[index.table].Get(row)),
		(*D)(m.storageD.columns[index.table].Get(row)),
		(*E)(m.storageE.columns[index.table].Get(row)),
		(*F)(m.storageF.columns[index.table].Get(row)),
		(*G)(m.storageG.columns[index.table].Get(row))
}

// HasAll return whether the given entity has all mapped components.
func (m *Map7[A, B, C, D, E, F, G]) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	index := m.world.storage.entities[entity.id]
	return m.storageA.columns[index.table] != nil &&
		m.storageB.columns[index.table] != nil &&
		m.storageC.columns[index.table] != nil &&
		m.storageD.columns[index.table] != nil &&
		m.storageE.columns[index.table] != nil &&
		m.storageF.columns[index.table] != nil &&
		m.storageG.columns[index.table] != nil
}

// Add the mapped components to the given entity.
func (m *Map7[A, B, C, D, E, F, G]) Add(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.exchange(entity, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
	}, m.relations)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
func (m *Map7[A, B, C, D, E, F, G]) AddFn(entity Entity, fn func(a *A, b *B, c *C, d *D, e *E, f *F, g *G), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.exchange(entity, m.ids, nil, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
			(*G)(m.storageG.columns[index.table].Get(row)),
		)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
func (m *Map7[A, B, C, D, E, F, G]) AddBatch(batch *Batch, a *A, b *B, c *C, d *D, e *E, f *F, g *G, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.exchangeBatch(batch, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
	}, m.relations, nil)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map7[A, B, C, D, E, F, G]) AddBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]
			columnA := m.storageA.columns[tableID]
			columnB := m.storageB.columns[tableID]
			columnC := m.storageC.columns[tableID]
			columnD := m.storageD.columns[tableID]
			columnE := m.storageE.columns[tableID]
			columnF := m.storageF.columns[tableID]
			columnG := m.storageG.columns[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
					(*D)(columnD.Get(index)),
					(*E)(columnE.Get(index)),
					(*F)(columnF.Get(index)),
					(*G)(columnG.Get(index)),
				)
			}
			m.world.unlock(lock)
		}
	}
	m.world.exchangeBatch(batch, m.ids, nil, nil, m.relations, process)
}

// Remove the mapped components from the given entity.
func (m *Map7[A, B, C, D, E, F, G]) Remove(entity Entity) {
	m.world.exchange(entity, nil, m.ids, nil, nil)
}

// RemoveBatch removes the mapped components from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map7[A, B, C, D, E, F, G]) RemoveBatch(batch *Batch, fn func(entity Entity)) {
	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(table.GetEntity(index))
			}
			m.world.unlock(lock)
		}
	}
	m.world.exchangeBatch(batch, nil, m.ids, nil, nil, process)
}

// GetRelation returns the relation target of an entity for the component at the given index.
func (m *Map7[A, B, C, D, E, F, G]) GetRelation(entity Entity, index int) Entity {
	if !m.world.Alive(entity) {
		panic("can't get entity relation target for a dead entity")
	}
	return m.GetRelationUnchecked(entity, index)
}

// GetRelationUnchecked returns the relation target of an entity for the component at the given index.
// In contrast to [Map7.GetRelation], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map7[A, B, C, D, E, F, G]) GetRelationUnchecked(entity Entity, index int) Entity {
	return m.world.storage.getRelation(entity, m.ids[index])
}

// SetRelations sets relation targets for the given entity.
func (m *Map7[A, B, C, D, E, F, G]) SetRelations(entity Entity, rel ...Relation) {
	// alive check is done in World.setRelations
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.setRelations(entity, m.relations)
}

// SetRelationsBatch sets relation targets for all entities matching the given batch filter.
func (m *Map7[A, B, C, D, E, F, G]) SetRelationsBatch(batch *Batch, fn func(entity Entity), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(table.GetEntity(index))
			}
			m.world.unlock(lock)
		}
	}
	m.world.setRelationsBatch(batch, m.relations, process)
}

// Map8 is a mapper to access 8 components of an entity.
type Map8[A any, B any, C any, D any, E any, F any, G any, H any] struct {
	world     *World
	ids       []ID
	storageA  *componentStorage
	storageB  *componentStorage
	storageC  *componentStorage
	storageD  *componentStorage
	storageE  *componentStorage
	storageF  *componentStorage
	storageG  *componentStorage
	storageH  *componentStorage
	relations []RelationID
}

// NewMap8 creates a new [Map8].
func NewMap8[A any, B any, C any, D any, E any, F any, G any, H any](world *World) Map8[A, B, C, D, E, F, G, H] {
	ids := []ID{
		ComponentID[A](world),
		ComponentID[B](world),
		ComponentID[C](world),
		ComponentID[D](world),
		ComponentID[E](world),
		ComponentID[F](world),
		ComponentID[G](world),
		ComponentID[H](world),
	}
	return Map8[A, B, C, D, E, F, G, H]{
		world:    world,
		ids:      ids,
		storageA: &world.storage.components[ids[0].id],
		storageB: &world.storage.components[ids[1].id],
		storageC: &world.storage.components[ids[2].id],
		storageD: &world.storage.components[ids[3].id],
		storageE: &world.storage.components[ids[4].id],
		storageF: &world.storage.components[ids[5].id],
		storageG: &world.storage.components[ids[6].id],
		storageH: &world.storage.components[ids[7].id],
	}
}

// NewEntity creates a new entity with the mapped components.
func (m *Map8[A, B, C, D, E, F, G, H]) NewEntity(a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	return m.world.newEntityWith(m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
		unsafe.Pointer(h),
	}, m.relations)
}

// NewEntityFn creates a new entity with the mapped component and runs a callback instead of using a component for initialization.
// The callback can be nil.
func (m *Map8[A, B, C, D, E, F, G, H]) NewEntityFn(fn func(a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H), rel ...Relation) Entity {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	entity := m.world.newEntityWith(m.ids, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
			(*G)(m.storageG.columns[index.table].Get(row)),
			(*H)(m.storageH.columns[index.table].Get(row)),
		)
	}
	return entity
}

// NewBatch creates a batch of new entities with the mapped components.
func (m *Map8[A, B, C, D, E, F, G, H]) NewBatch(count int, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.newEntitiesWith(count, m.ids, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
		unsafe.Pointer(h),
	}, m.relations)
}

// NewBatchFn creates a batch of new entities with the mapped components, running the given initializer function on each.
// The initializer function can be nil.
func (m *Map8[A, B, C, D, E, F, G, H]) NewBatchFn(count int, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	tableID, start := m.world.newEntities(count, m.ids, m.relations)
	if fn == nil {
		return
	}

	table := &m.world.storage.tables[tableID]
	columnA := m.storageA.columns[tableID]
	columnB := m.storageB.columns[tableID]
	columnC := m.storageC.columns[tableID]
	columnD := m.storageD.columns[tableID]
	columnE := m.storageE.columns[tableID]
	columnF := m.storageF.columns[tableID]
	columnG := m.storageG.columns[tableID]
	columnH := m.storageH.columns[tableID]

	lock := m.world.lock()
	for i := range count {
		index := uintptr(start + i)
		fn(
			table.GetEntity(index),
			(*A)(columnA.Get(index)),
			(*B)(columnB.Get(index)),
			(*C)(columnC.Get(index)),
			(*D)(columnD.Get(index)),
			(*E)(columnE.Get(index)),
			(*F)(columnF.Get(index)),
			(*G)(columnG.Get(index)),
			(*H)(columnH.Get(index)),
		)
	}
	m.world.unlock(lock)
}

// Get returns the mapped components for the given entity.
//
// ⚠️ Do not store the obtained pointer outside of the current context!
func (m *Map8[A, B, C, D, E, F, G, H]) Get(entity Entity) (*A, *B, *C, *D, *E, *F, *G, *H) {
	if !m.world.Alive(entity) {
		panic("can't get components of a dead entity")
	}
	return m.GetUnchecked(entity)
}

// GetUnchecked returns the mapped components for the given entity.
// In contrast to [Map8.Get], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
//
// ⚠️ Do not store the obtained pointer outside of the current context!
func (m *Map8[A, B, C, D, E, F, G, H]) GetUnchecked(entity Entity) (*A, *B, *C, *D, *E, *F, *G, *H) {
	m.world.storage.checkHasComponent(entity, m.ids[0])
	m.world.storage.checkHasComponent(entity, m.ids[1])
	m.world.storage.checkHasComponent(entity, m.ids[2])
	m.world.storage.checkHasComponent(entity, m.ids[3])
	m.world.storage.checkHasComponent(entity, m.ids[4])
	m.world.storage.checkHasComponent(entity, m.ids[5])
	m.world.storage.checkHasComponent(entity, m.ids[6])
	m.world.storage.checkHasComponent(entity, m.ids[7])

	index := &m.world.storage.entities[entity.id]
	row := uintptr(index.row)

	return (*A)(m.storageA.columns[index.table].Get(row)),
		(*B)(m.storageB.columns[index.table].Get(row)),
		(*C)(m.storageC.columns[index.table].Get(row)),
		(*D)(m.storageD.columns[index.table].Get(row)),
		(*E)(m.storageE.columns[index.table].Get(row)),
		(*F)(m.storageF.columns[index.table].Get(row)),
		(*G)(m.storageG.columns[index.table].Get(row)),
		(*H)(m.storageH.columns[index.table].Get(row))
}

// HasAll return whether the given entity has all mapped components.
func (m *Map8[A, B, C, D, E, F, G, H]) HasAll(entity Entity) bool {
	if !m.world.Alive(entity) {
		panic("can't check components of a dead entity")
	}
	index := m.world.storage.entities[entity.id]
	return m.storageA.columns[index.table] != nil &&
		m.storageB.columns[index.table] != nil &&
		m.storageC.columns[index.table] != nil &&
		m.storageD.columns[index.table] != nil &&
		m.storageE.columns[index.table] != nil &&
		m.storageF.columns[index.table] != nil &&
		m.storageG.columns[index.table] != nil &&
		m.storageH.columns[index.table] != nil
}

// Add the mapped components to the given entity.
func (m *Map8[A, B, C, D, E, F, G, H]) Add(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.exchange(entity, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
		unsafe.Pointer(h),
	}, m.relations)
}

// AddFn adds the mapped components to the given entity and runs a callback instead of using components for initialization.
// The callback can be nil.
func (m *Map8[A, B, C, D, E, F, G, H]) AddFn(entity Entity, fn func(a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.exchange(entity, m.ids, nil, nil, m.relations)
	if fn != nil {
		index := &m.world.storage.entities[entity.id]
		row := uintptr(index.row)
		fn(
			(*A)(m.storageA.columns[index.table].Get(row)),
			(*B)(m.storageB.columns[index.table].Get(row)),
			(*C)(m.storageC.columns[index.table].Get(row)),
			(*D)(m.storageD.columns[index.table].Get(row)),
			(*E)(m.storageE.columns[index.table].Get(row)),
			(*F)(m.storageF.columns[index.table].Get(row)),
			(*G)(m.storageG.columns[index.table].Get(row)),
			(*H)(m.storageH.columns[index.table].Get(row)),
		)
	}
}

// AddBatch adds the mapped components to all entities matching the given batch filter.
func (m *Map8[A, B, C, D, E, F, G, H]) AddBatch(batch *Batch, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.exchangeBatch(batch, m.ids, nil, []unsafe.Pointer{
		unsafe.Pointer(a),
		unsafe.Pointer(b),
		unsafe.Pointer(c),
		unsafe.Pointer(d),
		unsafe.Pointer(e),
		unsafe.Pointer(f),
		unsafe.Pointer(g),
		unsafe.Pointer(h),
	}, m.relations, nil)
}

// AddBatchFn adds the mapped components to all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map8[A, B, C, D, E, F, G, H]) AddBatchFn(batch *Batch, fn func(entity Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]
			columnA := m.storageA.columns[tableID]
			columnB := m.storageB.columns[tableID]
			columnC := m.storageC.columns[tableID]
			columnD := m.storageD.columns[tableID]
			columnE := m.storageE.columns[tableID]
			columnF := m.storageF.columns[tableID]
			columnG := m.storageG.columns[tableID]
			columnH := m.storageH.columns[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(
					table.GetEntity(index),
					(*A)(columnA.Get(index)),
					(*B)(columnB.Get(index)),
					(*C)(columnC.Get(index)),
					(*D)(columnD.Get(index)),
					(*E)(columnE.Get(index)),
					(*F)(columnF.Get(index)),
					(*G)(columnG.Get(index)),
					(*H)(columnH.Get(index)),
				)
			}
			m.world.unlock(lock)
		}
	}
	m.world.exchangeBatch(batch, m.ids, nil, nil, m.relations, process)
}

// Remove the mapped components from the given entity.
func (m *Map8[A, B, C, D, E, F, G, H]) Remove(entity Entity) {
	m.world.exchange(entity, nil, m.ids, nil, nil)
}

// RemoveBatch removes the mapped components from all entities matching the given batch filter,
// running the given function on each. The function can be nil.
func (m *Map8[A, B, C, D, E, F, G, H]) RemoveBatch(batch *Batch, fn func(entity Entity)) {
	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(table.GetEntity(index))
			}
			m.world.unlock(lock)
		}
	}
	m.world.exchangeBatch(batch, nil, m.ids, nil, nil, process)
}

// GetRelation returns the relation target of an entity for the component at the given index.
func (m *Map8[A, B, C, D, E, F, G, H]) GetRelation(entity Entity, index int) Entity {
	if !m.world.Alive(entity) {
		panic("can't get entity relation target for a dead entity")
	}
	return m.GetRelationUnchecked(entity, index)
}

// GetRelationUnchecked returns the relation target of an entity for the component at the given index.
// In contrast to [Map8.GetRelation], it does not check whether the entity is alive.
// Can be used as an optimization when it is certain that the entity is alive.
func (m *Map8[A, B, C, D, E, F, G, H]) GetRelationUnchecked(entity Entity, index int) Entity {
	return m.world.storage.getRelation(entity, m.ids[index])
}

// SetRelations sets relation targets for the given entity.
func (m *Map8[A, B, C, D, E, F, G, H]) SetRelations(entity Entity, rel ...Relation) {
	// alive check is done in World.setRelations
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)
	m.world.setRelations(entity, m.relations)
}

// SetRelationsBatch sets relation targets for all entities matching the given batch filter.
func (m *Map8[A, B, C, D, E, F, G, H]) SetRelationsBatch(batch *Batch, fn func(entity Entity), rel ...Relation) {
	m.relations = relations(rel).toRelations(m.world, m.ids, nil, m.relations)

	var process func(tableID tableID, start, len int)
	if fn != nil {
		process = func(tableID tableID, start, len int) {
			table := &m.world.storage.tables[tableID]

			lock := m.world.lock()
			for i := range len {
				index := uintptr(start + i)
				fn(table.GetEntity(index))
			}
			m.world.unlock(lock)
		}
	}
	m.world.setRelationsBatch(batch, m.relations, process)
}
