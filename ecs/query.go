package ecs

// Code generated by go generate; DO NOT EDIT.

type cursor struct {
	table    int
	index    uintptr
	maxIndex int64
}



// Query0 is a filter for two components.
type Query0 struct {
	world      *World
	mask       Mask
	cursor     cursor
	table      *table
}

// NewQuery0 creates a new [Query0].
func NewQuery0(world *World) Query0 {

	return Query0{
		world:      world,
		mask:       All(),
		cursor: cursor{
			table:    -1,
			index:    0,
			maxIndex: -1,
		},
	}
}

func (q *Query0) Next() bool {
	if int64(q.cursor.index) < q.cursor.maxIndex {
		q.cursor.index++
		return true
	}
	return q.nextTable()
}

func (q *Query0) nextTable() bool {
	maxTableIndex := len(q.world.storage.tables) - 1
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		q.table = &q.world.storage.tables[q.cursor.table]
		archetype := &q.world.storage.archetypes[q.table.archetype]
		if !archetype.mask.Contains(&q.mask) || q.table.entities.Len() == 0 {
			continue
		}

		q.cursor.index = 0
		q.cursor.maxIndex = int64(q.table.entities.Len() - 1)
		return true
	}
	q.cursor.table = -1
	q.cursor.index = 0
	q.cursor.maxIndex = -1
	q.table = nil
	return false
}

func (q *Query0) Entity() Entity {
	return q.table.GetEntity(q.cursor.index)
}

func (q *Query0) Get()  {
	return 
}


// Query1 is a filter for two components.
type Query1[A any] struct {
	world      *World
	mask       Mask
	cursor     cursor
	table      *table
	componentA *componentStorage
	columnA    *column
}

// NewQuery1 creates a new [Query1].
func NewQuery1[A any](world *World) Query1[A] {
	idA := ComponentID[A](world)

	return Query1[A]{
		world:      world,
		mask:       All(idA),
		componentA: &world.storage.components[idA.id],
		cursor: cursor{
			table:    -1,
			index:    0,
			maxIndex: -1,
		},
	}
}

func (q *Query1[A]) Next() bool {
	if int64(q.cursor.index) < q.cursor.maxIndex {
		q.cursor.index++
		return true
	}
	return q.nextTable()
}

func (q *Query1[A]) nextTable() bool {
	maxTableIndex := len(q.world.storage.tables) - 1
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		q.table = &q.world.storage.tables[q.cursor.table]
		archetype := &q.world.storage.archetypes[q.table.archetype]
		if !archetype.mask.Contains(&q.mask) || q.table.entities.Len() == 0 {
			continue
		}
		q.columnA = q.componentA.columns[q.cursor.table]

		q.cursor.index = 0
		q.cursor.maxIndex = int64(q.table.entities.Len() - 1)
		return true
	}
	q.cursor.table = -1
	q.cursor.index = 0
	q.cursor.maxIndex = -1
	q.table = nil
	return false
}

func (q *Query1[A]) Entity() Entity {
	return q.table.GetEntity(q.cursor.index)
}

func (q *Query1[A]) Get() (*A) {
	return (*A)(q.columnA.Get(q.cursor.index))
}


// Query2 is a filter for two components.
type Query2[A any, B any] struct {
	world      *World
	mask       Mask
	cursor     cursor
	table      *table
	componentA *componentStorage
	componentB *componentStorage
	columnA    *column
	columnB    *column
}

// NewQuery2 creates a new [Query2].
func NewQuery2[A any, B any](world *World) Query2[A, B] {
	idA := ComponentID[A](world)
	idB := ComponentID[B](world)

	return Query2[A, B]{
		world:      world,
		mask:       All(idA, idB),
		componentA: &world.storage.components[idA.id],
		componentB: &world.storage.components[idB.id],
		cursor: cursor{
			table:    -1,
			index:    0,
			maxIndex: -1,
		},
	}
}

func (q *Query2[A, B]) Next() bool {
	if int64(q.cursor.index) < q.cursor.maxIndex {
		q.cursor.index++
		return true
	}
	return q.nextTable()
}

func (q *Query2[A, B]) nextTable() bool {
	maxTableIndex := len(q.world.storage.tables) - 1
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		q.table = &q.world.storage.tables[q.cursor.table]
		archetype := &q.world.storage.archetypes[q.table.archetype]
		if !archetype.mask.Contains(&q.mask) || q.table.entities.Len() == 0 {
			continue
		}
		q.columnA = q.componentA.columns[q.cursor.table]
		q.columnB = q.componentB.columns[q.cursor.table]

		q.cursor.index = 0
		q.cursor.maxIndex = int64(q.table.entities.Len() - 1)
		return true
	}
	q.cursor.table = -1
	q.cursor.index = 0
	q.cursor.maxIndex = -1
	q.table = nil
	return false
}

func (q *Query2[A, B]) Entity() Entity {
	return q.table.GetEntity(q.cursor.index)
}

func (q *Query2[A, B]) Get() (*A, *B) {
	return (*A)(q.columnA.Get(q.cursor.index)),
	    (*B)(q.columnB.Get(q.cursor.index))
}


// Query3 is a filter for two components.
type Query3[A any, B any, C any] struct {
	world      *World
	mask       Mask
	cursor     cursor
	table      *table
	componentA *componentStorage
	componentB *componentStorage
	componentC *componentStorage
	columnA    *column
	columnB    *column
	columnC    *column
}

// NewQuery3 creates a new [Query3].
func NewQuery3[A any, B any, C any](world *World) Query3[A, B, C] {
	idA := ComponentID[A](world)
	idB := ComponentID[B](world)
	idC := ComponentID[C](world)

	return Query3[A, B, C]{
		world:      world,
		mask:       All(idA, idB, idC),
		componentA: &world.storage.components[idA.id],
		componentB: &world.storage.components[idB.id],
		componentC: &world.storage.components[idC.id],
		cursor: cursor{
			table:    -1,
			index:    0,
			maxIndex: -1,
		},
	}
}

func (q *Query3[A, B, C]) Next() bool {
	if int64(q.cursor.index) < q.cursor.maxIndex {
		q.cursor.index++
		return true
	}
	return q.nextTable()
}

func (q *Query3[A, B, C]) nextTable() bool {
	maxTableIndex := len(q.world.storage.tables) - 1
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		q.table = &q.world.storage.tables[q.cursor.table]
		archetype := &q.world.storage.archetypes[q.table.archetype]
		if !archetype.mask.Contains(&q.mask) || q.table.entities.Len() == 0 {
			continue
		}
		q.columnA = q.componentA.columns[q.cursor.table]
		q.columnB = q.componentB.columns[q.cursor.table]
		q.columnC = q.componentC.columns[q.cursor.table]

		q.cursor.index = 0
		q.cursor.maxIndex = int64(q.table.entities.Len() - 1)
		return true
	}
	q.cursor.table = -1
	q.cursor.index = 0
	q.cursor.maxIndex = -1
	q.table = nil
	return false
}

func (q *Query3[A, B, C]) Entity() Entity {
	return q.table.GetEntity(q.cursor.index)
}

func (q *Query3[A, B, C]) Get() (*A, *B, *C) {
	return (*A)(q.columnA.Get(q.cursor.index)),
	    (*B)(q.columnB.Get(q.cursor.index)),
	    (*C)(q.columnC.Get(q.cursor.index))
}


// Query4 is a filter for two components.
type Query4[A any, B any, C any, D any] struct {
	world      *World
	mask       Mask
	cursor     cursor
	table      *table
	componentA *componentStorage
	componentB *componentStorage
	componentC *componentStorage
	componentD *componentStorage
	columnA    *column
	columnB    *column
	columnC    *column
	columnD    *column
}

// NewQuery4 creates a new [Query4].
func NewQuery4[A any, B any, C any, D any](world *World) Query4[A, B, C, D] {
	idA := ComponentID[A](world)
	idB := ComponentID[B](world)
	idC := ComponentID[C](world)
	idD := ComponentID[D](world)

	return Query4[A, B, C, D]{
		world:      world,
		mask:       All(idA, idB, idC, idD),
		componentA: &world.storage.components[idA.id],
		componentB: &world.storage.components[idB.id],
		componentC: &world.storage.components[idC.id],
		componentD: &world.storage.components[idD.id],
		cursor: cursor{
			table:    -1,
			index:    0,
			maxIndex: -1,
		},
	}
}

func (q *Query4[A, B, C, D]) Next() bool {
	if int64(q.cursor.index) < q.cursor.maxIndex {
		q.cursor.index++
		return true
	}
	return q.nextTable()
}

func (q *Query4[A, B, C, D]) nextTable() bool {
	maxTableIndex := len(q.world.storage.tables) - 1
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		q.table = &q.world.storage.tables[q.cursor.table]
		archetype := &q.world.storage.archetypes[q.table.archetype]
		if !archetype.mask.Contains(&q.mask) || q.table.entities.Len() == 0 {
			continue
		}
		q.columnA = q.componentA.columns[q.cursor.table]
		q.columnB = q.componentB.columns[q.cursor.table]
		q.columnC = q.componentC.columns[q.cursor.table]
		q.columnD = q.componentD.columns[q.cursor.table]

		q.cursor.index = 0
		q.cursor.maxIndex = int64(q.table.entities.Len() - 1)
		return true
	}
	q.cursor.table = -1
	q.cursor.index = 0
	q.cursor.maxIndex = -1
	q.table = nil
	return false
}

func (q *Query4[A, B, C, D]) Entity() Entity {
	return q.table.GetEntity(q.cursor.index)
}

func (q *Query4[A, B, C, D]) Get() (*A, *B, *C, *D) {
	return (*A)(q.columnA.Get(q.cursor.index)),
	    (*B)(q.columnB.Get(q.cursor.index)),
	    (*C)(q.columnC.Get(q.cursor.index)),
	    (*D)(q.columnD.Get(q.cursor.index))
}


// Query5 is a filter for two components.
type Query5[A any, B any, C any, D any, E any] struct {
	world      *World
	mask       Mask
	cursor     cursor
	table      *table
	componentA *componentStorage
	componentB *componentStorage
	componentC *componentStorage
	componentD *componentStorage
	componentE *componentStorage
	columnA    *column
	columnB    *column
	columnC    *column
	columnD    *column
	columnE    *column
}

// NewQuery5 creates a new [Query5].
func NewQuery5[A any, B any, C any, D any, E any](world *World) Query5[A, B, C, D, E] {
	idA := ComponentID[A](world)
	idB := ComponentID[B](world)
	idC := ComponentID[C](world)
	idD := ComponentID[D](world)
	idE := ComponentID[E](world)

	return Query5[A, B, C, D, E]{
		world:      world,
		mask:       All(idA, idB, idC, idD, idE),
		componentA: &world.storage.components[idA.id],
		componentB: &world.storage.components[idB.id],
		componentC: &world.storage.components[idC.id],
		componentD: &world.storage.components[idD.id],
		componentE: &world.storage.components[idE.id],
		cursor: cursor{
			table:    -1,
			index:    0,
			maxIndex: -1,
		},
	}
}

func (q *Query5[A, B, C, D, E]) Next() bool {
	if int64(q.cursor.index) < q.cursor.maxIndex {
		q.cursor.index++
		return true
	}
	return q.nextTable()
}

func (q *Query5[A, B, C, D, E]) nextTable() bool {
	maxTableIndex := len(q.world.storage.tables) - 1
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		q.table = &q.world.storage.tables[q.cursor.table]
		archetype := &q.world.storage.archetypes[q.table.archetype]
		if !archetype.mask.Contains(&q.mask) || q.table.entities.Len() == 0 {
			continue
		}
		q.columnA = q.componentA.columns[q.cursor.table]
		q.columnB = q.componentB.columns[q.cursor.table]
		q.columnC = q.componentC.columns[q.cursor.table]
		q.columnD = q.componentD.columns[q.cursor.table]
		q.columnE = q.componentE.columns[q.cursor.table]

		q.cursor.index = 0
		q.cursor.maxIndex = int64(q.table.entities.Len() - 1)
		return true
	}
	q.cursor.table = -1
	q.cursor.index = 0
	q.cursor.maxIndex = -1
	q.table = nil
	return false
}

func (q *Query5[A, B, C, D, E]) Entity() Entity {
	return q.table.GetEntity(q.cursor.index)
}

func (q *Query5[A, B, C, D, E]) Get() (*A, *B, *C, *D, *E) {
	return (*A)(q.columnA.Get(q.cursor.index)),
	    (*B)(q.columnB.Get(q.cursor.index)),
	    (*C)(q.columnC.Get(q.cursor.index)),
	    (*D)(q.columnD.Get(q.cursor.index)),
	    (*E)(q.columnE.Get(q.cursor.index))
}


// Query6 is a filter for two components.
type Query6[A any, B any, C any, D any, E any, F any] struct {
	world      *World
	mask       Mask
	cursor     cursor
	table      *table
	componentA *componentStorage
	componentB *componentStorage
	componentC *componentStorage
	componentD *componentStorage
	componentE *componentStorage
	componentF *componentStorage
	columnA    *column
	columnB    *column
	columnC    *column
	columnD    *column
	columnE    *column
	columnF    *column
}

// NewQuery6 creates a new [Query6].
func NewQuery6[A any, B any, C any, D any, E any, F any](world *World) Query6[A, B, C, D, E, F] {
	idA := ComponentID[A](world)
	idB := ComponentID[B](world)
	idC := ComponentID[C](world)
	idD := ComponentID[D](world)
	idE := ComponentID[E](world)
	idF := ComponentID[F](world)

	return Query6[A, B, C, D, E, F]{
		world:      world,
		mask:       All(idA, idB, idC, idD, idE, idF),
		componentA: &world.storage.components[idA.id],
		componentB: &world.storage.components[idB.id],
		componentC: &world.storage.components[idC.id],
		componentD: &world.storage.components[idD.id],
		componentE: &world.storage.components[idE.id],
		componentF: &world.storage.components[idF.id],
		cursor: cursor{
			table:    -1,
			index:    0,
			maxIndex: -1,
		},
	}
}

func (q *Query6[A, B, C, D, E, F]) Next() bool {
	if int64(q.cursor.index) < q.cursor.maxIndex {
		q.cursor.index++
		return true
	}
	return q.nextTable()
}

func (q *Query6[A, B, C, D, E, F]) nextTable() bool {
	maxTableIndex := len(q.world.storage.tables) - 1
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		q.table = &q.world.storage.tables[q.cursor.table]
		archetype := &q.world.storage.archetypes[q.table.archetype]
		if !archetype.mask.Contains(&q.mask) || q.table.entities.Len() == 0 {
			continue
		}
		q.columnA = q.componentA.columns[q.cursor.table]
		q.columnB = q.componentB.columns[q.cursor.table]
		q.columnC = q.componentC.columns[q.cursor.table]
		q.columnD = q.componentD.columns[q.cursor.table]
		q.columnE = q.componentE.columns[q.cursor.table]
		q.columnF = q.componentF.columns[q.cursor.table]

		q.cursor.index = 0
		q.cursor.maxIndex = int64(q.table.entities.Len() - 1)
		return true
	}
	q.cursor.table = -1
	q.cursor.index = 0
	q.cursor.maxIndex = -1
	q.table = nil
	return false
}

func (q *Query6[A, B, C, D, E, F]) Entity() Entity {
	return q.table.GetEntity(q.cursor.index)
}

func (q *Query6[A, B, C, D, E, F]) Get() (*A, *B, *C, *D, *E, *F) {
	return (*A)(q.columnA.Get(q.cursor.index)),
	    (*B)(q.columnB.Get(q.cursor.index)),
	    (*C)(q.columnC.Get(q.cursor.index)),
	    (*D)(q.columnD.Get(q.cursor.index)),
	    (*E)(q.columnE.Get(q.cursor.index)),
	    (*F)(q.columnF.Get(q.cursor.index))
}


// Query7 is a filter for two components.
type Query7[A any, B any, C any, D any, E any, F any, G any] struct {
	world      *World
	mask       Mask
	cursor     cursor
	table      *table
	componentA *componentStorage
	componentB *componentStorage
	componentC *componentStorage
	componentD *componentStorage
	componentE *componentStorage
	componentF *componentStorage
	componentG *componentStorage
	columnA    *column
	columnB    *column
	columnC    *column
	columnD    *column
	columnE    *column
	columnF    *column
	columnG    *column
}

// NewQuery7 creates a new [Query7].
func NewQuery7[A any, B any, C any, D any, E any, F any, G any](world *World) Query7[A, B, C, D, E, F, G] {
	idA := ComponentID[A](world)
	idB := ComponentID[B](world)
	idC := ComponentID[C](world)
	idD := ComponentID[D](world)
	idE := ComponentID[E](world)
	idF := ComponentID[F](world)
	idG := ComponentID[G](world)

	return Query7[A, B, C, D, E, F, G]{
		world:      world,
		mask:       All(idA, idB, idC, idD, idE, idF, idG),
		componentA: &world.storage.components[idA.id],
		componentB: &world.storage.components[idB.id],
		componentC: &world.storage.components[idC.id],
		componentD: &world.storage.components[idD.id],
		componentE: &world.storage.components[idE.id],
		componentF: &world.storage.components[idF.id],
		componentG: &world.storage.components[idG.id],
		cursor: cursor{
			table:    -1,
			index:    0,
			maxIndex: -1,
		},
	}
}

func (q *Query7[A, B, C, D, E, F, G]) Next() bool {
	if int64(q.cursor.index) < q.cursor.maxIndex {
		q.cursor.index++
		return true
	}
	return q.nextTable()
}

func (q *Query7[A, B, C, D, E, F, G]) nextTable() bool {
	maxTableIndex := len(q.world.storage.tables) - 1
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		q.table = &q.world.storage.tables[q.cursor.table]
		archetype := &q.world.storage.archetypes[q.table.archetype]
		if !archetype.mask.Contains(&q.mask) || q.table.entities.Len() == 0 {
			continue
		}
		q.columnA = q.componentA.columns[q.cursor.table]
		q.columnB = q.componentB.columns[q.cursor.table]
		q.columnC = q.componentC.columns[q.cursor.table]
		q.columnD = q.componentD.columns[q.cursor.table]
		q.columnE = q.componentE.columns[q.cursor.table]
		q.columnF = q.componentF.columns[q.cursor.table]
		q.columnG = q.componentG.columns[q.cursor.table]

		q.cursor.index = 0
		q.cursor.maxIndex = int64(q.table.entities.Len() - 1)
		return true
	}
	q.cursor.table = -1
	q.cursor.index = 0
	q.cursor.maxIndex = -1
	q.table = nil
	return false
}

func (q *Query7[A, B, C, D, E, F, G]) Entity() Entity {
	return q.table.GetEntity(q.cursor.index)
}

func (q *Query7[A, B, C, D, E, F, G]) Get() (*A, *B, *C, *D, *E, *F, *G) {
	return (*A)(q.columnA.Get(q.cursor.index)),
	    (*B)(q.columnB.Get(q.cursor.index)),
	    (*C)(q.columnC.Get(q.cursor.index)),
	    (*D)(q.columnD.Get(q.cursor.index)),
	    (*E)(q.columnE.Get(q.cursor.index)),
	    (*F)(q.columnF.Get(q.cursor.index)),
	    (*G)(q.columnG.Get(q.cursor.index))
}


// Query8 is a filter for two components.
type Query8[A any, B any, C any, D any, E any, F any, G any, H any] struct {
	world      *World
	mask       Mask
	cursor     cursor
	table      *table
	componentA *componentStorage
	componentB *componentStorage
	componentC *componentStorage
	componentD *componentStorage
	componentE *componentStorage
	componentF *componentStorage
	componentG *componentStorage
	componentH *componentStorage
	columnA    *column
	columnB    *column
	columnC    *column
	columnD    *column
	columnE    *column
	columnF    *column
	columnG    *column
	columnH    *column
}

// NewQuery8 creates a new [Query8].
func NewQuery8[A any, B any, C any, D any, E any, F any, G any, H any](world *World) Query8[A, B, C, D, E, F, G, H] {
	idA := ComponentID[A](world)
	idB := ComponentID[B](world)
	idC := ComponentID[C](world)
	idD := ComponentID[D](world)
	idE := ComponentID[E](world)
	idF := ComponentID[F](world)
	idG := ComponentID[G](world)
	idH := ComponentID[H](world)

	return Query8[A, B, C, D, E, F, G, H]{
		world:      world,
		mask:       All(idA, idB, idC, idD, idE, idF, idG, idH),
		componentA: &world.storage.components[idA.id],
		componentB: &world.storage.components[idB.id],
		componentC: &world.storage.components[idC.id],
		componentD: &world.storage.components[idD.id],
		componentE: &world.storage.components[idE.id],
		componentF: &world.storage.components[idF.id],
		componentG: &world.storage.components[idG.id],
		componentH: &world.storage.components[idH.id],
		cursor: cursor{
			table:    -1,
			index:    0,
			maxIndex: -1,
		},
	}
}

func (q *Query8[A, B, C, D, E, F, G, H]) Next() bool {
	if int64(q.cursor.index) < q.cursor.maxIndex {
		q.cursor.index++
		return true
	}
	return q.nextTable()
}

func (q *Query8[A, B, C, D, E, F, G, H]) nextTable() bool {
	maxTableIndex := len(q.world.storage.tables) - 1
	for q.cursor.table < maxTableIndex {
		q.cursor.table++
		q.table = &q.world.storage.tables[q.cursor.table]
		archetype := &q.world.storage.archetypes[q.table.archetype]
		if !archetype.mask.Contains(&q.mask) || q.table.entities.Len() == 0 {
			continue
		}
		q.columnA = q.componentA.columns[q.cursor.table]
		q.columnB = q.componentB.columns[q.cursor.table]
		q.columnC = q.componentC.columns[q.cursor.table]
		q.columnD = q.componentD.columns[q.cursor.table]
		q.columnE = q.componentE.columns[q.cursor.table]
		q.columnF = q.componentF.columns[q.cursor.table]
		q.columnG = q.componentG.columns[q.cursor.table]
		q.columnH = q.componentH.columns[q.cursor.table]

		q.cursor.index = 0
		q.cursor.maxIndex = int64(q.table.entities.Len() - 1)
		return true
	}
	q.cursor.table = -1
	q.cursor.index = 0
	q.cursor.maxIndex = -1
	q.table = nil
	return false
}

func (q *Query8[A, B, C, D, E, F, G, H]) Entity() Entity {
	return q.table.GetEntity(q.cursor.index)
}

func (q *Query8[A, B, C, D, E, F, G, H]) Get() (*A, *B, *C, *D, *E, *F, *G, *H) {
	return (*A)(q.columnA.Get(q.cursor.index)),
	    (*B)(q.columnB.Get(q.cursor.index)),
	    (*C)(q.columnC.Get(q.cursor.index)),
	    (*D)(q.columnD.Get(q.cursor.index)),
	    (*E)(q.columnE.Get(q.cursor.index)),
	    (*F)(q.columnF.Get(q.cursor.index)),
	    (*G)(q.columnG.Get(q.cursor.index)),
	    (*H)(q.columnH.Get(q.cursor.index))
}
